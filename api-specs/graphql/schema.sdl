"API Clients can be used to obtain OAuth 2 access tokens. The secret is only shown once in the response of creating the API Client."
type APIClientWithSecret {
  id: String!
  name: String!
  scope: String!
  createdAt: DateTime
  lastUsedAt: Date
  deleteAt: DateTime
  secret: String!
  accessTokenValiditySeconds: Int
  refreshTokenValiditySeconds: Int
}

"API Clients can be used to obtain OAuth 2 access tokens"
type APIClientWithoutSecret {
  id: String!
  name: String!
  scope: String!
  createdAt: DateTime
  lastUsedAt: Date
  deleteAt: DateTime
  accessTokenValiditySeconds: Int
  refreshTokenValiditySeconds: Int
}

type APIClientWithoutSecretQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [APIClientWithoutSecret!]!
}

type AWSLambdaDestination implements ExtensionDestination {
  arn: String!
  accessKey: String!
  accessSecret: String!
  type: String!
}

input AWSLambdaDestinationInput {
  arn: String!
  accessKey: String!
  accessSecret: String!
}

type AbsoluteDiscountValue implements CartDiscountValue & ProductDiscountValue {
  money: [Money!]!
  type: String!
}

input AbsoluteDiscountValueInput {
  money: [MoneyInput!]!
}

enum ActionType {
  Create
  Update
}

"A field to access the active cart."
interface ActiveCartInterface {
  activeCart: Cart
}

input AddAssociateRolePermission {
  permission: Permission!
}

input AddAttributeGroupAttribute {
  attribute: AttributeReferenceInput!
}

input AddBusinessUnitAddress {
  address: AddressInput!
}

input AddBusinessUnitAssociate {
  associate: AssociateDraft!
}

input AddBusinessUnitBillingAddressId {
  addressId: String
  addressKey: String
}

input AddBusinessUnitShippingAddressId {
  addressId: String
  addressKey: String
}

input AddBusinessUnitStore {
  store: ResourceIdentifierInput!
}

input AddCartCustomLineItem {
  priceMode: CustomLineItemPriceMode = Standard
  shippingDetails: ItemShippingDetailsDraft
  custom: CustomFieldsDraft
  quantity: Long
  externalTaxRate: ExternalTaxRateDraft
  taxCategory: ResourceIdentifierInput
  slug: String!
  money: BaseMoneyInput!
  key: String
  name: [LocalizedStringItemInputType!]!
}

input AddCartCustomShippingMethod {
  shippingKey: String!
  shippingMethodName: String!
  shippingAddress: AddressInput!
  shippingRate: ShippingRateDraft!
  shippingRateInput: ShippingRateInputDraft
  taxCategory: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
  custom: CustomFieldsDraft
  deliveries: [DeliveryDraft!] = []
}

input AddCartDiscountCode {
  code: String!
  validateDuplicates: Boolean = false
}

input AddCartDiscountStore {
  store: ResourceIdentifierInput!
}

input AddCartItemShippingAddress {
  address: AddressInput!
}

input AddCartLineItem {
  addedAt: DateTime
  shippingDetails: ItemShippingDetailsDraft
  inventoryMode: InventoryMode
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  externalPrice: BaseMoneyInput
  perMethodExternalTaxRate: [MethodExternalTaxRateDraft!] = []
  externalTaxRate: ExternalTaxRateDraft
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  supplyChannel: ResourceIdentifierInput
  variantId: Int
  quantity: Long
  key: String
  sku: String
  productId: String
}

input AddCartPayment {
  payment: ResourceIdentifierInput!
}

input AddCartShippingMethod {
  shippingKey: String!
  shippingMethod: ResourceIdentifierInput!
  externalTaxRate: ExternalTaxRateDraft
  shippingAddress: AddressInput!
  shippingRateInput: ShippingRateInputDraft
  custom: CustomFieldsDraft
  deliveries: [DeliveryDraft!] = []
}

input AddCartShoppingList {
  shoppingList: ResourceIdentifierInput!
  supplyChannel: ResourceIdentifierInput
  distributionChannel: ResourceIdentifierInput
}

input AddCategoryAsset {
  position: Int
  asset: AssetDraftInput!
}

input AddChannelRoles {
  roles: [ChannelRole!]!
}

input AddCustomerAddress {
  address: AddressInput!
}

input AddCustomerBillingAddressId {
  addressId: String
  addressKey: String
}

input AddCustomerShippingAddressId {
  addressId: String
  addressKey: String
}

input AddCustomerStore {
  store: ResourceIdentifierInput!
}

input AddInventoryEntryQuantity {
  quantity: Long!
}

input AddMyBusinessUnitAddress {
  address: AddressInput!
}

input AddMyBusinessUnitBillingAddressId {
  addressId: String
  addressKey: String
}

input AddMyBusinessUnitShippingAddressId {
  addressId: String
  addressKey: String
}

input AddMyCartLineItem {
  addedAt: DateTime
  shippingDetails: ItemShippingDetailsDraft
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  supplyChannel: ResourceIdentifierInput
  variantId: Int
  quantity: Long
  sku: String
  key: String
  productId: String
}

input AddMyPaymentTransaction {
  transaction: MyTransactionDraft!
}

input AddOrderDelivery {
  deliveryKey: String
  items: [DeliveryItemDraftType!] = []
  parcels: [ParcelDataDraftType!] = []
  address: AddressInput
  custom: CustomFieldsDraft
  shippingKey: String
}

input AddOrderEditStagedAction {
  stagedAction: StagedOrderUpdateAction!
}

input AddOrderItemShippingAddress {
  address: AddressInput!
}

input AddOrderParcelToDelivery {
  deliveryId: String
  deliveryKey: String
  parcelKey: String
  measurements: ParcelMeasurementsDraftType
  trackingData: TrackingDataDraftType
  items: [DeliveryItemDraftType!] = []
  custom: CustomFieldsDraft
}

input AddOrderPayment {
  payment: ResourceIdentifierInput!
}

input AddOrderReturnInfo {
  items: [ReturnItemDraftType!]!
  returnDate: DateTime
  returnTrackingId: String
}

input AddPaymentInterfaceInteraction {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input AddPaymentTransaction {
  transaction: TransactionDraft!
}

input AddProductAsset {
  variantId: Int
  sku: String
  staged: Boolean = true
  position: Int
  asset: AssetDraftInput!
}

input AddProductExternalImage {
  variantId: Int
  sku: String
  image: ImageInput!
  staged: Boolean = true
}

input AddProductPrice {
  variantId: Int
  sku: String
  price: ProductPriceDataInput!
  staged: Boolean = true
}

input AddProductSelectionProduct {
  product: ResourceIdentifierInput!
  variantSelection: ProductVariantSelectionDraft
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input AddProductTailoringAsset {
  variantId: Int
  sku: String
  staged: Boolean = true
  position: Int
  asset: AssetDraftInput!
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input AddProductTailoringExternalImage {
  variantId: Int
  sku: String
  image: ImageInput!
  staged: Boolean = true
}

input AddProductToCategory {
  category: ResourceIdentifierInput!
  orderHint: String
  staged: Boolean = true
}

input AddProductVariant {
  assets: [AssetDraftInput!] = []
  attributes: [ProductAttributeInput!] = []
  images: [ImageInput!] = []
  prices: [ProductPriceDataInput!] = []
  key: String
  sku: String
  staged: Boolean = true
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input AddProductVariantTailoring {
  id: Int
  sku: String
  images: [ImageInput!] = []
  assets: [AssetDraftInput!] = []
  staged: Boolean = true
}

input AddShippingMethodShippingRate {
  zone: ResourceIdentifierInput!
  shippingRate: ShippingRateDraft!
}

input AddShippingMethodZone {
  zone: ResourceIdentifierInput!
}

input AddShoppingListLineItem {
  addedAt: DateTime
  custom: CustomFieldsDraft
  quantity: Int = 1
  variantId: Int
  sku: String
  key: String
  productId: String
}

input AddShoppingListTextLineItem {
  addedAt: DateTime
  custom: CustomFieldsDraft
  quantity: Int = 1
  description: [LocalizedStringItemInputType!]
  name: [LocalizedStringItemInputType!]!
  key: String
}

input AddStagedOrderCustomLineItem {
  priceMode: CustomLineItemPriceMode = Standard
  shippingDetails: ItemShippingDetailsDraftType
  custom: CustomFieldsDraft
  quantity: Long
  externalTaxRate: ExternalTaxRateDraft
  taxCategory: ResourceIdentifierInput
  slug: String!
  money: BaseMoneyInput!
  key: String
  name: [LocalizedStringItemInputType!]!
}

type AddStagedOrderCustomLineItemOutput implements StagedOrderUpdateActionOutput {
  type: String!
  draft: CustomLineItemDraftOutput!
}

input AddStagedOrderDelivery {
  deliveryKey: String
  items: [DeliveryItemDraftType!] = []
  parcels: [ParcelDataDraftType!] = []
  address: AddressInput
  custom: CustomFieldsDraft
  shippingKey: String
}

type AddStagedOrderDeliveryOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryKey: String
  items: [DeliveryItem!]!
  parcels: [ParcelData!]!
  address: AddressDraft
  custom: CustomFieldsCommand
  shippingKey: String
}

input AddStagedOrderDiscountCode {
  code: String!
  validateDuplicates: Boolean = false
}

type AddStagedOrderDiscountCodeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  code: String!
  validateDuplicates: Boolean!
}

input AddStagedOrderItemShippingAddress {
  address: AddressInput!
}

type AddStagedOrderItemShippingAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft!
}

input AddStagedOrderLineItem {
  addedAt: DateTime
  shippingDetails: ItemShippingDetailsDraftType
  inventoryMode: InventoryMode
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  externalPrice: BaseMoneyInput
  perMethodExternalTaxRate: [MethodExternalTaxRateDraft!] = []
  externalTaxRate: ExternalTaxRateDraft
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  supplyChannel: ResourceIdentifierInput
  variantId: Int
  quantity: Long
  key: String
  sku: String
  productId: String
}

type AddStagedOrderLineItemOutput implements StagedOrderUpdateActionOutput {
  type: String!
  draft: LineItemDraftOutput!
}

input AddStagedOrderParcelToDelivery {
  deliveryId: String
  deliveryKey: String
  parcelKey: String
  measurements: ParcelMeasurementsDraftType
  trackingData: TrackingDataDraftType
  items: [DeliveryItemDraftType!] = []
  custom: CustomFieldsDraft
}

type AddStagedOrderParcelToDeliveryOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String
  deliveryKey: String
  parcelKey: String
  measurements: ParcelMeasurements
  trackingData: TrackingData
  items: [DeliveryItem!]!
  custom: CustomFieldsCommand
}

input AddStagedOrderPayment {
  payment: ResourceIdentifierInput!
}

type AddStagedOrderPaymentOutput implements StagedOrderUpdateActionOutput {
  type: String!
  paymentResId: ResourceIdentifier!
}

input AddStagedOrderReturnInfo {
  items: [ReturnItemDraftType!]!
  returnDate: DateTime
  returnTrackingId: String
}

type AddStagedOrderReturnInfoOutput implements StagedOrderUpdateActionOutput {
  type: String!
  items: [ReturnItemDraftTypeOutput!]!
  returnDate: DateTime
  returnTrackingId: String
}

input AddStagedOrderShoppingList {
  shoppingList: ResourceIdentifierInput!
  supplyChannel: ResourceIdentifierInput
  distributionChannel: ResourceIdentifierInput
}

type AddStagedOrderShoppingListOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shoppingListResId: ResourceIdentifier!
  supplyChannelResId: ChannelReferenceIdentifier
  distributionChannelResId: ChannelReferenceIdentifier
}

input AddStandalonePriceTier {
  tier: ProductPriceTierInput!
}

input AddStateRoles {
  roles: [StateRole!]!
}

input AddStoreCountry {
  country: StoreCountryInput!
}

input AddStoreDistributionChannel {
  distributionChannel: ResourceIdentifierInput!
}

input AddStoreProductSelection {
  productSelection: ResourceIdentifierInput!
  active: Boolean
}

input AddStoreSupplyChannel {
  supplyChannel: ResourceIdentifierInput!
}

input AddTypeEnumValue {
  fieldName: String!
  value: EnumValueInput!
}

input AddTypeFieldDefinition {
  fieldDefinition: FieldDefinitionInput!
}

input AddTypeLocalizedEnumValue {
  fieldName: String!
  value: LocalizedEnumValueInput!
}

input AddZoneLocation {
  location: ZoneLocation!
}

"An address represents a postal address."
type Address {
  id: String
  streetName: String
  streetNumber: String
  additionalStreetInfo: String
  postalCode: String
  city: String
  region: String
  state: String
  country: Country!
  company: String
  department: String
  building: String
  apartment: String
  pOBox: String
  additionalAddressInfo: String
  externalId: String
  key: String
  phone: String
  mobile: String
  email: String
  fax: String
  title: String
  salutation: String
  firstName: String
  lastName: String
  custom: CustomFieldsType
}

type AddressDraft {
  id: String
  streetName: String
  streetNumber: String
  additionalStreetInfo: String
  postalCode: String
  city: String
  region: String
  state: String
  country: Country!
  company: String
  department: String
  building: String
  apartment: String
  pOBox: String
  additionalAddressInfo: String
  externalId: String
  key: String
  custom: CustomFieldsCommand
  phone: String
  mobile: String
  email: String
  fax: String
  title: String
  salutation: String
  firstName: String
  lastName: String
}

input AddressInput {
  id: String
  title: String
  salutation: String
  firstName: String
  lastName: String
  streetName: String
  streetNumber: String
  additionalStreetInfo: String
  postalCode: String
  city: String
  region: String
  state: String
  country: Country!
  company: String
  department: String
  building: String
  apartment: String
  pOBox: String
  phone: String
  mobile: String
  email: String
  fax: String
  additionalAddressInfo: String
  externalId: String
  key: String
  custom: CustomFieldsDraft
}

enum AnonymousCartSignInMode {
  """
  `LineItem`s of the anonymous cart will be copied to the customer’s active cart that has been modified most recently.

  The `CartState` of the anonymous cart gets changed to `Merged` while the `CartState` of the customer’s cart remains `Active`.

  `CustomLineItems` and `CustomFields` of the anonymous cart will not be copied to the customers cart.

  If a `LineItem` in the anonymous cart matches an existing line item in the customer’s cart (same product ID and variant ID), the maximum quantity of both LineItems is used as the new quantity. In that case `CustomFields` on the `LineItem` of the anonymous cart will not be in the resulting `LineItem`.
  """
  MergeWithExistingCustomerCart

  "The anonymous cart is used as new active customer cart. No `LineItem`s get merged."
  UseAsNewActiveCustomerCart
}

type Applied implements OrderEditResult {
  appliedAt: DateTime!
  excerptBeforeEdit: OrderExcerpt!
  excerptAfterEdit: OrderExcerpt!
  type: String!
}

input ApplyCartDeltaToCustomLineItemShippingDetailsTargets {
  customLineItemId: String
  customLineItemKey: String
  targetsDelta: [ShippingTargetDraft!]!
}

input ApplyCartDeltaToLineItemShippingDetailsTargets {
  lineItemId: String
  targetsDelta: [ShippingTargetDraft!]!
  lineItemKey: String
}

input ApplyStagedChanges {
  dummy: String
}

type ApprovalFlow implements Versioned {
  status: String!
  approvals: [ApprovalFlowApproval!]!
  rejection: ApprovalFlowRejection
  orderRef: Reference!
  order: Order
  rules: [ApprovalRule!]!
  businessUnitRef: KeyReference!
  businessUnit: BusinessUnit!
  eligibleApprovers: [RuleApprover!]!
  pendingApprovers: [RuleApprover!]!
  currentTierPendingApprovers: [RuleApprover!]!
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type ApprovalFlowApproval {
  approver: Associate!
  approvedAt: DateTime!
}

type ApprovalFlowApproved implements MessagePayload {
  associate: Customer
  order: Order
  associateRef: Reference
  orderRef: Reference
  type: String!
}

type ApprovalFlowCompleted implements MessagePayload {
  status: String!
  order: Order
  orderRef: Reference
  type: String!
}

type ApprovalFlowCreated implements MessagePayload {
  approvalFlow: ApprovalFlow!
  type: String!
}

type ApprovalFlowQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [ApprovalFlow!]!
}

type ApprovalFlowRejected implements MessagePayload {
  rejectionReason: String
  associate: Customer
  order: Order
  associateRef: Reference
  orderRef: Reference
  type: String!
}

type ApprovalFlowRejection {
  rejecter: Associate!
  rejectedAt: DateTime!
  reason: String
}

input ApprovalFlowUpdateAction {
  reject: RejectApprovalFlow
  setCustomField: SetApprovalFlowCustomField
  setCustomType: SetApprovalFlowCustomType
  approve: ApproveApprovalFlow
}

type ApprovalRule implements Versioned {
  key: String
  name: String!
  description: String
  status: ApprovalRuleStatus!
  predicate: String!
  approvers: ApproverHierarchy!
  requesters: [RuleRequester!]!
  businessUnitRef: KeyReference!
  businessUnit: BusinessUnit!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type ApprovalRuleApproversSet implements MessagePayload {
  oldApprovers: ApproverHierarchy!
  approvers: ApproverHierarchy!
  type: String!
}

type ApprovalRuleCreated implements MessagePayload {
  approvalRule: ApprovalRule!
  type: String!
}

type ApprovalRuleDescriptionSet implements MessagePayload {
  oldDescription: String
  description: String
  type: String!
}

input ApprovalRuleDraft {
  key: String
  name: String!
  description: String
  status: ApprovalRuleStatus!
  predicate: String!
  approvers: ApproverHierarchyDraft!
  requesters: [RuleRequesterDraft!]!
}

type ApprovalRuleKeySet implements MessagePayload {
  oldKey: String
  key: String
  type: String!
}

type ApprovalRuleNameSet implements MessagePayload {
  oldName: String!
  name: String!
  type: String!
}

type ApprovalRulePredicateSet implements MessagePayload {
  oldPredicate: String!
  predicate: String!
  type: String!
}

type ApprovalRuleQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [ApprovalRule!]!
}

type ApprovalRuleRequestersSet implements MessagePayload {
  oldRequesters: [RuleRequester!]!
  requesters: [RuleRequester!]!
  type: String!
}

enum ApprovalRuleStatus {
  Active
  Inactive
}

type ApprovalRuleStatusSet implements MessagePayload {
  oldStatus: ApprovalRuleStatus!
  status: ApprovalRuleStatus!
  type: String!
}

input ApprovalRuleUpdateAction {
  setKey: SetApprovalRuleKey
  setName: SetApprovalRuleName
  setDescription: SetApprovalRuleDescription
  setPredicate: SetApprovalRulePredicate
  setRequesters: SetApprovalRuleRequesters
  setStatus: SetApprovalRuleStatus
  setApprovers: SetApprovalRuleApprovers
}

input ApproveApprovalFlow {
  dummy: String
}

type ApproverConjunction {
  and: [ApproverDisjunction!]!
}

input ApproverConjunctionDraft {
  and: [ApproverDisjunctionDraft!]!
}

type ApproverDisjunction {
  or: [RuleApprover!]!
}

input ApproverDisjunctionDraft {
  or: [RuleApproverDraft!]!
}

type ApproverHierarchy {
  tiers: [ApproverConjunction!]!
}

input ApproverHierarchyDraft {
  tiers: [ApproverConjunctionDraft!]!
}

type AsAssociate implements CartQueryInterface & OrderQueryInterface & QuoteQueryInterface & QuoteRequestQueryInterface {
  cart(id: String!): Cart
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  order(
    "Queries with specified ID"
    id: String, orderNumber: String): Order
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
  quoteRequest(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): QuoteRequest
  quoteRequests(where: String, sort: [String!], limit: Int, offset: Int): QuoteRequestQueryResult!
  quote(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Quote
  quotes(where: String, sort: [String!], limit: Int, offset: Int): QuoteQueryResult!
  approvalRule(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ApprovalRule
  approvalRules(where: String, sort: [String!], limit: Int, offset: Int): ApprovalRuleQueryResult!
  approvalFlow(id: String!): ApprovalFlow
  approvalFlows(where: String, sort: [String!], limit: Int, offset: Int): ApprovalFlowQueryResult!
  businessUnit(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): BusinessUnit
  businessUnits(where: String, sort: [String!], limit: Int, offset: Int): BusinessUnitQueryResult!
}

input AsAssociateArgument {
  businessUnitKey: KeyReferenceInput!
  associateId: String!
}

type Asset {
  id: String!
  key: String
  sources: [AssetSource!]!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  tags: [String!]!
  custom: CustomFieldsType
}

type AssetDimensions {
  width: Int!
  height: Int!
}

input AssetDimensionsInput {
  width: Int!
  height: Int!
}

input AssetDraftInput {
  key: String
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  custom: CustomFieldsDraft
  sources: [AssetSourceInput!]
  tags: [String!]
  type: ResourceIdentifierInput
}

type AssetSource {
  uri: String!
  key: String
  dimensions: AssetDimensions
  contentType: String
}

input AssetSourceInput {
  uri: String!
  key: String
  dimensions: AssetDimensionsInput
  contentType: String
}

type Associate {
  associateRoleAssignments: [AssociateRoleAssignment!]!
  customerRef: Reference
  customer: Customer
}

input AssociateDraft {
  customer: ResourceIdentifierInput!
  associateRoleAssignments: [AssociateRoleAssignmentDraft!]
}

enum AssociateInheritanceMode {
  Disabled
  Enabled
}

type AssociateRole implements Versioned & ReferenceExpandable {
  key: String!
  buyerAssignable: Boolean!
  name: String
  permissions: [Permission!]!
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type AssociateRoleAssignment {
  associateRoleRef: KeyReference
  associateRole: AssociateRole!
  inheritance: AssociateInheritanceMode!
}

input AssociateRoleAssignmentDraft {
  associateRole: ResourceIdentifierInput!
  inheritance: AssociateInheritanceMode
}

type AssociateRoleBuyerAssignableChanged implements MessagePayload {
  buyerAssignable: Boolean!
  type: String!
}

type AssociateRoleCreated implements MessagePayload {
  associateRole: AssociateRole!
  type: String!
}

type AssociateRoleDeleted implements MessagePayload {
  type: String!
}

input AssociateRoleDraft {
  key: String!
  name: String
  buyerAssignable: Boolean!
  permissions: [Permission!]
  custom: CustomFieldsDraft
}

type AssociateRoleNameSet implements MessagePayload {
  name: String
  type: String!
}

type AssociateRolePermissionAdded implements MessagePayload {
  permission: Permission!
  type: String!
}

type AssociateRolePermissionRemoved implements MessagePayload {
  permission: Permission!
  type: String!
}

type AssociateRolePermissionsSet implements MessagePayload {
  permissions: [Permission!]
  type: String!
}

type AssociateRoleQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [AssociateRole!]!
}

input AssociateRoleUpdateAction {
  addPermission: AddAssociateRolePermission
  changeBuyerAssignable: ChangeAssociateRoleBuyerAssignable
  removePermission: RemoveAssociateRolePermission
  setCustomField: SetAssociateRoleCustomField
  setCustomType: SetAssociateRoleCustomType
  setName: SetAssociateRoleName
  setPermissions: SetAssociateRolePermissions
}

interface Attribute {
  name: String!
}

enum AttributeConstraint {
  "No constraints are applied to the attribute"
  None

  "Attribute value should be different in each variant"
  Unique

  "A set of attributes, that have this constraint, should have different combinations in each variant"
  CombinationUnique

  "Attribute value should be the same in all variants"
  SameForAll
}

type AttributeDefinition {
  type: AttributeDefinitionType!
  name: String!
  label(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  isRequired: Boolean!
  attributeConstraint: AttributeConstraint!
  inputTip(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  inputHint: TextInputHint!
  isSearchable: Boolean!
  labelAllLocales: [LocalizedString!]!
  inputTipAllLocales: [LocalizedString!]
}

input AttributeDefinitionDraft {
  type: AttributeTypeDraft!
  name: String!
  label: [LocalizedStringItemInputType!]!
  isRequired: Boolean!
  attributeConstraint: AttributeConstraint
  inputTip: [LocalizedStringItemInputType!]
  inputHint: TextInputHint
  isSearchable: Boolean!
}

type AttributeDefinitionResult {
  limit: Int
  offset: Int
  total: Int!
  results: [AttributeDefinition!]!
}

"(https://docs.commercetools.com/api/projects/productTypes#attributetype)[https://docs.commercetools.com/api/projects/productTypes#attributetype]"
interface AttributeDefinitionType {
  name: String!
}

type AttributeGroup implements Versioned {
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  key: String
  attributes: [AttributeReference!]!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

input AttributeGroupDraft {
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  key: String
  attributes: [AttributeReferenceInput!]!
}

type AttributeGroupQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [AttributeGroup!]!
}

input AttributeGroupUpdateAction {
  addAttribute: AddAttributeGroupAttribute
  changeName: ChangeAttributeGroupName
  removeAttribute: RemoveAttributeGroupAttribute
  setDescription: SetAttributeGroupDescription
  setKey: SetAttributeGroupKey
  setAttributes: SetAttributeGroupAttributes
}

type AttributeReference {
  key: String!
}

input AttributeReferenceInput {
  key: String!
}

input AttributeSetElementTypeDraft {
  text: SimpleAttributeTypeDraft
  number: SimpleAttributeTypeDraft
  money: SimpleAttributeTypeDraft
  date: SimpleAttributeTypeDraft
  time: SimpleAttributeTypeDraft
  datetime: SimpleAttributeTypeDraft
  boolean: SimpleAttributeTypeDraft
  reference: ReferenceTypeDefinitionDraft
  enum: EnumTypeDraft
  lenum: LocalizableEnumTypeDraft
  ltext: SimpleAttributeTypeDraft
}

input AttributeSetTypeDraft {
  elementType: AttributeSetElementTypeDraft!
}

input AttributeTypeDraft {
  set: AttributeSetTypeDraft
  text: SimpleAttributeTypeDraft
  number: SimpleAttributeTypeDraft
  money: SimpleAttributeTypeDraft
  date: SimpleAttributeTypeDraft
  time: SimpleAttributeTypeDraft
  datetime: SimpleAttributeTypeDraft
  boolean: SimpleAttributeTypeDraft
  reference: ReferenceTypeDefinitionDraft
  enum: EnumTypeDraft
  lenum: LocalizableEnumTypeDraft
  ltext: SimpleAttributeTypeDraft
}

type Attribution {
  clientId: String
  source: AttributionSource!
  userRef: Reference
}

enum AttributionSource {
  Export
  Import
}

"AuthenticationMode values."
enum AuthenticationMode {
  ExternalAuth
  Password
}

type AuthorizationHeader implements HttpDestinationAuthentication {
  headerValue: String!
  type: String!
}

input AuthorizationHeaderInput {
  headerValue: String!
}

enum AwsAuthenticationMode {
  Credentials
  IAM
}

type AzureFunctionsAuthentication implements HttpDestinationAuthentication {
  key: String!
  type: String!
}

input AzureFunctionsAuthenticationInput {
  key: String!
}

type AzureServiceBusDestination implements Destination {
  connectionString: String!
  type: String!
}

input AzureServiceBusDestinationInput {
  connectionString: String!
}

interface BaseMoney {
  type: String!
  currencyCode: Currency!
  centAmount: Long!
  fractionDigits: Int!
}

input BaseMoneyInput {
  centPrecision: MoneyInput
  highPrecision: HighPrecisionMoneyInput
}

input BaseSearchKeywordInput {
  whitespace: WhitespaceSuggestTokenizerInput
  custom: CustomSuggestTokenizerInput
}

"The `BigDecimal` scalar type represents signed fractional values with arbitrary precision."
scalar BigDecimal

type BooleanAttribute implements Attribute {
  value: Boolean!
  name: String!
}

type BooleanAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type BooleanField implements CustomField {
  value: Boolean!
  name: String!
}

type BooleanType implements FieldType {
  name: String!
}

type BusinessUnit implements Versioned & ReferenceExpandable {
  key: String!
  name: String!
  contactEmail: String
  addresses: [Address!]!
  defaultShippingAddress: Address
  defaultBillingAddress: Address
  defaultShippingAddressId: String
  defaultBillingAddressId: String
  shippingAddresses: [Address!]!
  billingAddresses: [Address!]!
  shippingAddressIds: [String!]!
  billingAddressIds: [String!]!
  status: BusinessUnitStatus!
  storesRef: [KeyReference!]
  stores: [Store!]
  storeMode: String
  unitType: BusinessUnitType!
  associates: [Associate!]!
  associateMode: BusinessUnitAssociateMode!
  inheritedAssociates: [InheritedAssociate!]
  custom: CustomFieldsType
  parentUnitRef: KeyReference
  parentUnit: BusinessUnit

  "This field contains the BusinessUnits KeyReferences from the Company to the parent Division of this BusinessUnit in that order."
  ancestors: [BusinessUnit!]!

  "This field contains the inherited stores from its parentUnit if storeMode is set to FromParent."
  inheritedStores: [InheritedStore!]
  topLevelUnitRef: KeyReference
  topLevelUnit: BusinessUnit!
  approvalRuleMode: BusinessUnitApprovalRuleMode!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type BusinessUnitAddressAdded implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitAddressChanged implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitAddressCustomFieldAdded implements MessagePayload {
  name: String!
  value: Json!
  addressId: String
  type: String!
}

type BusinessUnitAddressCustomFieldChanged implements MessagePayload {
  name: String!
  value: Json!
  oldValue: Json
  addressId: String
  type: String!
}

type BusinessUnitAddressCustomFieldRemoved implements MessagePayload {
  name: String!
  addressId: String
  type: String!
}

type BusinessUnitAddressCustomTypeRemoved implements MessagePayload {
  oldTypeId: String
  addressId: String
  type: String!
}

type BusinessUnitAddressCustomTypeSet implements MessagePayload {
  customFields: CustomFieldsType!
  oldTypeId: String
  addressId: String
  type: String!
}

type BusinessUnitAddressRemoved implements MessagePayload {
  address: Address!
  type: String!
}

enum BusinessUnitApprovalRuleMode {
  Explicit
  ExplicitAndFromParent
}

type BusinessUnitApprovalRuleModeChanged implements MessagePayload {
  approvalRuleMode: BusinessUnitApprovalRuleMode!
  oldApprovalRuleMode: BusinessUnitApprovalRuleMode
  type: String!
}

type BusinessUnitAssociateAdded implements MessagePayload {
  associate: Associate!
  type: String!
}

type BusinessUnitAssociateChanged implements MessagePayload {
  associate: Associate!
  type: String!
}

enum BusinessUnitAssociateMode {
  Explicit
  ExplicitAndFromParent
}

type BusinessUnitAssociateModeChanged implements MessagePayload {
  associateMode: BusinessUnitAssociateMode!
  oldAssociateMode: BusinessUnitAssociateMode
  type: String!
}

type BusinessUnitAssociateRemoved implements MessagePayload {
  associate: Associate!
  type: String!
}

type BusinessUnitAssociatesSet implements MessagePayload {
  associates: [Associate!]!
  type: String!
}

type BusinessUnitBillingAddressAdded implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitBillingAddressRemoved implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitConfiguration {
  myBusinessUnitStatusOnCreation: BusinessUnitConfigurationStatus!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  myBusinessUnitAssociateRoleOnCreationRef: KeyReference

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  myBusinessUnitAssociateRoleOnCreation: AssociateRole
}

enum BusinessUnitConfigurationStatus {
  Active
  Inactive
}

type BusinessUnitContactEmailSet implements MessagePayload {
  contactEmail: String
  type: String!
}

type BusinessUnitCreated implements MessagePayload {
  businessUnit: BusinessUnit!
  type: String!
}

type BusinessUnitCustomFieldAdded implements MessagePayload {
  name: String!
  value: Json!
  type: String!
}

type BusinessUnitCustomFieldChanged implements MessagePayload {
  name: String!
  value: Json!
  oldValue: Json
  type: String!
}

type BusinessUnitCustomFieldRemoved implements MessagePayload {
  name: String!
  type: String!
}

type BusinessUnitCustomTypeRemoved implements MessagePayload {
  oldTypeId: String
  type: String!
}

type BusinessUnitCustomTypeSet implements MessagePayload {
  customFields: CustomFieldsType!
  oldTypeId: String
  type: String!
}

type BusinessUnitDefaultBillingAddressSet implements MessagePayload {
  address: Address
  type: String!
}

type BusinessUnitDefaultShippingAddressSet implements MessagePayload {
  address: Address
  type: String!
}

type BusinessUnitDeleted implements MessagePayload {
  type: String!
}

input BusinessUnitDraft {
  key: String!
  name: String!
  contactEmail: String
  addresses: [AddressInput!]

  "The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address."
  defaultBillingAddress: Int

  "The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address."
  defaultShippingAddress: Int

  "The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses."
  shippingAddresses: [Int!] = []

  "The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses."
  billingAddresses: [Int!] = []
  custom: CustomFieldsDraft
  unitType: BusinessUnitType!
  storeMode: String
  parentUnit: ResourceIdentifierInput
  stores: [ResourceIdentifierInput!]
  associates: [AssociateDraft!]
  associateMode: BusinessUnitAssociateMode
  approvalRuleMode: BusinessUnitApprovalRuleMode
}

type BusinessUnitNameChanged implements MessagePayload {
  name: String!
  type: String!
}

type BusinessUnitParentChanged implements MessagePayload {
  oldParentUnit: BusinessUnit
  newParentUnit: BusinessUnit
  oldParentUnitRef: KeyReference
  newParentUnitRef: KeyReference
  type: String!
}

type BusinessUnitQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [BusinessUnit!]!
}

type BusinessUnitShippingAddressAdded implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitShippingAddressRemoved implements MessagePayload {
  address: Address!
  type: String!
}

enum BusinessUnitStatus {
  Active
  Inactive
}

type BusinessUnitStatusChanged implements MessagePayload {
  status: BusinessUnitStatus!
  type: String!
}

type BusinessUnitStoreAdded implements MessagePayload {
  store: Store!
  storeRef: KeyReference!
  type: String!
}

type BusinessUnitStoreModeChanged implements MessagePayload {
  storeMode: String!
  oldStoreMode: String!
  stores: [Store!]
  oldStores: [Store!]
  storesRef: [KeyReference!]
  oldStoresRef: [KeyReference!]
  type: String!
}

type BusinessUnitStoreRemoved implements MessagePayload {
  store: Store!
  storeRef: KeyReference!
  type: String!
}

type BusinessUnitStoresSet implements MessagePayload {
  stores: [Store!]!
  storesRef: [KeyReference!]!
  type: String!
}

enum BusinessUnitType {
  Company
  Division
}

input BusinessUnitUpdateAction {
  addAddress: AddBusinessUnitAddress
  addAssociate: AddBusinessUnitAssociate
  addBillingAddressId: AddBusinessUnitBillingAddressId
  addShippingAddressId: AddBusinessUnitShippingAddressId
  addStore: AddBusinessUnitStore
  changeAddress: ChangeBusinessUnitAddress
  changeAssociate: ChangeBusinessUnitAssociate
  changeName: ChangeBusinessUnitName
  changeParentUnit: ChangeBusinessUnitParentUnit
  changeStatus: ChangeBusinessUnitStatus
  removeAddress: RemoveBusinessUnitAddress
  removeAssociate: RemoveBusinessUnitAssociate
  removeBillingAddressId: RemoveBusinessUnitBillingAddressId
  removeShippingAddressId: RemoveBusinessUnitShippingAddressId
  removeStore: RemoveBusinessUnitStore
  setAddressCustomField: SetBusinessUnitAddressCustomField
  setAddressCustomType: SetBusinessUnitAddressCustomType
  setAssociates: SetBusinessUnitAssociates
  setContactEmail: SetBusinessUnitContactEmail
  setCustomField: SetBusinessUnitCustomField
  setCustomType: SetBusinessUnitCustomType
  setDefaultBillingAddress: SetBusinessUnitDefaultBillingAddress
  setDefaultShippingAddress: SetBusinessUnitDefaultShippingAddress
  setStores: SetBusinessUnitStores
  setStoreMode: SetBusinessUnitStoreMode
  changeAssociateMode: ChangeBusinessUnitAssociateMode
  changeApprovalRuleMode: ChangeBusinessUnitApprovalRuleMode
}

input CancelQuoteRequest {
  dummy: String
}

"A shopping cart holds product variants and can be ordered. Each cart either belongs to a registered customer or is an anonymous cart."
type Cart implements Versioned & ReferenceExpandable {
  customerId: String
  customer: Customer
  customerEmail: String
  anonymousId: String
  lineItems(
    "Queries with specified ID"
    id: String): [LineItem!]!
  customLineItems: [CustomLineItem!]!
  totalPrice: Money!
  taxedPrice: TaxedPrice
  discountOnTotalPrice: DiscountOnTotalPrice
  shippingAddress: Address
  billingAddress: Address
  inventoryMode: InventoryMode!
  taxMode: TaxMode!
  taxRoundingMode: RoundingMode!
  taxCalculationMode: TaxCalculationMode!
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  country: Country
  shippingKey: String
  shippingInfo: ShippingInfo
  discountCodes: [DiscountCodeInfo!]!
  directDiscounts: [DirectDiscount!]!
  refusedGifts: [CartDiscount!]!
  refusedGiftsRefs: [Reference!]!
  paymentInfo: PaymentInfo
  locale: Locale
  shippingRateInput: ShippingRateInput
  origin: CartOrigin!
  storeRef: KeyReference
  store: Store
  itemShippingAddresses: [Address!]!
  businessUnit: BusinessUnit
  businessUnitRef: KeyReference
  shipping: [Shipping!]!
  taxedShippingPrice: TaxedPrice
  shippingMode: ShippingMode!
  shippingCustomFields: CustomFieldsType
  cartState: CartState!
  key: String
  custom: CustomFieldsType
  deleteDaysAfterLastModification: Int
  totalLineItemQuantity: Long
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

input CartClassificationInput {
  values: [LocalizedEnumValueInput!]!
}

type CartClassificationType implements ShippingRateInputType {
  values: [ShippingRateInputLocalizedEnumValue!]!
  type: String!
}

type CartCreated implements MessagePayload {
  totalPrice: Money!
  lineItemCount: Int!
  discountCodesRefs: [Reference!]!
  type: String!
}

"\nCart discounts are recalculated every time LineItems or CustomLineItems are added or removed from the Cart or an order is created from the cart.\n\nThe number of active cart discounts that do not require a discount code (isActive=true and requiresDiscountCode=false) is limited to 100.\n      "
type CartDiscount implements Versioned & ReferenceExpandable {
  cartPredicate: String!
  validFrom: DateTime
  validUntil: DateTime
  stackingMode: StackingMode!
  isActive: Boolean!
  requiresDiscountCode: Boolean!
  sortOrder: String!
  key: String
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  descriptionAllLocales: [LocalizedString!]
  referenceRefs: [Reference!]!
  custom: CustomFieldsType
  storesRef: [KeyReference!]!
  stores: [Store!]!
  value: CartDiscountValue!
  target: CartDiscountTarget
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type CartDiscountCreated implements MessagePayload {
  cartDiscount: CartDiscount!
  type: String!
}

type CartDiscountDeleted implements MessagePayload {
  type: String!
}

input CartDiscountDraft {
  value: CartDiscountValueInput!
  cartPredicate: String!
  target: CartDiscountTargetInput
  sortOrder: String!
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  validFrom: DateTime
  validUntil: DateTime
  stackingMode: StackingMode = Stacking
  requiresDiscountCode: Boolean = false
  isActive: Boolean = true
  custom: CustomFieldsDraft
  key: String
  stores: [ResourceIdentifierInput!]
}

type CartDiscountLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type CartDiscountLimitsProjection {
  totalActiveWithoutDiscountCodes: CartDiscountLimitWithCurrent!
}

"Fields to access cartDiscounts. Includes direct access to a single cartDiscount and searching for cartDiscounts."
interface CartDiscountQueryInterface {
  cartDiscount(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CartDiscount
  cartDiscounts(where: String, sort: [String!], limit: Int, offset: Int): CartDiscountQueryResult!
}

type CartDiscountQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [CartDiscount!]!
}

type CartDiscountStoreAdded implements MessagePayload {
  store: Store!
  storeRef: KeyReference!
  type: String!
}

type CartDiscountStoreRemoved implements MessagePayload {
  store: Store!
  storeRef: KeyReference!
  type: String!
}

type CartDiscountStoresSet implements MessagePayload {
  storesRef: [KeyReference!]!
  stores: [Store!]!
  type: String!
}

interface CartDiscountTarget {
  type: String!
}

input CartDiscountTargetInput {
  lineItems: LineItemsTargetInput
  customLineItems: CustomLineItemsTargetInput
  shipping: ShippingTargetInput
  multiBuyLineItems: MultiBuyLineItemsTargetInput
  multiBuyCustomLineItems: MultiBuyCustomLineItemsTargetInput
  totalPrice: CartDiscountTotalPriceTargetInput
}

type CartDiscountTotalPriceTarget implements CartDiscountTarget {
  type: String!
}

input CartDiscountTotalPriceTargetInput {
  dummy: String
}

input CartDiscountUpdateAction {
  setStores: SetCartDiscountStores
  addStore: AddCartDiscountStore
  removeStore: RemoveCartDiscountStore
  changeCartPredicate: ChangeCartDiscountCartPredicate
  changeIsActive: ChangeCartDiscountIsActive
  changeName: ChangeCartDiscountName
  changeRequiresDiscountCode: ChangeCartDiscountRequiresDiscountCode
  changeSortOrder: ChangeCartDiscountSortOrder
  changeStackingMode: ChangeCartDiscountStackingMode
  changeTarget: ChangeCartDiscountTarget
  changeValue: ChangeCartDiscountValue
  setCustomField: SetCartDiscountCustomField
  setCustomType: SetCartDiscountCustomType
  setDescription: SetCartDiscountDescription
  setKey: SetCartDiscountKey
  setValidFrom: SetCartDiscountValidFrom
  setValidFromAndUntil: SetCartDiscountValidFromAndUntil
  setValidUntil: SetCartDiscountValidUntil
}

interface CartDiscountValue {
  type: String!
}

input CartDiscountValueBaseMoneyInput {
  centPrecision: MoneyInput
  highPrecision: HighPrecisionMoneyInput

  "CurrencyCode and centAmount are deprecated. Please use `Money`(centPrecision) or `HighPrecisionMoney`(highPrecision)."
  currencyCode: Currency

  "CurrencyCode and centAmount are deprecated. Please use `Money`(centPrecision) or `HighPrecisionMoney`(highPrecision)."
  centAmount: Long
}

input CartDiscountValueInput {
  relative: RelativeDiscountValueInput
  absolute: AbsoluteDiscountValueInput
  fixed: FixedPriceDiscountValueInput
  giftLineItem: GiftLineItemValueInput
}

input CartDraft {
  currency: Currency!
  country: Country
  inventoryMode: InventoryMode = None
  custom: CustomFieldsDraft
  customerEmail: String
  shippingAddress: AddressInput
  billingAddress: AddressInput
  shippingMethod: ResourceIdentifierInput
  taxMode: TaxMode = Platform
  locale: Locale
  deleteDaysAfterLastModification: Int
  itemShippingAddresses: [AddressInput!] = []
  discountCodes: [String!] = []
  store: ResourceIdentifierInput
  businessUnit: ResourceIdentifierInput
  shippingMode: ShippingMode = Single
  customShipping: [CustomShippingDraft!] = []
  shipping: [ShippingDraft!] = []
  key: String
  lineItems: [LineItemDraft!] = []
  customLineItems: [CustomLineItemDraft!] = []
  customerId: String
  externalTaxRateForShippingMethod: ExternalTaxRateDraft
  anonymousId: String
  taxRoundingMode: RoundingMode = HalfEven
  taxCalculationMode: TaxCalculationMode = LineItemLevel
  customerGroup: ResourceIdentifierInput
  shippingRateInput: ShippingRateInputDraft
  origin: CartOrigin = Customer
}

type CartLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type CartLimitsProjection {
  total: CartLimitWithCurrent!
}

enum CartOrigin {
  "The cart was created by the customer. This is the default value"
  Customer

  "The cart was created by the merchant on behalf of the customer"
  Merchant

  "The cart was created by our platform and belongs to a Quote."
  Quote
}

"Fields to access carts. Includes direct access to a single cart and searching for carts."
interface CartQueryInterface {
  cart(id: String!): Cart
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
}

type CartQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Cart!]!
}

input CartScoreInput {
  dummy: String
}

type CartScoreType implements ShippingRateInputType {
  type: String!
}

enum CartState {
  "The cart can be updated and ordered. It is the default state."
  Active

  "The cart is frozen. The cart is ready for checkout and a few update actions are not allowed."
  Frozen

  "Anonymous cart whose content was merged into a customers cart on signin. No further operations on the cart are allowed."
  Merged

  "The cart was ordered. No further operations on the cart are allowed."
  Ordered
}

input CartUpdateAction {
  addCustomLineItem: AddCartCustomLineItem
  addCustomShippingMethod: AddCartCustomShippingMethod
  addDiscountCode: AddCartDiscountCode
  addItemShippingAddress: AddCartItemShippingAddress
  addLineItem: AddCartLineItem
  addPayment: AddCartPayment
  addShippingMethod: AddCartShippingMethod
  addShoppingList: AddCartShoppingList
  applyDeltaToCustomLineItemShippingDetailsTargets: ApplyCartDeltaToCustomLineItemShippingDetailsTargets
  applyDeltaToLineItemShippingDetailsTargets: ApplyCartDeltaToLineItemShippingDetailsTargets
  changeCustomLineItemMoney: ChangeCartCustomLineItemMoney
  changeCustomLineItemPriceMode: ChangeCartCustomLineItemPriceMode
  changeCustomLineItemQuantity: ChangeCartCustomLineItemQuantity
  changeLineItemsOrder: ChangeCartLineItemsOrder
  changeTaxCalculationMode: ChangeCartTaxCalculationMode
  changeTaxMode: ChangeCartTaxMode
  changeTaxRoundingMode: ChangeCartTaxRoundingMode
  recalculate: RecalculateCart
  removeCustomLineItem: RemoveCartCustomLineItem
  removeDiscountCode: RemoveCartDiscountCode
  removeItemShippingAddress: RemoveCartItemShippingAddress
  removeLineItem: RemoveCartLineItem
  removePayment: RemoveCartPayment
  removeShippingMethod: RemoveCartShippingMethod
  setAnonymousId: SetCartAnonymousId
  setBillingAddress: SetCartBillingAddress
  setBillingAddressCustomField: SetCartBillingAddressCustomField
  setBillingAddressCustomType: SetCartBillingAddressCustomType
  setBusinessUnit: SetCartBusinessUnit
  setKey: SetCartKey
  setCartTotalTax: SetCartTotalTax
  setCountry: SetCartCountry
  setCustomField: SetCartCustomField
  setCustomLineItemCustomField: SetCartCustomLineItemCustomField
  setCustomLineItemCustomType: SetCartCustomLineItemCustomType
  setCustomLineItemShippingDetails: SetCartCustomLineItemShippingDetails
  setCustomLineItemTaxAmount: SetCartCustomLineItemTaxAmount
  setCustomLineItemTaxRate: SetCartCustomLineItemTaxRate
  setCustomShippingMethod: SetCartCustomShippingMethod
  setCustomType: SetCartCustomType
  setCustomerEmail: SetCartCustomerEmail
  setCustomerGroup: SetCartCustomerGroup
  setCustomerId: SetCartCustomerId
  setDeleteDaysAfterLastModification: SetCartDeleteDaysAfterLastModification
  setDirectDiscounts: SetCartDirectDiscounts
  setItemShippingAddressCustomField: SetCartItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetCartItemShippingAddressCustomType
  setLineItemCustomField: SetCartLineItemCustomField
  setLineItemCustomType: SetCartLineItemCustomType
  setLineItemDistributionChannel: SetCartLineItemDistributionChannel
  setLineItemInventoryMode: SetCartLineItemInventoryMode
  setLineItemPrice: SetCartLineItemPrice
  setLineItemShippingDetails: SetCartLineItemShippingDetails
  setLineItemSupplyChannel: SetCartLineItemSupplyChannel
  setLineItemTaxAmount: SetCartLineItemTaxAmount
  setLineItemTaxRate: SetCartLineItemTaxRate
  setLineItemTotalPrice: SetCartLineItemTotalPrice
  setLocale: SetCartLocale
  setShippingAddress: SetCartShippingAddress
  setShippingAddressCustomField: SetCartShippingAddressCustomField
  setShippingAddressCustomType: SetCartShippingAddressCustomType
  setShippingCustomField: SetCartShippingCustomField
  setShippingCustomType: SetCartShippingCustomType
  setShippingMethod: SetCartShippingMethod
  setShippingMethodTaxAmount: SetCartShippingMethodTaxAmount
  setShippingMethodTaxRate: SetCartShippingMethodTaxRate
  setShippingRateInput: SetCartShippingRateInput
  updateItemShippingAddress: UpdateCartItemShippingAddress
  freezeCart: FreezeCart
  unfreezeCart: UnfreezeCart
  changeLineItemQuantity: ChangeCartLineItemQuantity
}

input CartValueInput {
  dummy: String
}

type CartValueType implements ShippingRateInputType {
  type: String!
}

type CartsConfiguration {
  deleteDaysAfterLastModification: Int
  allowAddingUnpublishedProducts: Boolean!
  countryTaxRateFallbackEnabled: Boolean!
}

input CartsConfigurationInput {
  deleteDaysAfterLastModification: Int
}

type Category implements Versioned & ReferenceExpandable {
  id: String!
  key: String
  version: Long!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  ancestorsRef: [Reference!]!
  ancestors: [Category!]!
  parentRef: Reference
  parent: Category
  orderHint: String!
  externalId: String
  metaTitle(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaKeywords(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaDescription(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]

  "Number of staged products in the category subtree."
  stagedProductCount: Int!

  "Number of direct child categories."
  childCount: Int!

  "Direct child categories."
  children: [Category!]
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  assets: [Asset!]!
  custom: CustomFieldsType
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type CategoryCreated implements MessagePayload {
  category: Category!
  type: String!
}

input CategoryDraft {
  key: String
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  custom: CustomFieldsDraft
  slug: [LocalizedStringItemInputType!]!
  externalId: String
  metaTitle: [LocalizedStringItemInputType!]
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  orderHint: String
  parent: ResourceIdentifierInput
  assets: [AssetDraftInput!] = []
}

type CategoryLimitsProjection {
  maxCategories: Limit!
}

type CategoryOrderHint {
  categoryId: String!
  orderHint: String!
}

input CategoryOrderHintInput {
  uuid: String!
  orderHint: String!
}

type CategoryOrderHintProductSearch {
  categoryId: String!
  orderHint: String!
}

type CategoryQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Category!]!
}

type CategorySlugChanged implements MessagePayload {
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  oldSlug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  oldSlugAllLocales: [LocalizedString!]
  type: String!
}

input CategoryUpdateAction {
  addAsset: AddCategoryAsset
  changeAssetName: ChangeCategoryAssetName
  changeAssetOrder: ChangeCategoryAssetOrder
  changeName: ChangeCategoryName
  changeOrderHint: ChangeCategoryOrderHint
  changeSlug: ChangeCategorySlug
  changeParent: ChangeCategoryParent
  removeAsset: RemoveCategoryAsset
  setAssetCustomField: SetCategoryAssetCustomField
  setAssetCustomType: SetCategoryAssetCustomType
  setAssetDescription: SetCategoryAssetDescription
  setAssetKey: SetCategoryAssetKey
  setAssetSources: SetCategoryAssetSources
  setAssetTags: SetCategoryAssetTags
  setCustomField: SetCategoryCustomField
  setCustomType: SetCategoryCustomType
  setDescription: SetCategoryDescription
  setKey: SetCategoryKey
  setMetaDescription: SetCategoryMetaDescription
  setMetaKeywords: SetCategoryMetaKeywords
  setMetaTitle: SetCategoryMetaTitle
  setExternalId: SetCategoryExternalId
}

input ChangeAssociateRoleBuyerAssignable {
  buyerAssignable: Boolean!
}

input ChangeAttributeGroupName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeBusinessUnitAddress {
  addressId: String
  addressKey: String
  address: AddressInput!
}

input ChangeBusinessUnitApprovalRuleMode {
  approvalRuleMode: BusinessUnitApprovalRuleMode!
}

input ChangeBusinessUnitAssociate {
  associate: AssociateDraft!
}

input ChangeBusinessUnitAssociateMode {
  associateMode: BusinessUnitAssociateMode!
}

input ChangeBusinessUnitName {
  name: String!
}

input ChangeBusinessUnitParentUnit {
  parentUnit: ResourceIdentifierInput!
}

input ChangeBusinessUnitStatus {
  status: BusinessUnitStatus!
}

input ChangeCartCustomLineItemMoney {
  customLineItemId: String
  customLineItemKey: String
  money: BaseMoneyInput!
}

input ChangeCartCustomLineItemPriceMode {
  customLineItemId: String
  customLineItemKey: String
  mode: CustomLineItemPriceMode!
}

input ChangeCartCustomLineItemQuantity {
  customLineItemId: String
  customLineItemKey: String
  quantity: Long!
}

input ChangeCartDiscountCartPredicate {
  cartPredicate: String!
}

input ChangeCartDiscountIsActive {
  isActive: Boolean!
}

input ChangeCartDiscountName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeCartDiscountRequiresDiscountCode {
  requiresDiscountCode: Boolean!
}

input ChangeCartDiscountSortOrder {
  sortOrder: String!
}

input ChangeCartDiscountStackingMode {
  stackingMode: StackingMode!
}

input ChangeCartDiscountTarget {
  target: CartDiscountTargetInput!
}

input ChangeCartDiscountValue {
  value: CartDiscountValueInput!
}

input ChangeCartLineItemQuantity {
  lineItemId: String
  lineItemKey: String
  quantity: Long!

  "Only valid for the general Carts API. Ignored for the My Carts API."
  externalPrice: BaseMoneyInput

  "Only valid for the general Carts API. Ignored for the My Carts API."
  externalTotalPrice: ExternalLineItemTotalPriceDraft
}

input ChangeCartLineItemsOrder {
  lineItemOrder: [String!]!
}

input ChangeCartTaxCalculationMode {
  taxCalculationMode: TaxCalculationMode!
}

input ChangeCartTaxMode {
  taxMode: TaxMode!
}

input ChangeCartTaxRoundingMode {
  taxRoundingMode: RoundingMode!
}

input ChangeCategoryAssetName {
  name: [LocalizedStringItemInputType!]!
  assetKey: String
  assetId: String
}

input ChangeCategoryAssetOrder {
  assetOrder: [String!]!
}

input ChangeCategoryName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeCategoryOrderHint {
  orderHint: String!
}

input ChangeCategoryParent {
  parent: ResourceIdentifierInput!
}

input ChangeCategorySlug {
  slug: [LocalizedStringItemInputType!]!
}

input ChangeChannelDescription {
  description: [LocalizedStringItemInputType!]
}

input ChangeChannelKey {
  key: String!
}

input ChangeChannelName {
  name: [LocalizedStringItemInputType!]
}

input ChangeCustomerAddress {
  addressId: String
  addressKey: String
  address: AddressInput!
}

input ChangeCustomerEmail {
  email: String!
}

input ChangeCustomerGroupName {
  name: String!
}

input ChangeDiscountCodeCartDiscounts {
  cartDiscounts: [ResourceIdentifierInput!]!
}

input ChangeDiscountCodeGroups {
  groups: [String!]!
}

input ChangeDiscountCodeIsActive {
  isActive: Boolean!
}

input ChangeExtensionDestination {
  destination: ExtensionDestinationInput!
}

input ChangeExtensionTriggers {
  triggers: [TriggerInput!]!
}

input ChangeInventoryEntryQuantity {
  quantity: Long!
}

input ChangeMyBusinessUnitAddress {
  addressId: String
  addressKey: String
  address: AddressInput!
}

input ChangeMyBusinessUnitAssociate {
  associate: AssociateDraft!
}

input ChangeMyBusinessUnitName {
  name: String!
}

input ChangeMyBusinessUnitParentUnit {
  parentUnit: ResourceIdentifierInput!
}

input ChangeMyCartTaxMode {
  taxMode: TaxMode!
}

input ChangeMyQuoteMyQuoteState {
  quoteState: MyQuoteState!
}

input ChangeOrderPaymentState {
  paymentState: PaymentState!
}

input ChangeOrderShipmentState {
  shipmentState: ShipmentState!
}

input ChangeOrderState {
  orderState: OrderState!
}

input ChangePaymentAmountPlanned {
  amount: MoneyInput!
}

input ChangePaymentTransactionInteractionId {
  transactionId: String!
  interactionId: String!
}

input ChangePaymentTransactionState {
  transactionId: String!
  state: TransactionState!
}

input ChangePaymentTransactionTimestamp {
  transactionId: String!
  timestamp: DateTime!
}

input ChangeProductAssetName {
  variantId: Int
  sku: String
  staged: Boolean = true
  name: [LocalizedStringItemInputType!]!
  assetKey: String
  assetId: String
}

input ChangeProductAssetOrder {
  variantId: Int
  sku: String
  staged: Boolean = true
  assetOrder: [String!]!
}

input ChangeProductDiscountIsActive {
  isActive: Boolean!
}

input ChangeProductDiscountName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeProductDiscountPredicate {
  predicate: String!
}

input ChangeProductDiscountSortOrder {
  sortOrder: String!
}

input ChangeProductDiscountValue {
  value: ProductDiscountValueInput!
}

input ChangeProductImageLabel {
  variantId: Int
  sku: String
  imageUrl: String!
  label: String
  staged: Boolean = true
}

input ChangeProductMasterVariant {
  variantId: Int
  sku: String
  staged: Boolean = true
}

input ChangeProductName {
  name: [LocalizedStringItemInputType!]!
  staged: Boolean = true
}

input ChangeProductPrice {
  priceId: String
  variantId: Int
  sku: String
  price: ProductPriceDataInput!
  staged: Boolean = true
}

input ChangeProductSelectionName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeProductSlug {
  slug: [LocalizedStringItemInputType!]!
  staged: Boolean = true
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input ChangeProductTailoringAssetName {
  variantId: Int
  sku: String
  staged: Boolean = true
  name: [LocalizedStringItemInputType!]!
  assetKey: String
  assetId: String
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input ChangeProductTailoringAssetOrder {
  variantId: Int
  sku: String
  staged: Boolean = true
  assetOrder: [String!]!
}

input ChangeProjectSettingsCartsConfiguration {
  cartsConfiguration: CartsConfigurationInput!
}

input ChangeProjectSettingsCountries {
  countries: [Country!]!
}

input ChangeProjectSettingsCountryTaxRateFallbackEnabled {
  countryTaxRateFallbackEnabled: Boolean!
}

input ChangeProjectSettingsCurrencies {
  currencies: [Currency!]!
}

input ChangeProjectSettingsLanguages {
  languages: [Locale!]!
}

input ChangeProjectSettingsMessagesConfiguration {
  messagesConfiguration: MessagesConfigurationDraft!
}

input ChangeProjectSettingsMessagesEnabled {
  messagesEnabled: Boolean!
}

input ChangeProjectSettingsMyBusinessUnitStatusOnCreation {
  status: BusinessUnitConfigurationStatus!
}

input ChangeProjectSettingsName {
  name: String!
}

input ChangeProjectSettingsOrderSearchStatus {
  status: OrderSearchStatus!
}

input ChangeProjectSettingsProductSearchIndexingEnabled {
  enabled: Boolean!
}

input ChangeProjectSettingsShoppingListsConfiguration {
  shoppingListsConfiguration: ShoppingListsConfigurationInput!
}

input ChangeQuoteCustomer {
  customer: ResourceIdentifierInput!
}

input ChangeQuoteRequestCustomer {
  customer: ResourceIdentifierInput!
}

input ChangeQuoteRequestState {
  quoteRequestState: QuoteRequestState!
}

input ChangeQuoteState {
  quoteState: QuoteState!
}

input ChangeShippingMethodActive {
  active: Boolean!
}

input ChangeShippingMethodIsDefault {
  isDefault: Boolean!
}

input ChangeShippingMethodName {
  name: String!
}

input ChangeShippingMethodTaxCategory {
  taxCategory: ResourceIdentifierInput!
}

input ChangeShoppingListLineItemQuantity {
  lineItemId: String
  lineItemKey: String
  quantity: Int!
}

input ChangeShoppingListLineItemsOrder {
  lineItemOrder: [String!]!
}

input ChangeShoppingListName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeShoppingListTextLineItemName {
  textLineItemId: String
  textLineItemKey: String
  name: [LocalizedStringItemInputType!]!
}

input ChangeShoppingListTextLineItemQuantity {
  textLineItemId: String
  textLineItemKey: String
  quantity: Int!
}

input ChangeShoppingListTextLineItemsOrder {
  textLineItemOrder: [String!]!
}

input ChangeStagedOrderCustomLineItemMoney {
  customLineItemId: String
  customLineItemKey: String
  money: BaseMoneyInput!
}

type ChangeStagedOrderCustomLineItemMoneyOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String
  customLineItemKey: String
  money: BaseMoney!
}

input ChangeStagedOrderCustomLineItemQuantity {
  customLineItemId: String
  customLineItemKey: String
  quantity: Long!
}

type ChangeStagedOrderCustomLineItemQuantityOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String
  customLineItemKey: String
  quantity: Long!
}

input ChangeStagedOrderLineItemQuantity {
  lineItemId: String
  quantity: Long!
  lineItemKey: String
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
}

type ChangeStagedOrderLineItemQuantityOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  quantity: Long!
  lineItemKey: String
  externalPrice: BaseMoney
  externalTotalPrice: ExternalLineItemTotalPrice
}

input ChangeStagedOrderOrderState {
  orderState: OrderState!
}

type ChangeStagedOrderOrderStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  orderState: OrderState!
}

input ChangeStagedOrderPaymentState {
  paymentState: PaymentState!
}

type ChangeStagedOrderPaymentStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  paymentState: PaymentState!
}

input ChangeStagedOrderShipmentState {
  shipmentState: ShipmentState!
}

type ChangeStagedOrderShipmentStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shipmentState: ShipmentState!
}

input ChangeStagedOrderTaxCalculationMode {
  taxCalculationMode: TaxCalculationMode!
}

type ChangeStagedOrderTaxCalculationModeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  taxCalculationMode: TaxCalculationMode!
}

input ChangeStagedOrderTaxMode {
  taxMode: TaxMode!
}

type ChangeStagedOrderTaxModeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  taxMode: TaxMode!
}

input ChangeStagedOrderTaxRoundingMode {
  taxRoundingMode: RoundingMode!
}

type ChangeStagedOrderTaxRoundingModeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  taxRoundingMode: RoundingMode!
}

input ChangeStagedQuoteState {
  stagedQuoteState: StagedQuoteState!
}

input ChangeStandalonePriceActive {
  active: Boolean!
}

input ChangeStandalonePriceValue {
  value: BaseMoneyInput!

  "default is `false`"
  staged: Boolean
}

input ChangeStateInitial {
  initial: Boolean!
}

input ChangeStateKey {
  key: String!
}

input ChangeStateType {
  type: StateType!
}

input ChangeStoreProductSelectionActive {
  productSelection: ResourceIdentifierInput!
  active: Boolean!
}

type ChangeSubscription {
  resourceTypeId: String!
}

input ChangeSubscriptionDestination {
  destination: DestinationInput!
}

input ChangeSubscriptionInput {
  resourceTypeId: String!
}

input ChangeTypeEnumValueLabel {
  fieldName: String!
  value: EnumValueInput!
}

input ChangeTypeEnumValueOrder {
  fieldName: String!
  keys: [String!]!
}

input ChangeTypeFieldDefinitionOrder {
  fieldNames: [String!]!
}

input ChangeTypeInputHint {
  fieldName: String!
  inputHint: TextInputHint!
}

input ChangeTypeKey {
  key: String!
}

input ChangeTypeLabel {
  fieldName: String!
  label: [LocalizedStringItemInputType!]!
}

input ChangeTypeLocalizedEnumValueLabel {
  fieldName: String!
  value: LocalizedEnumValueInput!
}

input ChangeTypeLocalizedEnumValueOrder {
  fieldName: String!
  keys: [String!]!
}

input ChangeTypeName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeZoneName {
  name: String!
}

type Channel implements Versioned & ReviewTarget & ReferenceExpandable {
  id: String!
  version: Long!
  key: String!
  roles: [ChannelRole!]!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  address: Address
  geoLocation: Geometry
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  reviewRatingStatistics: ReviewRatingStatistics
  custom: CustomFieldsType
  createdBy: Initiator
  lastModifiedBy: Initiator
}

input ChannelDraft {
  key: String!
  roles: [ChannelRole!]!
  name: [LocalizedStringItemInputType!]
  description: [LocalizedStringItemInputType!]
  custom: CustomFieldsDraft
  address: AddressInput
  geoLocation: GeometryInput
}

type ChannelQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Channel!]!
}

type ChannelReferenceIdentifier {
  typeId: String!
  id: String
  key: String
}

enum ChannelRole {
  "Role tells that this channel can be used to track inventory entries.Channels with this role can be treated as warehouses"
  InventorySupply

  "Role tells that this channel can be used to expose products to a specific distribution channel. It can be used by the cart to select a product price."
  ProductDistribution

  "Role tells that this channel can be used to track order export activities."
  OrderExport

  "Role tells that this channel can be used to track order import activities."
  OrderImport

  "This role can be combined with some other roles (e.g. with `InventorySupply`) to represent the fact that this particular channel is the primary/master channel among the channels of the same type."
  Primary
}

input ChannelUpdateAction {
  addRoles: AddChannelRoles
  changeDescription: ChangeChannelDescription
  changeKey: ChangeChannelKey
  changeName: ChangeChannelName
  removeRoles: RemoveChannelRoles
  setAddress: SetChannelAddress
  setAddressCustomField: SetChannelAddressCustomField
  setAddressCustomType: SetChannelAddressCustomType
  setCustomField: SetChannelCustomField
  setCustomType: SetChannelCustomType
  setGeoLocation: SetChannelGeoLocation
  setRoles: SetChannelRoles
}

type ClassificationShippingRateInput implements ShippingRateInput {
  key: String!
  type: String!
  labelAllLocales: [LocalizedString!]!
  label(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
}

input ClassificationShippingRateInputDraft {
  key: String!
}

type ClassificationShippingRateInputDraftOutput implements ShippingRateInputDraftOutput {
  key: String!
  type: String!
}

type CloudEventsSubscriptionsFormat implements NotificationFormat {
  type: String!
  cloudEventsVersion: String!
}

input CloudEventsSubscriptionsFormatInput {
  cloudEventsVersion: String!
}

type CommercetoolsSubscription implements Versioned {
  key: String
  destination: Destination!
  messages: [MessageSubscription!]!
  changes: [ChangeSubscription!]!
  format: NotificationFormat!
  status: SubscriptionHealthStatus!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type CommercetoolsSubscriptionQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [CommercetoolsSubscription!]!
}

type ConfluentCloudDestination implements Destination {
  bootstrapServer: String!
  apiKey: String!
  apiSecret: String!
  acks: String!
  topic: String!
  key: String
  type: String!
}

input ConfluentCloudDestinationInput {
  bootstrapServer: String!
  apiKey: String!
  apiSecret: String!
  acks: String!
  topic: String!
  key: String
}

"[ISO 3166-1](http://en.wikipedia.org/wiki/ISO_3166-1) country code."
scalar Country

input CreateApiClient {
  name: String!
  scope: String!
  deleteDaysAfterCreation: Int
  accessTokenValiditySeconds: Int
  refreshTokenValiditySeconds: Int
}

input CreateProductSelectionDraft {
  key: String
  name: [LocalizedStringItemInputType!]!
  mode: ProductSelectionMode
  custom: CustomFieldsDraft
}

input CreateStandalonePrice {
  key: String
  sku: String!
  value: BaseMoneyInput!
  staged: StagedPriceDraft
  country: Country
  customerGroup: ResourceIdentifierInput
  channel: ResourceIdentifierInput
  validFrom: DateTime
  validUntil: DateTime
  tiers: [ProductPriceTierInput!] = []
  custom: CustomFieldsDraft
  discounted: DiscountedProductPriceValueInput
  active: Boolean! = true
}

input CreateStore {
  key: String!
  name: [LocalizedStringItemInputType!]
  languages: [Locale!]
  countries: [StoreCountryInput!]
  distributionChannels: [ResourceIdentifierInput!]
  supplyChannels: [ResourceIdentifierInput!]
  productSelections: [ProductSelectionSettingDraft!]
  custom: CustomFieldsDraft
}

input CreateZone {
  name: String!
  key: String
  description: String
  locations: [ZoneLocation!] = []
}

"Represents a currency. Currencies are identified by their [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm) currency codes."
scalar Currency

interface CustomField {
  name: String!
}

"""
A key-value pair representing the field name and value of one single custom field.

The value of this custom field consists of escaped JSON based on the FieldDefinition of the Type.


Examples for `value`:

* FieldType `String`: `"\"This is a string\""`
* FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
* FieldType `Number`: `"4"`
* FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
* FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
"""
input CustomFieldInput {
  name: String!

  """
  The value of this custom field consists of escaped JSON based on the FieldDefinition of the Type.


  Examples for `value`:

  * FieldType `String`: `"\"This is a string\""`
  * FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
  * FieldType `Number`: `"4"`
  * FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
  * FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
  """
  value: String!
}

type CustomFieldsCommand {
  typeId: String
  typeKey: String
  fields: Json!
  typeResId: ResourceIdentifier
}

input CustomFieldsDraft {
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
}

type CustomFieldsType {
  typeRef: Reference!
  type: TypeDefinition

  "This field contains non-typed data."
  customFieldsRaw(
    """
    The names of the custom fields to include.

    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    includeNames: [String!],

    """
    The names of the custom fields to exclude.

    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    excludeNames: [String!]): [RawCustomField!]
}

"A custom line item is a generic item that can be added to the cart but is not bound to a product. You can use it for discounts (negative money), vouchers, complex cart rules, additional services or fees. You control the lifecycle of this item."
type CustomLineItem {
  id: String!
  key: String
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  money: BaseMoney!
  totalPrice: Money!
  slug: String!
  quantity: Long!
  state: [ItemState!]!
  taxCategory: TaxCategory
  taxCategoryRef: Reference
  taxRate: TaxRate
  taxedPrice: TaxedItemPrice
  taxedPricePortions: [MethodTaxedPrice!]!
  perMethodTaxRate: [MethodTaxRate!]!
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  custom: CustomFieldsType
  shippingDetails: ItemShippingDetails
  priceMode: CustomLineItemPriceMode!
}

input CustomLineItemDraft {
  name: [LocalizedStringItemInputType!]!
  key: String
  money: BaseMoneyInput!
  slug: String!
  taxCategory: ReferenceInput
  externalTaxRate: ExternalTaxRateDraft
  quantity: Long
  custom: CustomFieldsDraft
  shippingDetails: ItemShippingDetailsDraft
  priceMode: CustomLineItemPriceMode
}

type CustomLineItemDraftOutput {
  key: String
  money: BaseMoney!
  slug: String!
  externalTaxRate: ExternalTaxRateDraftOutput
  quantity: Long
  custom: CustomFieldsCommand
  shippingDetails: ItemShippingDetailsDraftOutput
  priceMode: CustomLineItemPriceMode!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  taxCategoryResId: ResourceIdentifier
  nameAllLocales: [LocalizedString!]!
}

input CustomLineItemImportDraft {
  name: [LocalizedStringItemInputType!]!
  key: String
  quantity: Long!
  money: BaseMoneyInput!
  slug: String!
  state: [ItemStateDraftType!]
  taxRate: TaxRateInput
  taxCategory: ResourceIdentifierInput
  custom: CustomFieldsDraft
  shippingDetails: ItemShippingDetailsDraft
  priceMode: CustomLineItemPriceMode
}

enum CustomLineItemPriceMode {
  "Cart discounts are deactivated for the custom line items with this price mode."
  External

  "This is the default mode."
  Standard
}

type CustomLineItemReturnItem implements ReturnItem {
  type: String!
  customLineItemId: String!
  id: String!
  key: String
  quantity: Long!
  comment: String
  shipmentState: ReturnShipmentState!
  paymentState: ReturnPaymentState!
  custom: CustomFieldsType
  lastModifiedAt: DateTime!
  createdAt: DateTime!
}

type CustomLineItemStateTransition implements MessagePayload & OrderMessagePayload {
  customLineItemId: String!
  customLineItemKey: String
  transitionDate: DateTime!
  quantity: Long!
  fromState: State
  toState: State
  fromStateRef: Reference!
  toStateRef: Reference!
  type: String!
}

type CustomLineItemsTarget implements CartDiscountTarget {
  predicate: String!
  type: String!
}

input CustomLineItemsTargetInput {
  predicate: String!
}

type CustomObject implements Versioned & ReferenceExpandable {
  container: String!
  key: String!
  value: Json!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

"""
An input object used to create a new, or update an existing Custom Object.

The value should be passed in a form of escaped JSON.

Example for `value` field:

```
"{ \"stringField\": \"myVal\", \"numberField\": 123, \"boolField\": false, \"nestedObject\": { \"nestedObjectKey\": \"anotherValue\" }, \"dateField\": \"2018-10-12T14:00:00.000Z\" }"
```
"""
input CustomObjectDraft {
  key: String!
  container: String!

  """
  The value should be passed in a form of escaped JSON.

  Example for `value` field:

  ```
  "{ \"stringField\": \"myVal\", \"numberField\": 123, \"boolField\": false, \"nestedObject\": { \"nestedObjectKey\": \"anotherValue\" }, \"dateField\": \"2018-10-12T14:00:00.000Z\" }"
  ```
  """
  value: String!
  version: Long
}

type CustomObjectLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type CustomObjectLimitsProjection {
  total: CustomObjectLimitWithCurrent!
}

type CustomObjectQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [CustomObject!]!
}

input CustomShippingDraft {
  key: String!
  shippingMethodName: String!
  shippingAddress: AddressInput!
  shippingRate: ShippingRateDraft!
  shippingRateInput: ShippingRateInputDraft
  taxCategory: ReferenceInput
  externalTaxRate: ExternalTaxRateDraft
  deliveries: [DeliveryDraft!]
  custom: CustomFieldsDraft
}

type CustomSuggestTokenizer implements SuggestTokenizer {
  inputs: [String!]!
  type: String!
}

input CustomSuggestTokenizerInput {
  inputs: [String!]!
}

type CustomSuggestTokenizerProductSearch implements SuggestTokenizerProductSearch {
  inputs: [String!]!
  type: String!
}

"A customer is a person purchasing products. Carts, Orders and Reviews can be associated to a customer."
type Customer implements Versioned & ReferenceExpandable {
  customerNumber: String
  email: String!
  addresses: [Address!]!
  defaultShippingAddressId: String
  defaultBillingAddressId: String
  shippingAddressIds: [String!]!
  billingAddressIds: [String!]!
  isEmailVerified: Boolean!
  customerGroupRef: Reference
  externalId: String
  key: String
  authenticationMode: AuthenticationMode
  firstName: String
  lastName: String
  middleName: String
  title: String
  locale: Locale
  salutation: String
  dateOfBirth: Date
  companyName: String
  vatId: String
  password: String
  customerGroup: CustomerGroup
  defaultShippingAddress: Address
  defaultBillingAddress: Address
  shippingAddresses: [Address!]!
  billingAddresses: [Address!]!
  storesRef: [KeyReference!]!
  stores: [Store!]!
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

"A field to access a customer's active cart."
interface CustomerActiveCartInterface {
  customerActiveCart(customerId: String!): Cart
}

type CustomerAddressAdded implements MessagePayload {
  address: Address!
  type: String!
}

type CustomerAddressChanged implements MessagePayload {
  address: Address!
  type: String!
}

type CustomerAddressCustomFieldAdded implements MessagePayload {
  name: String!
  value: Json!
  addressId: String
  type: String!
}

type CustomerAddressCustomFieldChanged implements MessagePayload {
  name: String!
  value: Json!
  previousValue: Json
  addressId: String
  type: String!
}

type CustomerAddressCustomFieldRemoved implements MessagePayload {
  name: String!
  addressId: String
  type: String!
}

type CustomerAddressCustomTypeRemoved implements MessagePayload {
  previousTypeId: String
  addressId: String
  type: String!
}

type CustomerAddressCustomTypeSet implements MessagePayload {
  customFields: CustomFieldsType!
  previousTypeId: String
  addressId: String
  type: String!
}

type CustomerAddressRemoved implements MessagePayload {
  address: Address!
  type: String!
}

type CustomerCompanyNameSet implements MessagePayload {
  companyName: String
  type: String!
}

type CustomerCreated implements MessagePayload {
  customer: Customer!
  type: String!
}

type CustomerCustomFieldAdded implements MessagePayload {
  name: String!
  value: Json!
  type: String!
}

type CustomerCustomFieldChanged implements MessagePayload {
  name: String!
  value: Json!
  previousValue: Json
  type: String!
}

type CustomerCustomFieldRemoved implements MessagePayload {
  name: String!
  type: String!
}

type CustomerCustomTypeRemoved implements MessagePayload {
  previousTypeId: String
  type: String!
}

type CustomerCustomTypeSet implements MessagePayload {
  customFields: CustomFieldsType!
  previousTypeId: String
  type: String!
}

type CustomerDateOfBirthSet implements MessagePayload {
  dateOfBirth: Date
  type: String!
}

type CustomerDeleted implements MessagePayload {
  type: String!
}

type CustomerEmailChanged implements MessagePayload {
  email: String!
  type: String!
}

type CustomerEmailToken implements Versioned {
  customerId: String!
  expiresAt: DateTime!
  value: String!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type CustomerEmailTokenCreated implements MessagePayload {
  customerId: String!
  expiresAt: DateTime!
  type: String!
}

type CustomerEmailVerified implements MessagePayload {
  type: String!
}

type CustomerFirstNameSet implements MessagePayload {
  firstName: String
  type: String!
}

"A customer can be a member in a customer group (e.g. reseller, gold member). A customer group can be used in price calculations with special prices being assigned to certain customer groups."
type CustomerGroup implements Versioned & ReferenceExpandable {
  id: String!
  version: Long!
  name: String!
  key: String
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  custom: CustomFieldsType
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type CustomerGroupCustomFieldAdded implements MessagePayload {
  name: String!
  value: Json!
  type: String!
}

type CustomerGroupCustomFieldChanged implements MessagePayload {
  name: String!
  value: Json!
  oldValue: Json
  type: String!
}

type CustomerGroupCustomFieldRemoved implements MessagePayload {
  name: String!
  type: String!
}

type CustomerGroupCustomTypeRemoved implements MessagePayload {
  oldTypeId: String
  type: String!
}

type CustomerGroupCustomTypeSet implements MessagePayload {
  customFields: CustomFieldsType!
  oldTypeId: String
  type: String!
}

input CustomerGroupDraft {
  groupName: String!
  key: String
  custom: CustomFieldsDraft
}

type CustomerGroupLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type CustomerGroupLimitsProjection {
  total: CustomerGroupLimitWithCurrent!
}

type CustomerGroupQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [CustomerGroup!]!
}

type CustomerGroupReferenceIdentifier {
  typeId: String!
  id: String
  key: String
}

type CustomerGroupSet implements MessagePayload {
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  type: String!
}

input CustomerGroupUpdateAction {
  changeName: ChangeCustomerGroupName
  setKey: SetCustomerGroupKey
  setCustomType: SetCustomerGroupCustomType
  setCustomField: SetCustomerGroupCustomField
}

type CustomerLastNameSet implements MessagePayload {
  lastName: String
  type: String!
}

type CustomerLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type CustomerLimitsProjection {
  total: CustomerLimitWithCurrent!
}

type CustomerPasswordToken implements Versioned {
  customerId: String!
  expiresAt: DateTime!
  value: String!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type CustomerPasswordTokenCreated implements MessagePayload {
  customerId: String!
  expiresAt: DateTime!
  type: String!
}

type CustomerPasswordUpdated implements MessagePayload {
  reset: Boolean!
  type: String!
}

"Fields to access customer accounts. Includes direct access to a single customer and searching for customers."
interface CustomerQueryInterface {
  customer(
    "Queries a customer with specified email token"
    emailToken: String,

    "Queries a customer with specified password token"
    passwordToken: String,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Customer
  customers(where: String, sort: [String!], limit: Int, offset: Int): CustomerQueryResult!
}

type CustomerQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Customer!]!
}

input CustomerSignInDraft {
  email: String!
  password: String!

  "This field will be deprecated in favour of anonymousCart.id."
  anonymousCartId: String
  anonymousCart: ResourceIdentifierInput
  anonymousCartSignInMode: AnonymousCartSignInMode = MergeWithExistingCustomerCart
  anonymousId: String
  updateProductData: Boolean = false
}

type CustomerSignInResult {
  customer: Customer!
  cart: Cart
}

input CustomerSignMeInDraft {
  email: String!
  password: String!
  activeCartSignInMode: AnonymousCartSignInMode = MergeWithExistingCustomerCart
  updateProductData: Boolean = false
}

input CustomerSignMeUpDraft {
  email: String!
  password: String
  firstName: String
  lastName: String
  middleName: String
  title: String
  dateOfBirth: Date
  companyName: String
  vatId: String
  addresses: [AddressInput!] = []

  "The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address."
  defaultBillingAddress: Int

  "The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address."
  defaultShippingAddress: Int

  "The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses."
  shippingAddresses: [Int!] = []

  "The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses."
  billingAddresses: [Int!] = []
  custom: CustomFieldsDraft
  locale: Locale
  salutation: String
  key: String
  stores: [ResourceIdentifierInput!]
}

input CustomerSignUpDraft {
  email: String!
  password: String
  firstName: String
  lastName: String
  middleName: String
  title: String
  dateOfBirth: Date
  companyName: String
  vatId: String
  addresses: [AddressInput!] = []

  "The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address."
  defaultBillingAddress: Int

  "The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address."
  defaultShippingAddress: Int

  "The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses."
  shippingAddresses: [Int!] = []

  "The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses."
  billingAddresses: [Int!] = []
  custom: CustomFieldsDraft
  locale: Locale
  salutation: String
  key: String
  stores: [ResourceIdentifierInput!]
  customerNumber: String

  "This field will be deprecated in favour of anonymousCart.id."
  anonymousCartId: String
  anonymousCart: ResourceIdentifierInput
  externalId: String
  customerGroup: ResourceIdentifierInput
  isEmailVerified: Boolean
  anonymousId: String
  authenticationMode: AuthenticationMode
}

type CustomerTitleSet implements MessagePayload {
  title: String
  type: String!
}

input CustomerUpdateAction {
  addAddress: AddCustomerAddress
  addBillingAddressId: AddCustomerBillingAddressId
  addShippingAddressId: AddCustomerShippingAddressId
  addStore: AddCustomerStore
  changeAddress: ChangeCustomerAddress
  changeEmail: ChangeCustomerEmail
  removeAddress: RemoveCustomerAddress
  removeBillingAddressId: RemoveCustomerBillingAddressId
  removeShippingAddressId: RemoveCustomerShippingAddressId
  removeStore: RemoveCustomerStore
  setCompanyName: SetCustomerCompanyName
  setAddressCustomField: SetCustomerAddressCustomField
  setAddressCustomType: SetCustomerAddressCustomType
  setAuthenticationMode: SetCustomerAuthenticationMode
  setCustomField: SetCustomerCustomField
  setCustomType: SetCustomerCustomType
  setCustomerGroup: SetCustomerGroup
  setKey: SetCustomerKey
  setLocale: SetCustomerLocale
  setCustomerNumber: SetCustomerNumber
  setDateOfBirth: SetCustomerDateOfBirth
  setDefaultBillingAddress: SetCustomerDefaultBillingAddress
  setDefaultShippingAddress: SetCustomerDefaultShippingAddress
  setExternalId: SetCustomerExternalId
  setFirstName: SetCustomerFirstName
  setLastName: SetCustomerLastName
  setMiddleName: SetCustomerMiddleName
  setSalutation: SetCustomerSalutation
  setStores: SetCustomerStores
  setTitle: SetCustomerTitle
  setVatId: SetCustomerVatId
}

"DateTime is a scalar value that represents an ISO8601 formatted date."
scalar Date

type DateAttribute implements Attribute {
  value: Date!
  name: String!
}

type DateAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type DateField implements CustomField {
  value: Date!
  name: String!
}

"DateTime is a scalar value that represents an ISO8601 formatted date and time."
scalar DateTime

type DateTimeAttribute implements Attribute {
  value: DateTime!
  name: String!
}

type DateTimeAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type DateTimeField implements CustomField {
  value: DateTime!
  name: String!
}

type DateTimeType implements FieldType {
  name: String!
}

type DateType implements FieldType {
  name: String!
}

type Delivery {
  id: String!
  key: String
  createdAt: DateTime!
  items: [DeliveryItem!]!
  parcels: [Parcel!]!
  address: Address
  custom: CustomFieldsType
}

type DeliveryAdded implements MessagePayload & OrderMessagePayload {
  delivery: Delivery!
  shippingKey: String
  type: String!
}

type DeliveryAddressSet implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  address: Address
  oldAddress: Address
  shippingKey: String
  type: String!
}

input DeliveryDraft {
  key: String
  items: [DeliveryItemDraftType!]!
  parcels: [ParcelDraft!]!
  address: AddressInput
  custom: CustomFieldsDraft
}

type DeliveryItem {
  id: String!
  quantity: Long!
}

input DeliveryItemDraftType {
  id: String!
  quantity: Long!
}

type DeliveryItemsUpdated implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  items: [DeliveryItem!]!
  oldItems: [DeliveryItem!]!
  shippingKey: String
  type: String!
}

type DeliveryRemoved implements MessagePayload & OrderMessagePayload {
  delivery: Delivery!
  shippingKey: String
  type: String!
}

interface Destination {
  type: String!
}

input DestinationInput {
  SQS: SQSDestinationInput
  SNS: SNSDestinationInput
  AzureServiceBus: AzureServiceBusDestinationInput
  EventGrid: EventGridDestinationInput
  GoogleCloudPubSub: GoogleCloudPubSubDestinationInput
  EventBridge: EventBridgeDestinationInput
  ConfluentCloud: ConfluentCloudDestinationInput
}

type Dimensions {
  width: Int!
  height: Int!
}

input DimensionsInput {
  width: Int!
  height: Int!
}

type DimensionsProductSearch {
  width: Int!
  height: Int!
}

type DirectDiscount {
  id: String!
  value: CartDiscountValue!
  target: CartDiscountTarget
}

input DirectDiscountDraft {
  value: CartDiscountValueInput!
  target: CartDiscountTargetInput
}

type DirectDiscountDraftOutput {
  value: CartDiscountValue!
  target: CartDiscountTarget
}

"With discount codes it is possible to give specific cart discounts to an eligible amount of users. They are defined by a string value which can be added to a cart so that specific cart discounts can be applied to the cart."
type DiscountCode implements Versioned & ReferenceExpandable {
  code: String!
  key: String
  isActive: Boolean!
  maxApplications: Long
  maxApplicationsPerCustomer: Long
  cartPredicate: String
  applicationVersion: Long
  validFrom: DateTime
  validUntil: DateTime
  groups: [String!]!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  cartDiscounts: [CartDiscount!]!
  referenceRefs: [Reference!]!
  nameAllLocales: [LocalizedString!]
  descriptionAllLocales: [LocalizedString!]
  custom: CustomFieldsType

  "How many times this discount code was applied (only applications that were part of a successful checkout are considered)"
  applicationCount: Long!
  cartDiscountRefs: [Reference!]!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type DiscountCodeCreated implements MessagePayload {
  discountCode: DiscountCode!
  type: String!
}

type DiscountCodeDeleted implements MessagePayload {
  type: String!
}

input DiscountCodeDraft {
  code: String!
  name: [LocalizedStringItemInputType!]
  key: String
  description: [LocalizedStringItemInputType!]
  cartDiscounts: [ResourceIdentifierInput!]!
  isActive: Boolean = true
  maxApplications: Long
  maxApplicationsPerCustomer: Long
  cartPredicate: String
  custom: CustomFieldsDraft
  validFrom: DateTime
  validUntil: DateTime
  groups: [String!] = []
}

type DiscountCodeInfo {
  discountCodeRef: Reference!
  state: DiscountCodeState
  discountCode: DiscountCode
}

type DiscountCodeKeySet implements MessagePayload {
  key: String
  oldKey: String
  type: String!
}

type DiscountCodeQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [DiscountCode!]!
}

enum DiscountCodeState {
  "The discount code is active and none of the discounts were applied because the discount application was stopped by one discount that has the StackingMode of StopAfterThisDiscount defined"
  ApplicationStoppedByPreviousDiscount

  "The discount code is active and it contains at least one active and valid CartDiscount. But its cart predicate does not match the cart or none of the contained active discount\u2019s cart predicates match the cart"
  DoesNotMatchCart

  "The discount code is active and it contains at least one active and valid CartDiscount. The discount code cartPredicate matches the cart and at least one of the contained active discount\u2019s cart predicates matches the cart."
  MatchesCart

  "maxApplications or maxApplicationsPerCustomer for discountCode has been reached."
  MaxApplicationReached

  "The discount code is not active or it does not contain any active cart discounts."
  NotActive

  "The discount code is not valid or it does not contain any valid cart discounts. Validity is determined based on the validFrom and validUntil dates"
  NotValid
}

input DiscountCodeUpdateAction {
  changeCartDiscounts: ChangeDiscountCodeCartDiscounts
  changeGroups: ChangeDiscountCodeGroups
  changeIsActive: ChangeDiscountCodeIsActive
  setCartPredicate: SetDiscountCodeCartPredicate
  setCustomField: SetDiscountCodeCustomField
  setCustomType: SetDiscountCodeCustomType
  setDescription: SetDiscountCodeDescription
  setKey: SetDiscountCodeKey
  setMaxApplications: SetDiscountCodeMaxApplications
  setMaxApplicationsPerCustomer: SetDiscountCodeMaxApplicationsPerCustomer
  setName: SetDiscountCodeName
  setValidFrom: SetDiscountCodeValidFrom
  setValidFromAndUntil: SetDiscountCodeValidFromAndUntil
  setValidUntil: SetDiscountCodeValidUntil
}

type DiscountOnTotalPrice {
  discountedAmount: BaseMoney!
  includedDiscounts: [DiscountedTotalPricePortion!]!
  discountedNetAmount: BaseMoney
  discountedGrossAmount: BaseMoney
}

type DiscountedLineItemPortion {
  discount: CartDiscount
  discountRef: Reference!
  discountedAmount: BaseMoney!
}

input DiscountedLineItemPortionDraft {
  discount: ReferenceInput!
  discountedAmount: BaseMoneyInput!
}

type DiscountedLineItemPrice {
  value: BaseMoney!
  includedDiscounts: [DiscountedLineItemPortion!]!
}

input DiscountedLineItemPriceDraft {
  value: BaseMoneyInput!
  includedDiscounts: [DiscountedLineItemPortionDraft!] = []
}

type DiscountedLineItemPriceForQuantity {
  quantity: Long!
  discountedPrice: DiscountedLineItemPrice!
}

type DiscountedProductPriceValue {
  value: BaseMoney!
  discountRef: Reference!
  discount: ProductDiscount
}

input DiscountedProductPriceValueInput {
  value: BaseMoneyInput!
  discount: ResourceIdentifierInput!
}

type DiscountedProductSearchPriceValue {
  value: BaseMoney!
  discountRef: Reference!
  discount: ProductDiscount
}

type DiscountedTotalPricePortion {
  discount: CartDiscount
  discountRef: Reference!
  discountedAmount: BaseMoney!
}

type EnumAttribute implements Attribute {
  key: String!
  label: String!
  name: String!
}

type EnumAttributeDefinitionType implements AttributeDefinitionType {
  values(
    """
    The keys of the enum values to include.

    If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
    """
    includeKeys: [String!],

    """
    The keys of the enum values to exclude.

    If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
    """
    excludeKeys: [String!], limit: Int, offset: Int, sort: [String!]): PlainEnumValueResult!
  name: String!
}

type EnumField implements CustomField {
  key: String!
  name: String!
}

type EnumType implements FieldType {
  values: [EnumValue!]!
  name: String!
}

input EnumTypeDraft {
  values: [PlainEnumValueDraft!]!
}

type EnumValue {
  key: String!
  label: String!
}

input EnumValueInput {
  key: String!
  label: String!
}

type EventBridgeDestination implements Destination {
  source: String!
  region: String!
  accountId: String!
  type: String!
}

input EventBridgeDestinationInput {
  region: String!
  accountId: String!
}

type EventGridDestination implements Destination {
  uri: String!
  accessKey: String!
  type: String!
}

input EventGridDestinationInput {
  uri: String!
  accessKey: String!
}

input ExcludeProductSelectionProduct {
  product: ResourceIdentifierInput!
  variantExclusion: ProductVariantExclusionDraft
}

input ExistsFilterInput {
  path: String!
}

type Extension implements Versioned & ReferenceExpandable {
  key: String
  destination: ExtensionDestination!
  triggers: [Trigger!]!
  timeoutInMs: Int
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

interface ExtensionDestination {
  type: String!
}

input ExtensionDestinationInput {
  HTTP: HttpDestinationInput
  AWSLambda: AWSLambdaDestinationInput
  GoogleCloudFunction: GoogleCloudFunctionDestinationInput
}

input ExtensionDraft {
  key: String
  destination: ExtensionDestinationInput!
  triggers: [TriggerInput!]!
  timeoutInMs: Int
}

type ExtensionLimitsProjection {
  timeoutInMs: Limit!
}

type ExtensionQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Extension!]!
}

input ExtensionUpdateAction {
  changeDestination: ChangeExtensionDestination
  changeTriggers: ChangeExtensionTriggers
  setKey: SetExtensionKey
  setTimeoutInMs: SetExtensionTimeoutInMs
}

type ExternalDiscountValue implements ProductDiscountValue {
  type: String!
}

input ExternalDiscountValueInput {
  dummy: String
}

type ExternalLineItemTotalPrice {
  price: BaseMoney!
  totalPrice: Money!
}

input ExternalLineItemTotalPriceDraft {
  price: BaseMoneyInput!
  totalPrice: MoneyInput!
}

type ExternalOAuth {
  url: String!
  authorizationHeader: String!
}

input ExternalOAuthDraft {
  url: String!
  authorizationHeader: String!
}

input ExternalTaxAmountDraft {
  totalGross: MoneyInput!
  taxRate: ExternalTaxRateDraft!
}

type ExternalTaxAmountDraftOutput {
  totalGross: Money!
  taxRate: ExternalTaxRateDraftOutput!
}

input ExternalTaxRateDraft {
  name: String!
  amount: Float!
  country: Country!
  state: String
  subRates: [SubRateDraft!] = []
  includedInPrice: Boolean = false
}

type ExternalTaxRateDraftOutput {
  name: String!
  amount: Float
  country: Country!
  state: String
  subRates: [SubRate!]!
  includedInPrice: Boolean!
}

interface FacetResult {
  type: String!
}

type FacetResultValue {
  facet: String!
  value: FacetResult!
}

"Field definitions describe custom fields and allow you to define some meta-information associated with the field."
type FieldDefinition {
  name: String!
  required: Boolean!
  inputHint: TextInputHint!
  label(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  labelAllLocales: [LocalizedString!]!
  type: FieldType!
}

input FieldDefinitionInput {
  type: FieldTypeInput!
  name: String!
  label: [LocalizedStringItemInputType!]!
  required: Boolean!
  inputHint: TextInputHint!
}

interface FieldType {
  name: String!
}

input FieldTypeEnumTypeDraft {
  values: [EnumValueInput!]!
}

input FieldTypeInput {
  Set: FieldTypeSetTypeDraft
  String: SimpleFieldTypeDraft
  LocalizedString: SimpleFieldTypeDraft
  Number: SimpleFieldTypeDraft
  Money: SimpleFieldTypeDraft
  Date: SimpleFieldTypeDraft
  Time: SimpleFieldTypeDraft
  DateTime: SimpleFieldTypeDraft
  Boolean: SimpleFieldTypeDraft
  Enum: FieldTypeEnumTypeDraft
  LocalizedEnum: FieldTypeLocalizedEnumTypeDraft
  Reference: FieldTypeReferenceTypeDraft
}

input FieldTypeLocalizedEnumTypeDraft {
  values: [LocalizedEnumValueInput!]!
}

input FieldTypeReferenceTypeDraft {
  referenceTypeId: String!
}

input FieldTypeSetElementTypeDraft {
  String: SimpleFieldTypeDraft
  LocalizedString: SimpleFieldTypeDraft
  Number: SimpleFieldTypeDraft
  Money: SimpleFieldTypeDraft
  Date: SimpleFieldTypeDraft
  Time: SimpleFieldTypeDraft
  DateTime: SimpleFieldTypeDraft
  Boolean: SimpleFieldTypeDraft
  Enum: FieldTypeEnumTypeDraft
  LocalizedEnum: FieldTypeLocalizedEnumTypeDraft
  Reference: FieldTypeReferenceTypeDraft
}

input FieldTypeSetTypeDraft {
  elementType: FieldTypeSetElementTypeDraft!
}

type FixedPriceDiscountValue implements CartDiscountValue {
  type: String!
  money: [BaseMoney!]!
}

input FixedPriceDiscountValueInput {
  money: [CartDiscountValueBaseMoneyInput!]!
}

input FreezeCart {
  dummy: String
}

interface Geometry {
  type: String!
}

input GeometryInput {
  type: String!
  coordinates: [Float!]
}

type GiftLineItemValue implements CartDiscountValue {
  type: String!
  variantId: Int!
  productRef: ProductReferenceIdentifier!
  distributionChannelRef: ChannelReferenceIdentifier
  supplyChannelRef: ChannelReferenceIdentifier
}

input GiftLineItemValueInput {
  product: ResourceIdentifierInput!
  variantId: Int!
  distributionChannel: ResourceIdentifierInput
  supplyChannel: ResourceIdentifierInput
}

type GoogleCloudFunctionDestination implements ExtensionDestination {
  url: String!
  type: String!
}

input GoogleCloudFunctionDestinationInput {
  url: String!
}

type GoogleCloudPubSubDestination implements Destination {
  projectId: String!
  topic: String!
  type: String!
}

input GoogleCloudPubSubDestinationInput {
  projectId: String!
  topic: String!
}

interface HasProductTailoringData {
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]
  metaTitle(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaDescription(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]
  metaKeywords(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  variants: [ProductVariantTailoring!]!
}

type HighPrecisionMoney implements BaseMoney {
  type: String!
  currencyCode: Currency!
  preciseAmount: Long!
  centAmount: Long!
  fractionDigits: Int!
}

input HighPrecisionMoneyInput {
  currencyCode: Currency!
  preciseAmount: Long!
  fractionDigits: Int!
  centAmount: Long
}

type HttpDestination implements ExtensionDestination {
  type: String!
  url: String!
  authentication: HttpDestinationAuthentication
}

interface HttpDestinationAuthentication {
  type: String!
}

input HttpDestinationAuthenticationInput {
  AuthorizationHeader: AuthorizationHeaderInput
  AzureFunctions: AzureFunctionsAuthenticationInput
}

input HttpDestinationInput {
  url: String!
  authentication: HttpDestinationAuthenticationInput
}

type Image {
  url: String!
  dimensions: Dimensions!
  label: String
}

input ImageInput {
  url: String!
  label: String
  dimensions: DimensionsInput!
}

type ImageProductSearch {
  url: String!
  dimensions: DimensionsProductSearch!
  label: String
}

input ImportOrderCustomLineItemState {
  customLineItemId: String
  customLineItemKey: String
  state: [ItemStateDraftType!]!
}

input ImportOrderDraft {
  orderNumber: String
  customerId: String
  customerEmail: String
  store: ReferenceInput
  lineItems: [LineItemImportDraft!]! = []
  customLineItems: [CustomLineItemImportDraft!]! = []
  totalPrice: MoneyInput!
  taxedPrice: TaxedPriceDraft
  shippingAddress: AddressInput
  billingAddress: AddressInput
  customerGroup: ReferenceInput
  country: Country
  orderState: OrderState
  shipmentState: ShipmentState
  paymentState: PaymentState
  shippingInfo: ShippingInfoImportDraft
  completedAt: DateTime
  custom: CustomFieldsDraft
  inventoryMode: InventoryMode = None
  shippingDetails: ItemShippingDetailsDraft
  taxCalculationMode: TaxCalculationMode = LineItemLevel
  origin: CartOrigin = Customer
  itemShippingAddresses: [AddressInput!] = []
  state: ReferenceInput
  paymentInfo: ReferenceInput
  purchaseOrderNumber: String
}

input ImportOrderLineItemState {
  lineItemId: String
  lineItemKey: String
  state: [ItemStateDraftType!]!
}

input ImportStagedOrderCustomLineItemState {
  customLineItemId: String
  customLineItemKey: String
  state: [ItemStateDraftType!]!
}

type ImportStagedOrderCustomLineItemStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String
  customLineItemKey: String
  state: Set!
}

input ImportStagedOrderLineItemState {
  lineItemId: String
  lineItemKey: String
  state: [ItemStateDraftType!]!
}

type ImportStagedOrderLineItemStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  lineItemKey: String
  state: Set!
}

type InStore implements CartDiscountQueryInterface & CartQueryInterface & CustomerActiveCartInterface & OrderQueryInterface & CustomerQueryInterface & ShippingMethodsByCartInterface & MeFieldInterface {
  """
  This field can only be used with an access token created with the password flow or with an anonymous session.

  It gives access to the data that is specific to the customer or the anonymous session linked to the access token.
  """
  me: InStoreMe!
  shippingMethodsByCart(id: String!): [ShippingMethod!]!
  cartDiscount(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CartDiscount
  cartDiscounts(where: String, sort: [String!], limit: Int, offset: Int): CartDiscountQueryResult!
  product(projectExpandedProducts: Boolean = false, localeProjection: [Locale!],

    "Queries for a product with specified SKU"
    sku: String,

    "Queries for a [Product](https://docs.commercetools.com/api/projects/products#product) with specified [ProductVariant](https://docs.commercetools.com/api/projects/products#productvariant) `key`"
    variantKey: String,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Product
  customer(
    "Queries a customer with specified email token"
    emailToken: String,

    "Queries a customer with specified password token"
    passwordToken: String,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Customer
  customers(where: String, sort: [String!], limit: Int, offset: Int): CustomerQueryResult!
  cart(id: String!): Cart
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  customerActiveCart(customerId: String!): Cart
  order(
    "Queries with specified ID"
    id: String, orderNumber: String): Order
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
  shoppingList(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShoppingList
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
  productSelectionAssignments(where: String, sort: [String!], limit: Int, offset: Int): ProductAssignmentQueryResult!
  productTailoring(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String,

    "Queries with specified Product ID"
    productId: String,

    "Queries with specified Product key"
    productKey: String): ProductTailoring
  productTailoringList(where: String, sort: [String!], limit: Int, offset: Int): ProductTailoringQueryResult!
  quoteRequest(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): QuoteRequest
  quoteRequests(where: String, sort: [String!], limit: Int, offset: Int): QuoteRequestQueryResult!
  stagedQuote(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): StagedQuote
  stagedQuotes(where: String, sort: [String!], limit: Int, offset: Int): StagedQuoteQueryResult!
  quote(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Quote
  quotes(where: String, sort: [String!], limit: Int, offset: Int): QuoteQueryResult!
}

type InStoreMe implements MeQueryInterface & CartQueryInterface & ActiveCartInterface & OrderQueryInterface & ShoppingListQueryInterface {
  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  customer: Customer

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  cart(id: String!): Cart

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  activeCart: Cart

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  order(
    "Queries with specified ID"
    id: String, orderNumber: String): Order

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  shoppingList(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShoppingList

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
}

type InheritedAssociate {
  associateRoleAssignments: [InheritedAssociateRoleAssignment!]!
  customerRef: Reference
  customer: Customer
}

type InheritedAssociateRoleAssignment {
  associateRoleRef: KeyReference!
  associateRole: AssociateRole!
  sourceRef: KeyReference!
  source: BusinessUnit!
}

type InheritedStore {
  store: Store
  storeRef: KeyReference!
}

type Initiator {
  isPlatformClient: Boolean
  externalUserId: String
  anonymousId: String
  attributedTo: Attribution
  clientId: String
  customerRef: Reference
  userRef: Reference
  associateRef: Reference
}

type InterfaceInteractionsRaw {
  typeRef: Reference!
  type: TypeDefinition
  fields(
    """
    The names of the custom fields to include.

    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    includeNames: [String!],

    """
    The names of the custom fields to exclude.

    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    excludeNames: [String!]): [RawCustomField!]!
}

type InterfaceInteractionsRawResult {
  limit: Int
  offset: Int
  total: Int!
  results: [InterfaceInteractionsRaw!]!
}

"Inventory allows you to track stock quantity per SKU and optionally per supply channel"
type InventoryEntry implements Versioned & ReferenceExpandable {
  sku: String!
  quantityOnStock: Long!
  availableQuantity: Long!
  key: String
  restockableInDays: Int
  expectedDelivery: DateTime
  supplyChannel: Channel
  supplyChannelRef: Reference
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type InventoryEntryCreated implements MessagePayload {
  inventoryEntry: InventoryEntry!
  type: String!
}

type InventoryEntryDeleted implements MessagePayload {
  sku: String!
  supplyChannel: Channel
  supplyChannelRef: Reference
  type: String!
}

input InventoryEntryDraft {
  sku: String!
  key: String
  quantityOnStock: Long!
  restockableInDays: Int
  expectedDelivery: DateTime
  supplyChannel: ResourceIdentifierInput
  custom: CustomFieldsDraft
}

type InventoryEntryQuantitySet implements MessagePayload {
  oldQuantityOnStock: Long!
  newQuantityOnStock: Long!
  oldAvailableQuantity: Long!
  newAvailableQuantity: Long!
  supplyChannel: Channel
  supplyChannelRef: Reference
  type: String!
}

type InventoryEntryQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [InventoryEntry!]!
}

input InventoryEntryUpdateAction {
  addQuantity: AddInventoryEntryQuantity
  changeQuantity: ChangeInventoryEntryQuantity
  removeQuantity: RemoveInventoryEntryQuantity
  setRestockableInDays: SetInventoryEntryRestockableInDays
  setExpectedDelivery: SetInventoryEntryExpectedDelivery
  setSupplyChannel: SetInventoryEntrySupplyChannel
  setCustomType: SetInventoryEntryCustomType
  setCustomField: SetInventoryEntryCustomField
}

enum InventoryMode {
  """
  Adding items to cart and ordering is independent of inventory. No inventory checks or modifications.
  This is the default mode for a new cart.
  """
  None

  """
  Creating an order will fail with an OutOfStock error if an unavailable line item exists. Line items in the cart
  are only reserved for the duration of the ordering transaction.
  """
  ReserveOnOrder

  """
  Orders are tracked on inventory. That means, ordering a LineItem will decrement the available quantity on the
  respective InventoryEntry. Creating an order will succeed even if the line item’s available quantity is zero or
  negative. But creating an order will fail with an OutOfStock error if no matching inventory entry exists for a
  line item.
  """
  TrackOnly
}

type ItemShippingDetails {
  targets: [ItemShippingTarget!]!
  valid: Boolean!
}

input ItemShippingDetailsDraft {
  targets: [ShippingTargetDraft!]!
}

type ItemShippingDetailsDraftOutput {
  targets: [ItemShippingTarget!]!
}

input ItemShippingDetailsDraftType {
  targets: [ShippingTargetDraftType!]!
}

type ItemShippingTarget {
  addressKey: String!
  quantity: Long!
  shippingMethodKey: String
}

type ItemState {
  quantity: Long!
  stateRef: Reference!
  state: State
}

input ItemStateDraftType {
  quantity: Long!
  state: ReferenceInput!
}

"Raw JSON value"
scalar Json

type KeyReference {
  typeId: String!
  key: String!
}

"A key that references a resource."
scalar KeyReferenceInput

type Limit {
  limit: Long
}

interface LimitWithCurrent {
  limit: Long
  current: Long
}

"""
A line item is a snapshot of a product variant at the time it was added to the cart.

Since a product variant may change at any time, the ProductVariant data is copied into the field variant.
The relation to the Product is kept but the line item will not automatically update if the product variant changes.
On the cart, the line item can be updated manually. The productSlug refers to the current version of the product.
It can be used to link to the product. If the product has been deleted, the line item remains but refers to a
non-existent product and the productSlug is left empty.

Please also note that creating an order is impossible if the product or product variant a line item relates to has been deleted.
"""
type LineItem {
  id: String!
  key: String
  productId: String!
  productKey: String
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  productSlug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  productSlugAllLocales: [LocalizedString!]
  productType: ProductTypeDefinition
  productTypeRef: Reference
  variant: ProductVariant
  price: ProductPrice!
  taxedPrice: TaxedItemPrice
  totalPrice: Money
  quantity: Long!
  addedAt: DateTime
  lastModifiedAt: DateTime
  state: [ItemState!]!
  taxRate: TaxRate
  supplyChannel: Channel
  supplyChannelRef: Reference
  distributionChannel: Channel
  distributionChannelRef: Reference
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  lineItemMode: LineItemMode!
  priceMode: LineItemPriceMode!
  custom: CustomFieldsType
  inventoryMode: InventoryMode
  shippingDetails: ItemShippingDetails
  perMethodTaxRate: [MethodTaxRate!]!
  taxedPricePortions: [MethodTaxedPrice!]!
}

input LineItemDraft {
  key: String
  productId: String
  sku: String
  quantity: Long
  variantId: Int
  supplyChannel: ResourceIdentifierInput
  distributionChannel: ResourceIdentifierInput
  custom: CustomFieldsDraft
  shippingDetails: ItemShippingDetailsDraft
  addedAt: DateTime
  externalTaxRate: ExternalTaxRateDraft
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  inventoryMode: InventoryMode
}

type LineItemDraftOutput {
  productId: String
  sku: String
  key: String
  quantity: Long
  variantId: Int
  custom: CustomFieldsCommand
  externalTaxRate: ExternalTaxRateDraftOutput
  perMethodExternalTaxRate: [MethodExternalTaxRateDraftOutput!]!
  externalPrice: BaseMoney
  externalTotalPrice: ExternalLineItemTotalPrice
  inventoryMode: InventoryMode
  shippingDetails: ItemShippingDetailsDraftOutput
  addedAt: DateTime
  distributionChannelResId: ResourceIdentifier
  supplyChannelResId: ResourceIdentifier
}

input LineItemImportDraft {
  productId: String
  name: [LocalizedStringItemInputType!]!
  key: String
  price: ProductPriceDataInput!
  quantity: Long!
  supplyChannel: ResourceIdentifierInput
  distributionChannel: ResourceIdentifierInput
  taxRate: TaxRateInput
  variant: ProductVariantImportDraft!
  state: [ItemStateDraftType!]
  custom: CustomFieldsDraft
  shippingDetails: ItemShippingDetailsDraft
}

enum LineItemMode {
  """
  The line item was added automatically, because a discount has added a free gift to the cart.
  The quantity can not be increased, and it won’t be merged when the same product variant is added.
  If the gift is removed, an entry is added to the "refusedGifts" array and the discount won’t be applied again
  to the cart. The price can not be changed externally.
  All other updates, such as the ones related to custom fields, can be used.
  """
  GiftLineItem

  """
  The line item was added during cart creation or with the update action addLineItem. Its quantity can be
  changed without restrictions.
  """
  Standard
}

enum LineItemPriceMode {
  "The line item price was set externally. Cart discounts can apply to line items with this price mode. All update actions that change the quantity of a line item with this price mode require the externalPrice field to be given."
  ExternalPrice

  "The line item price with the total was set externally."
  ExternalTotal

  "The price is selected form the product variant. This is the default mode."
  Platform
}

type LineItemReturnItem implements ReturnItem {
  type: String!
  lineItemId: String!
  id: String!
  key: String
  quantity: Long!
  comment: String
  shipmentState: ReturnShipmentState!
  paymentState: ReturnPaymentState!
  custom: CustomFieldsType
  lastModifiedAt: DateTime!
  createdAt: DateTime!
}

type LineItemStateTransition implements MessagePayload & OrderMessagePayload {
  lineItemId: String!
  lineItemKey: String
  transitionDate: DateTime!
  quantity: Long!
  fromState: State
  toState: State
  fromStateRef: Reference!
  toStateRef: Reference!
  type: String!
}

type LineItemsTarget implements CartDiscountTarget {
  predicate: String!
  type: String!
}

input LineItemsTargetInput {
  predicate: String!
}

"Locale is a scalar value represented as a string language tag."
scalar Locale

type LocalizableEnumAttributeDefinitionType implements AttributeDefinitionType {
  values(
    """
    The keys of the enum values to include.

    If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
    """
    includeKeys: [String!],

    """
    The keys of the enum values to exclude.

    If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
    """
    excludeKeys: [String!], limit: Int, offset: Int, sort: [String!]): LocalizableEnumValueTypeResult!
  name: String!
}

input LocalizableEnumTypeDraft {
  values: [LocalizedEnumValueDraft!]!
}

type LocalizableEnumValueType {
  key: String!
  label(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  labelAllLocales: [LocalizedString!]!
}

type LocalizableEnumValueTypeResult {
  limit: Int
  offset: Int
  total: Int!
  results: [LocalizableEnumValueType!]!
}

type LocalizableTextAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type LocalizedEnumAttribute implements Attribute {
  key: String!
  label(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale!): String
  name: String!
}

type LocalizedEnumField implements CustomField {
  key: String!
  label(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale!): String
  name: String!
}

type LocalizedEnumType implements FieldType {
  values: [LocalizedEnumValue!]!
  name: String!
}

type LocalizedEnumValue {
  key: String!
  label(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  labelAllLocales: [LocalizedString!]!
}

input LocalizedEnumValueDraft {
  key: String!
  label: [LocalizedStringItemInputType!]!
}

input LocalizedEnumValueInput {
  key: String!
  label: [LocalizedStringItemInputType!]!
}

type LocalizedString {
  locale: Locale!
  value: String!
}

type LocalizedStringAttribute implements Attribute {
  value(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale!): String
  name: String!
}

type LocalizedStringField implements CustomField {
  value(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale!): String
  name: String!
}

input LocalizedStringItemInputType {
  locale: Locale!
  value: String!
}

type LocalizedStringType implements FieldType {
  name: String!
}

type Location {
  country: Country!
  state: String
}

"The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

type Me implements MeQueryInterface & CartQueryInterface & ActiveCartInterface & OrderQueryInterface & ShoppingListQueryInterface {
  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  customer: Customer

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  cart(id: String!): Cart

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  activeCart: Cart

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  order(
    "Queries with specified ID"
    id: String, orderNumber: String): Order

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  shoppingList(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShoppingList

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  payment(id: String!): MyPayment

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  payments(where: String, sort: [String!], limit: Int, offset: Int): MyPaymentQueryResult!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  quoteRequest(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): QuoteRequest

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  quoteRequests(where: String, sort: [String!], limit: Int, offset: Int): QuoteRequestQueryResult!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  quote(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Quote

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  quotes(where: String, sort: [String!], limit: Int, offset: Int): QuoteQueryResult!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  businessUnit(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): BusinessUnit

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  businessUnits(where: String, sort: [String!], limit: Int, offset: Int): BusinessUnitQueryResult!
}

"The me field gives access to the data that is specific to the customer or anonymous session linked to the access token."
interface MeFieldInterface {
  me: MeQueryInterface!
}

interface MeQueryInterface implements CartQueryInterface & ActiveCartInterface & OrderQueryInterface & ShoppingListQueryInterface {
  cart(id: String!): Cart
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  activeCart: Cart
  order(
    "Queries with specified ID"
    id: String, orderNumber: String): Order
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
  shoppingList(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShoppingList
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
}

type Message implements Versioned & ReferenceExpandable {
  id: String!
  type: String!
  sequenceNumber: Long!
  resourceRef: Reference!
  resourceVersion: Long!
  userProvidedIdentifiers: UserProvidedIdentifiers
  payload: MessagePayload!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

interface MessagePayload {
  type: String!
}

type MessageQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Message!]!
}

type MessageSubscription {
  resourceTypeId: String!
  types: [String!]!
}

input MessageSubscriptionInput {
  resourceTypeId: String!
  types: [String!]
}

type MessagesConfiguration {
  enabled: Boolean!
  deleteDaysAfterCreation: Int
}

input MessagesConfigurationDraft {
  enabled: Boolean!
  deleteDaysAfterCreation: Int!
}

input MethodExternalTaxRateDraft {
  shippingMethodKey: String!
  taxRate: ExternalTaxRateDraft
}

type MethodExternalTaxRateDraftOutput {
  shippingMethodKey: String!
  taxRate: ExternalTaxRateDraftOutput
}

type MethodTaxRate {
  shippingMethodKey: String!
  taxRate: TaxRate
}

type MethodTaxedPrice {
  shippingMethodKey: String!
  taxedPrice: TaxedItemPrice
}

input MissingFilterInput {
  path: String!
}

type Money implements BaseMoney {
  type: String!
  currencyCode: Currency!
  centAmount: Long!

  "For the `Money` it equals to the default number of fraction digits used with the currency."
  fractionDigits: Int!
}

type MoneyAttribute implements Attribute {
  centAmount: Long!
  currencyCode: Currency!
  name: String!
}

type MoneyAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

input MoneyDraft {
  currencyCode: Currency!
  centAmount: Long!
}

type MoneyField implements CustomField {
  centAmount: Long!
  currencyCode: Currency!
  name: String!
}

input MoneyInput {
  currencyCode: Currency!
  centAmount: Long!
}

type MoneyType implements FieldType {
  name: String!
}

input MoveProductImageToPosition {
  variantId: Int
  sku: String
  imageUrl: String!
  position: Int!
  staged: Boolean
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input MoveProductTailoringImageToPosition {
  variantId: Int
  sku: String
  imageUrl: String!
  position: Int!
  staged: Boolean = true
}

type MultiBuyCustomLineItemsTarget implements CartDiscountTarget {
  predicate: String!
  triggerQuantity: Long!
  discountedQuantity: Long!
  maxOccurrence: Int
  selectionMode: SelectionMode!
  type: String!
}

input MultiBuyCustomLineItemsTargetInput {
  predicate: String!
  triggerQuantity: Long!
  discountedQuantity: Long!
  maxOccurrence: Int
  selectionMode: SelectionMode
}

type MultiBuyLineItemsTarget implements CartDiscountTarget {
  predicate: String!
  triggerQuantity: Long!
  discountedQuantity: Long!
  maxOccurrence: Int
  selectionMode: SelectionMode!
  type: String!
}

input MultiBuyLineItemsTargetInput {
  predicate: String!
  triggerQuantity: Long!
  discountedQuantity: Long!
  maxOccurrence: Int
  selectionMode: SelectionMode
}

type Mutation {
  createCustomerGroup(draft: CustomerGroupDraft!): CustomerGroup
  updateCustomerGroup(version: Long!, actions: [CustomerGroupUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CustomerGroup
  deleteCustomerGroup(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CustomerGroup
  createCategory(draft: CategoryDraft!): Category
  updateCategory(version: Long!, actions: [CategoryUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Category
  deleteCategory(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Category
  createChannel(draft: ChannelDraft!): Channel
  updateChannel(id: String!, version: Long!, actions: [ChannelUpdateAction!]!): Channel
  deleteChannel(id: String!, version: Long!): Channel
  createOrUpdateCustomObject(draft: CustomObjectDraft!): CustomObject
  deleteCustomObject(version: Long,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String, container: String, personalDataErasure: Boolean = false): CustomObject
  createProductType(draft: ProductTypeDraft!): ProductTypeDefinition
  updateProductType(version: Long!, actions: [ProductTypeUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ProductTypeDefinition
  deleteProductType(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ProductTypeDefinition
  createTypeDefinition(draft: TypeDefinitionDraft!): TypeDefinition
  updateTypeDefinition(version: Long!, actions: [TypeUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): TypeDefinition
  deleteTypeDefinition(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): TypeDefinition
  createShippingMethod(draft: ShippingMethodDraft!): ShippingMethod
  updateShippingMethod(version: Long!, actions: [ShippingMethodUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShippingMethod
  deleteShippingMethod(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShippingMethod
  createZone(draft: CreateZone!): Zone
  updateZone(version: Long!, actions: [ZoneUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Zone
  deleteZone(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Zone
  createTaxCategory(draft: TaxCategoryDraft!): TaxCategory
  updateTaxCategory(version: Long!, actions: [TaxCategoryUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): TaxCategory
  deleteTaxCategory(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): TaxCategory
  createDiscountCode(draft: DiscountCodeDraft!): DiscountCode
  updateDiscountCode(version: Long!, actions: [DiscountCodeUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): DiscountCode
  deleteDiscountCode(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): DiscountCode
  createCartDiscount(draft: CartDiscountDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): CartDiscount
  updateCartDiscount(version: Long!, actions: [CartDiscountUpdateAction!]!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CartDiscount
  deleteCartDiscount(version: Long!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CartDiscount
  createProductDiscount(draft: ProductDiscountDraft!): ProductDiscount
  updateProductDiscount(version: Long!, actions: [ProductDiscountUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ProductDiscount
  deleteProductDiscount(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ProductDiscount
  createAttributeGroup(draft: AttributeGroupDraft!): AttributeGroup
  updateAttributeGroup(version: Long!, actions: [AttributeGroupUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): AttributeGroup
  deleteAttributeGroup(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): AttributeGroup
  createProduct(draft: ProductDraft!): Product
  updateProduct(version: Long!, actions: [ProductUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Product
  deleteProduct(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Product
  createState(draft: StateDraft!): State
  updateState(version: Long!, actions: [StateUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): State
  deleteState(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): State

  "Creates a customer. If an anonymous cart is given then the cart is assigned to the created customer and the version number of the Cart will increase. If the id of an anonymous session is given, all carts and orders will be assigned to the created customer."
  customerSignUp(draft: CustomerSignUpDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): CustomerSignInResult!

  """
  Retrieves the authenticated customer (a customer that matches the given email/password pair).

  There may be carts and orders created before the sign in that should be assigned to the customer account. With the `anonymousCartId`, a single anonymous cart can be assigned. With the `anonymousId`, all orders and carts that have this `anonymousId` set will be assigned to the customer.
  If both `anonymousCartId` and `anonymousId` are given, the anonymous cart must have the `anonymousId`.

  Additionally, there might also exist one or more active customer carts from an earlier session. On customer sign in there are several ways how to proceed with this cart and the cart referenced by the `anonymousCartId`.

  * If the customer does not have a cart yet, the anonymous cart becomes the customer's cart.
  * If the customer already has one or more carts, the content of the anonymous cart will be copied to the customer's active cart that has been modified most recently.

    In this case the `CartState` of the anonymous cart gets changed to `Merged` while the customer's cart remains the `Active` cart.

    If a `LineItem` in the anonymous cart matches an existing line item, or a `CustomLineItem` matches an existing custom line item in the customer's cart, the maximum quantity of both line items is used as the new quantity.

    `ItemShippingDetails` are copied from the item with the highest quantity.

    If `itemShippingAddresses` are different in the two carts, the resulting cart contains the addresses of both the customer cart and the anonymous cart.

    Note, that it is not possible to merge carts that differ in their currency (set during creation of the cart).

  If a cart is is returned as part of the `CustomerSignInResult`, it has been recalculated (it will have up-to-date prices, taxes and discounts, and invalid line items have been removed).
  """
  customerSignIn(draft: CustomerSignInDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): CustomerSignInResult!
  updateCustomer(version: Long!, actions: [CustomerUpdateAction!]!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Customer
  deleteCustomer(version: Long!, personalDataErasure: Boolean = false,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Customer
  customerChangePassword(id: String!, version: Long!, currentPassword: String!, newPassword: String!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Customer

  """
  The following workflow can be used to reset the customer’s password:

  1. Create a password reset token and send it embedded in a link to the customer.
  2. When the customer clicks on the link, you may optionally retrieve customer by password token.
  3. When the customer entered new password, use reset customer’s password to reset the password.
  """
  customerResetPassword(version: Long, tokenValue: String!, newPassword: String!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Customer

  "Verifies customer's email using a token."
  customerConfirmEmail(version: Long, tokenValue: String!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Customer

  "The token value is used to reset the password of the customer with the given email. The token is valid only for 10 minutes."
  customerCreatePasswordResetToken(email: String!,

    "The validity of the created token in minutes."
    ttlMinutes: Int,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): CustomerPasswordToken
  customerCreateEmailVerificationToken(id: String!, version: Long,

    "The validity of the created token in minutes."
    ttlMinutes: Int!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): CustomerEmailToken!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta If used with an access token for Anonymous Sessions, all orders and carts belonging to the anonymousId will be assigned to the newly created customer."
  customerSignMeUp(draft: CustomerSignMeUpDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): CustomerSignInResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta

  Retrieves the authenticated customer (a customer that matches the given email/password pair).

  If used with an access token for Anonymous Sessions, all orders and carts belonging to the `anonymousId` will be assigned to the newly created customer.

  * If the customer does not have a cart yet, the anonymous cart that was modified most recently becomes the customer's cart.
  * If the customer already has a cart, the most recently modified anonymous cart will be handled according to the `AnonymousCartSignInMode`.

  If a cart is is returned as part of the `CustomerSignInResult`, it has been recalculated (it will have up-to-date prices, taxes and discounts, and invalid line items have been removed).
  """
  customerSignMeIn(draft: CustomerSignMeInDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): CustomerSignInResult!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta Signs up a new customer and associates it with the business unit."
  signUpInMyBusinessUnit(draft: SignUpInMyBusinessUnitDraft!): CustomerSignInResult!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  updateMyCustomer(version: Long!, actions: [MyCustomerUpdateAction!]!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Customer

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  deleteMyCustomer(version: Long!, personalDataErasure: Boolean = false,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Customer

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  customerChangeMyPassword(version: Long!, currentPassword: String!, newPassword: String!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Customer

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  customerConfirmMyEmail(tokenValue: String!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Customer

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  customerResetMyPassword(tokenValue: String!, newPassword: String!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Customer
  createInventoryEntry(draft: InventoryEntryDraft!): InventoryEntry
  updateInventoryEntry(version: Long!, actions: [InventoryEntryUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): InventoryEntry
  deleteInventoryEntry(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): InventoryEntry
  createCart(draft: CartDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument): Cart
  updateCart(version: Long!, actions: [CartUpdateAction!]!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Cart
  deleteCart(version: Long!, personalDataErasure: Boolean = false,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Cart
  replicateCart(reference: ReferenceInput!, key: String,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument): Cart

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  createMyCart(draft: MyCartDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Cart

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  updateMyCart(id: String!, version: Long!, actions: [MyCartUpdateAction!]!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Cart

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  deleteMyCart(id: String!, version: Long!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Cart

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  replicateMyCart(reference: ReferenceInput!): Cart
  createOrderFromCart(draft: OrderCartCommand!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument): Order
  updateOrder(version: Long!, actions: [OrderUpdateAction!]!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument,

    "Queries with specified ID"
    id: String, orderNumber: String): Order
  deleteOrder(version: Long!, personalDataErasure: Boolean = false,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String, orderNumber: String): Order

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  createMyOrderFromCart(draft: OrderMyCartCommand!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Order
  createOrderFromQuote(draft: OrderQuoteCommand!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument): Order

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  createMyOrderFromQuote(draft: OrderMyQuoteCommand!): Order
  importOrder(draft: ImportOrderDraft!): Order
  createOrderEdit(draft: OrderEditDraft!): OrderEdit
  updateOrderEdit(version: Long!, actions: [OrderEditUpdateAction!]!, dryRun: Boolean = false,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): OrderEdit
  deleteOrderEdit(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): OrderEdit
  createShoppingList(draft: ShoppingListDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): ShoppingList
  updateShoppingList(version: Long!, actions: [ShoppingListUpdateAction!]!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShoppingList
  deleteShoppingList(version: Long!, personalDataErasure: Boolean = false,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShoppingList

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  createMyShoppingList(draft: MyShoppingListDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): ShoppingList

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  updateMyShoppingList(version: Long!, actions: [MyShoppingListUpdateAction!]!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShoppingList

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  deleteMyShoppingList(version: Long!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShoppingList
  createPayment(draft: PaymentDraft!): Payment
  updatePayment(version: Long!, actions: [PaymentUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Payment
  deletePayment(version: Long!, personalDataErasure: Boolean = false,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Payment

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  createMyPayment(draft: MyPaymentDraft!): MyPayment
  updateMyPayment(id: String!, version: Long!, actions: [MyPaymentUpdateAction!]!): MyPayment
  deleteMyPayment(id: String!, version: Long!): MyPayment
  createProductSelection(draft: CreateProductSelectionDraft!): ProductSelection
  updateProductSelection(version: Long!, actions: [ProductSelectionUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ProductSelection
  deleteProductSelection(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ProductSelection
  createProductTailoring(
    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput, draft: ProductTailoringDraft!): ProductTailoring
  updateProductTailoring(
    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified Product ID"
    productId: String,

    "Queries with specified Product key"
    productKey: String,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String, actions: [ProductTailoringUpdateAction!]!, version: Long!): ProductTailoring
  deleteProductTailoring(
    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified Product ID"
    productId: String,

    "Queries with specified Product key"
    productKey: String,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String, version: Long!): ProductTailoring
  updateProject(version: Long!, actions: [ProjectSettingsUpdateAction!]!): ProjectProjection
  createStore(draft: CreateStore!): Store
  updateStore(version: Long!, actions: [StoreUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Store
  deleteStore(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Store
  createReview(draft: ReviewDraft!): Review
  updateReview(version: Long!, actions: [ReviewUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Review
  deleteReview(version: Long!, personalDataErasure: Boolean = false,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Review
  createSubscription(draft: SubscriptionDraft!): CommercetoolsSubscription
  updateSubscription(version: Long!, actions: [SubscriptionUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CommercetoolsSubscription
  deleteSubscription(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CommercetoolsSubscription
  createExtension(draft: ExtensionDraft!): Extension
  updateExtension(version: Long!, actions: [ExtensionUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Extension
  deleteExtension(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Extension
  createApiClient(draft: CreateApiClient!): APIClientWithSecret
  deleteApiClient(id: String!): APIClientWithoutSecret
  createStandalonePrice(draft: CreateStandalonePrice!): StandalonePrice
  updateStandalonePrice(version: Long!, actions: [StandalonePriceUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): StandalonePrice
  deleteStandalonePrice(version: Long!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): StandalonePrice
  createQuoteRequest(draft: QuoteRequestDraft!,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): QuoteRequest
  updateQuoteRequest(version: Long!,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument, actions: [QuoteRequestUpdateAction!]!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): QuoteRequest
  deleteQuoteRequest(version: Long!, personalDataErasure: Boolean = false,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): QuoteRequest
  createMyQuoteRequest(draft: MyQuoteRequestDraft!): QuoteRequest
  updateMyQuoteRequest(version: Long!, actions: [MyQuoteRequestUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): QuoteRequest
  createStagedQuote(draft: StagedQuoteDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): StagedQuote
  updateStagedQuote(version: Long!, actions: [StagedQuoteUpdateAction!]!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): StagedQuote
  deleteStagedQuote(version: Long!, personalDataErasure: Boolean = false,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): StagedQuote
  createQuote(draft: QuoteDraft!,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): Quote
  updateQuote(version: Long!, actions: [QuoteUpdateAction!]!,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Quote
  deleteQuote(version: Long!, personalDataErasure: Boolean = false,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Quote
  updateMyQuote(version: Long!, actions: [MyQuoteUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Quote
  createApprovalRule(draft: ApprovalRuleDraft!,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument!): ApprovalRule
  updateApprovalRule(version: Long!, actions: [ApprovalRuleUpdateAction!]!,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ApprovalRule
  updateApprovalFlow(version: Long!, actions: [ApprovalFlowUpdateAction!]!,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument!, id: String!): ApprovalFlow
  createBusinessUnit(draft: BusinessUnitDraft!,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument): BusinessUnit
  updateBusinessUnit(version: Long!, actions: [BusinessUnitUpdateAction!]!,

    "Create/modify entity as an associate in business-unit."
    asAssociate: AsAssociateArgument,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): BusinessUnit
  deleteBusinessUnit(version: Long!, personalDataErasure: Boolean = false,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): BusinessUnit
  createMyBusinessUnit(draft: MyBusinessUnitDraft!): BusinessUnit
  updateMyBusinessUnit(version: Long!, actions: [MyBusinessUnitUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): BusinessUnit
  createAssociateRole(draft: AssociateRoleDraft!): AssociateRole
  updateAssociateRole(version: Long!, actions: [AssociateRoleUpdateAction!]!,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): AssociateRole
  deleteAssociateRole(version: Long!, personalDataErasure: Boolean = false,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): AssociateRole
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input MyBusinessUnitDraft {
  key: String!
  name: String!
  contactEmail: String
  addresses: [AddressInput!]

  "The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address."
  defaultBillingAddress: Int

  "The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address."
  defaultShippingAddress: Int

  "The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses."
  shippingAddresses: [Int!] = []

  "The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses."
  billingAddresses: [Int!] = []
  custom: CustomFieldsDraft
  unitType: BusinessUnitType!
  storeMode: String
  parentUnit: ResourceIdentifierInput
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input MyBusinessUnitUpdateAction {
  addAddress: AddMyBusinessUnitAddress
  addBillingAddressId: AddMyBusinessUnitBillingAddressId
  addShippingAddressId: AddMyBusinessUnitShippingAddressId
  changeAddress: ChangeMyBusinessUnitAddress
  changeAssociate: ChangeMyBusinessUnitAssociate
  changeName: ChangeMyBusinessUnitName
  changeParentUnit: ChangeMyBusinessUnitParentUnit
  removeAddress: RemoveMyBusinessUnitAddress
  removeAssociate: RemoveMyBusinessUnitAssociate
  removeBillingAddressId: RemoveMyBusinessUnitBillingAddressId
  removeShippingAddressId: RemoveMyBusinessUnitShippingAddressId
  setAddressCustomField: SetMyBusinessUnitAddressCustomField
  setAddressCustomType: SetMyBusinessUnitAddressCustomType
  setContactEmail: SetMyBusinessUnitContactEmail
  setCustomField: SetMyBusinessUnitCustomField
  setCustomType: SetMyBusinessUnitCustomType
  setDefaultBillingAddress: SetMyBusinessUnitDefaultBillingAddress
  setDefaultShippingAddress: SetMyBusinessUnitDefaultShippingAddress
}

input MyCartDraft {
  currency: Currency!
  country: Country
  inventoryMode: InventoryMode = None
  custom: CustomFieldsDraft
  customerEmail: String
  shippingAddress: AddressInput
  billingAddress: AddressInput
  shippingMethod: ResourceIdentifierInput
  taxMode: TaxMode = Platform
  locale: Locale
  deleteDaysAfterLastModification: Int
  itemShippingAddresses: [AddressInput!] = []
  discountCodes: [String!] = []
  store: ResourceIdentifierInput
  businessUnit: ResourceIdentifierInput
  shippingMode: ShippingMode = Single
  customShipping: [CustomShippingDraft!] = []
  shipping: [ShippingDraft!] = []
  lineItems: [MyLineItemDraft!] = []
}

input MyCartUpdateAction {
  addDiscountCode: AddCartDiscountCode
  addItemShippingAddress: AddCartItemShippingAddress
  addLineItem: AddMyCartLineItem
  addPayment: AddCartPayment
  addShoppingList: AddCartShoppingList
  applyDeltaToLineItemShippingDetailsTargets: ApplyCartDeltaToLineItemShippingDetailsTargets
  changeLineItemsOrder: ChangeCartLineItemsOrder
  changeTaxMode: ChangeMyCartTaxMode
  recalculate: RecalculateCart
  removeDiscountCode: RemoveCartDiscountCode
  removeItemShippingAddress: RemoveCartItemShippingAddress
  removeLineItem: RemoveCartLineItem
  removePayment: RemoveCartPayment
  setBillingAddress: SetCartBillingAddress
  setBillingAddressCustomField: SetCartBillingAddressCustomField
  setBillingAddressCustomType: SetCartBillingAddressCustomType
  setBusinessUnit: SetCartBusinessUnit
  setCountry: SetCartCountry
  setCustomField: SetCartCustomField
  setCustomType: SetCartCustomType
  setCustomerEmail: SetCartCustomerEmail
  setDeleteDaysAfterLastModification: SetCartDeleteDaysAfterLastModification
  setItemShippingAddressCustomField: SetCartItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetCartItemShippingAddressCustomType
  setLineItemCustomField: SetCartLineItemCustomField
  setLineItemCustomType: SetCartLineItemCustomType
  setLineItemDistributionChannel: SetCartLineItemDistributionChannel
  setLineItemShippingDetails: SetCartLineItemShippingDetails
  setLineItemSupplyChannel: SetCartLineItemSupplyChannel
  setLocale: SetCartLocale
  setShippingMethod: SetMyCartShippingMethod
  setShippingAddress: SetCartShippingAddress
  setShippingAddressCustomField: SetCartShippingAddressCustomField
  setShippingAddressCustomType: SetCartShippingAddressCustomType
  setShippingCustomField: SetCartShippingCustomField
  setShippingCustomType: SetCartShippingCustomType
  updateItemShippingAddress: UpdateCartItemShippingAddress
  changeLineItemQuantity: ChangeCartLineItemQuantity
}

input MyCustomerUpdateAction {
  addAddress: AddCustomerAddress
  addBillingAddressId: AddCustomerBillingAddressId
  addShippingAddressId: AddCustomerShippingAddressId
  changeAddress: ChangeCustomerAddress
  changeEmail: ChangeCustomerEmail
  removeAddress: RemoveCustomerAddress
  removeBillingAddressId: RemoveCustomerBillingAddressId
  removeShippingAddressId: RemoveCustomerShippingAddressId
  setCompanyName: SetCustomerCompanyName
  setAddressCustomField: SetCustomerAddressCustomField
  setAddressCustomType: SetCustomerAddressCustomType
  setCustomField: SetCustomerCustomField
  setCustomType: SetCustomerCustomType
  setLocale: SetCustomerLocale
  setDateOfBirth: SetCustomerDateOfBirth
  setDefaultBillingAddress: SetCustomerDefaultBillingAddress
  setDefaultShippingAddress: SetCustomerDefaultShippingAddress
  setFirstName: SetCustomerFirstName
  setLastName: SetCustomerLastName
  setMiddleName: SetCustomerMiddleName
  setSalutation: SetCustomerSalutation
  setTitle: SetCustomerTitle
  setVatId: SetCustomerVatId
}

input MyLineItemDraft {
  key: String
  productId: String
  sku: String
  quantity: Long
  variantId: Int
  supplyChannel: ResourceIdentifierInput
  distributionChannel: ResourceIdentifierInput
  custom: CustomFieldsDraft
  shippingDetails: ItemShippingDetailsDraft
  addedAt: DateTime
}

"""
My Payments endpoint provides access to payments scoped to a specific user.
[documentation](https://docs.commercetools.com/api/projects/me-payments#mypayment)
"""
type MyPayment {
  id: String!
  version: Long!
  customerRef: Reference
  customer: Customer
  anonymousId: String
  paymentMethodInfo: PaymentMethodInfo!
  amountPlanned: Money!
  transactions: [Transaction!]!
  custom: CustomFieldsType
}

input MyPaymentDraft {
  amountPlanned: MoneyInput!
  paymentMethodInfo: PaymentMethodInfoInput
  custom: CustomFieldsDraft
  transaction: MyTransactionDraft
}

type MyPaymentQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [MyPayment!]!
}

input MyPaymentUpdateAction {
  addTransaction: AddMyPaymentTransaction
  changeAmountPlanned: ChangePaymentAmountPlanned
  setCustomField: SetPaymentCustomField
  setMethodInfoInterface: SetPaymentMethodInfoInterface
  setMethodInfoMethod: SetPaymentMethodInfoMethod
  setMethodInfoName: SetPaymentMethodInfoName
}

input MyQuoteRequestDraft {
  cartId: String!
  comment: String
  cartVersion: Long!
}

input MyQuoteRequestUpdateAction {
  cancelQuoteRequest: CancelQuoteRequest
  setCustomField: SetMyQuoteRequestCustomField
  setCustomType: SetMyQuoteRequestCustomType
}

enum MyQuoteState {
  Accepted
  Declined
}

input MyQuoteUpdateAction {
  changeMyQuoteState: ChangeMyQuoteMyQuoteState
  requestQuoteRenegotiation: RequestQuoteRenegotiation
  setCustomField: SetQuoteCustomField
  setCustomType: SetQuoteCustomType
}

input MyShoppingListDraft {
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  lineItems: [ShoppingListLineItemDraft!] = []
  textLineItems: [TextLineItemDraft!] = []
  custom: CustomFieldsDraft
  deleteDaysAfterLastModification: Int
}

input MyShoppingListUpdateAction {
  addLineItem: AddShoppingListLineItem
  addTextLineItem: AddShoppingListTextLineItem
  changeLineItemQuantity: ChangeShoppingListLineItemQuantity
  changeLineItemsOrder: ChangeShoppingListLineItemsOrder
  changeName: ChangeShoppingListName
  changeTextLineItemName: ChangeShoppingListTextLineItemName
  changeTextLineItemQuantity: ChangeShoppingListTextLineItemQuantity
  changeTextLineItemsOrder: ChangeShoppingListTextLineItemsOrder
  removeLineItem: RemoveShoppingListLineItem
  removeTextLineItem: RemoveShoppingListTextLineItem
  setCustomField: SetShoppingListCustomField
  setCustomType: SetShoppingListCustomType
  setDeleteDaysAfterLastModification: SetShoppingListDeleteDaysAfterLastModification
  setDescription: SetShoppingListDescription
  setLineItemCustomField: SetShoppingListLineItemCustomField
  setLineItemCustomType: SetShoppingListLineItemCustomType
  setStore: SetShoppingListStore
  setTextLineItemCustomField: SetShoppingListTextLineItemCustomField
  setTextLineItemCustomType: SetShoppingListTextLineItemCustomType
  setTextLineItemDescription: SetShoppingListTextLineItemDescription
}

input MyTransactionDraft {
  timestamp: DateTime
  type: TransactionType!
  amount: MoneyInput!
  interactionId: String
  custom: CustomFieldsDraft
}

type NestedAttributeDefinitionType implements AttributeDefinitionType {
  typeRef: Reference!
  name: String!
}

type NotProcessed implements OrderEditResult {
  type: String!
}

interface NotificationFormat {
  type: String!
}

type NumberAttribute implements Attribute {
  value: BigDecimal!
  name: String!
}

type NumberAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type NumberField implements CustomField {
  value: BigDecimal!
  name: String!
}

type NumberType implements FieldType {
  name: String!
}

"""
An order can be created from a cart, usually after a checkout process has been completed.
[documentation](https://docs.commercetools.com/api/projects/orders)
"""
type Order implements Versioned & ReferenceExpandable {
  customerId: String
  customer: Customer
  customerEmail: String
  anonymousId: String
  lineItems(
    "Queries with specified ID"
    id: String): [LineItem!]!
  customLineItems: [CustomLineItem!]!
  totalPrice: Money!
  taxedPrice: TaxedPrice
  discountOnTotalPrice: DiscountOnTotalPrice
  shippingAddress: Address
  billingAddress: Address
  inventoryMode: InventoryMode!
  taxMode: TaxMode!
  taxRoundingMode: RoundingMode!
  taxCalculationMode: TaxCalculationMode!
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  country: Country
  shippingKey: String
  shippingInfo: ShippingInfo
  discountCodes: [DiscountCodeInfo!]!
  directDiscounts: [DirectDiscount!]!
  refusedGifts: [CartDiscount!]!
  refusedGiftsRefs: [Reference!]!
  paymentInfo: PaymentInfo
  locale: Locale
  shippingRateInput: ShippingRateInput
  origin: CartOrigin!
  storeRef: KeyReference
  store: Store
  itemShippingAddresses: [Address!]!
  businessUnit: BusinessUnit
  businessUnitRef: KeyReference
  shipping: [Shipping!]!
  taxedShippingPrice: TaxedPrice
  shippingMode: ShippingMode!
  shippingCustomFields: CustomFieldsType
  completedAt: DateTime
  orderNumber: String
  orderState: OrderState!
  stateRef: Reference
  state: State
  shipmentState: ShipmentState
  paymentState: PaymentState
  syncInfo: [SyncInfo!]!
  returnInfo: [ReturnInfo!]!
  purchaseOrderNumber: String
  lastMessageSequenceNumber: Long! @deprecated(reason: "An internal field that should not be used in customer logic")
  cartRef: Reference
  cart: Cart
  quoteRef: Reference
  quote: Quote
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type OrderBillingAddressSet implements MessagePayload & OrderMessagePayload {
  address: Address
  oldAddress: Address
  type: String!
}

input OrderCartCommand {
  id: String
  cart: ResourceIdentifierInput
  version: Long!
  purchaseOrderNumber: String
  paymentState: PaymentState
  orderState: OrderState
  state: ResourceIdentifierInput
  shipmentState: ShipmentState
  orderNumber: String
  custom: CustomFieldsDraft
}

type OrderCreated implements MessagePayload & OrderMessagePayload {
  order: Order!
  type: String!
}

type OrderCustomFieldAdded implements MessagePayload & OrderMessagePayload {
  name: String!
  value: Json!
  type: String!
}

type OrderCustomFieldChanged implements MessagePayload & OrderMessagePayload {
  name: String!
  value: Json!
  previousValue: Json
  type: String!
}

type OrderCustomFieldRemoved implements MessagePayload & OrderMessagePayload {
  name: String!
  type: String!
}

type OrderCustomLineItemAdded implements MessagePayload & OrderMessagePayload {
  customLineItem: CustomLineItem!
  type: String!
}

type OrderCustomLineItemDiscountSet implements MessagePayload & OrderMessagePayload {
  customLineItemId: String!
  customLineItemKey: String
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  taxedPrice: TaxedItemPrice
  type: String!
}

type OrderCustomLineItemQuantityChanged implements MessagePayload & OrderMessagePayload {
  customLineItemId: String!
  customLineItemKey: String
  quantity: Long!
  oldQuantity: Long
  type: String!
}

type OrderCustomLineItemRemoved implements MessagePayload & OrderMessagePayload {
  customLineItemId: String!
  customLineItemKey: String
  customLineItem: CustomLineItem
  type: String!
}

type OrderCustomTypeRemoved implements MessagePayload & OrderMessagePayload {
  previousTypeId: String
  type: String!
}

type OrderCustomTypeSet implements MessagePayload & OrderMessagePayload {
  customFields: CustomFieldsType!
  previousTypeId: String
  type: String!
}

type OrderCustomerEmailSet implements MessagePayload & OrderMessagePayload {
  email: String
  oldEmail: String
  type: String!
}

type OrderCustomerGroupSet implements MessagePayload & OrderMessagePayload {
  customerGroup: CustomerGroup
  oldCustomerGroup: CustomerGroup
  customerGroupRef: Reference
  oldCustomerGroupRef: Reference
  type: String!
}

type OrderCustomerSet implements MessagePayload & OrderMessagePayload {
  customer: Customer
  oldCustomer: Customer
  customerGroup: CustomerGroup
  oldCustomerGroup: CustomerGroup
  customerRef: Reference
  oldCustomerRef: Reference
  customerGroupRef: Reference
  oldCustomerGroupRef: Reference
  type: String!
}

type OrderDeleted implements MessagePayload & OrderMessagePayload {
  order: Order
  type: String!
}

type OrderDiscountCodeAdded implements MessagePayload & OrderMessagePayload {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}

type OrderDiscountCodeRemoved implements MessagePayload & OrderMessagePayload {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}

type OrderDiscountCodeStateSet implements MessagePayload & OrderMessagePayload {
  state: DiscountCodeState!
  oldState: DiscountCodeState
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}

type OrderEdit implements Versioned {
  key: String
  resourceRef: Reference!
  resource: Order
  stagedActions: [StagedOrderUpdateActionOutput!]!
  result: OrderEditResult!
  comment: String
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type OrderEditApplied implements MessagePayload & OrderMessagePayload {
  result: Applied!
  edit: OrderEdit
  editRef: Reference!
  type: String!
}

input OrderEditDraft {
  key: String
  resource: ReferenceInput!
  stagedActions: [StagedOrderUpdateAction!]!
  custom: CustomFieldsDraft
  comment: String
  dryRun: Boolean
}

type OrderEditLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type OrderEditLimitsProjection {
  total: OrderEditLimitWithCurrent!
}

type OrderEditQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [OrderEdit!]!
}

interface OrderEditResult {
  type: String!
}

input OrderEditUpdateAction {
  addStagedAction: AddOrderEditStagedAction
  setComment: SetOrderEditComment
  setCustomField: SetOrderEditCustomField
  setCustomType: SetOrderEditCustomType
  setKey: SetOrderEditKey
  setStagedActions: SetOrderEditStagedActions
}

type OrderExcerpt {
  totalPrice: Money!
  taxedPrice: TaxedPrice
  version: Long
}

type OrderImported implements MessagePayload & OrderMessagePayload {
  order: Order!
  type: String!
}

type OrderLineItemAdded implements MessagePayload & OrderMessagePayload {
  lineItem: LineItem!
  addedQuantity: Long!
  type: String!
}

type OrderLineItemDiscountSet implements MessagePayload & OrderMessagePayload {
  lineItemId: String!
  lineItemKey: String
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  totalPrice: Money!
  taxedPricePortions: [MethodTaxedPrice!]!
  taxedPrice: TaxedItemPrice
  type: String!
}

type OrderLineItemDistributionChannelSet implements MessagePayload & OrderMessagePayload {
  lineItemId: String!
  lineItemKey: String
  distributionChannel: Channel
  distributionChannelRef: Reference
  type: String!
}

type OrderLineItemRemoved implements MessagePayload & OrderMessagePayload {
  lineItemId: String!
  lineItemKey: String
  removedQuantity: Long!
  newQuantity: Long!
  newState: Set!
  newTotalPrice: Money!
  newPrice: ProductPrice
  newShippingDetails: ItemShippingDetails
  newTaxedPrice: TaxedItemPrice
  type: String!
}

interface OrderMessagePayload {
  type: String!
}

input OrderMyCartCommand {
  id: String!
  version: Long!
}

input OrderMyQuoteCommand {
  id: String!
  version: Long!
  quoteStateToAccepted: Boolean = false
}

type OrderPaymentAdded implements MessagePayload & OrderMessagePayload {
  paymentRef: Reference!
  type: String!
}

type OrderPaymentRemoved implements MessagePayload & OrderMessagePayload {
  paymentRef: Reference!
  removedPaymentInfo: Boolean!
  type: String!
}

type OrderPaymentStateChanged implements MessagePayload & OrderMessagePayload {
  paymentState: PaymentState!
  oldPaymentState: PaymentState
  type: String!
}

"Fields to access orders. Includes direct access to a single order and searching for orders."
interface OrderQueryInterface {
  order(
    "Queries with specified ID"
    id: String, orderNumber: String): Order
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
}

type OrderQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Order!]!
}

input OrderQuoteCommand {
  quote: ResourceIdentifierInput
  version: Long!
  quoteStateToAccepted: Boolean = false
  paymentState: PaymentState
  orderState: OrderState
  state: ResourceIdentifierInput
  shipmentState: ShipmentState
  orderNumber: String
  custom: CustomFieldsDraft
}

type OrderReturnShipmentStateChanged implements MessagePayload & OrderMessagePayload {
  returnItemId: String!
  returnShipmentState: ReturnShipmentState!
  type: String!
}

type OrderSearchConfiguration {
  status: OrderSearchStatus!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
}

enum OrderSearchStatus {
  Activated
  Deactivated
}

type OrderShipmentStateChanged implements MessagePayload & OrderMessagePayload {
  shipmentState: ShipmentState!
  oldShipmentState: ShipmentState
  type: String!
}

type OrderShippingAddressSet implements MessagePayload & OrderMessagePayload {
  address: Address
  oldAddress: Address
  type: String!
}

type OrderShippingInfoSet implements MessagePayload & OrderMessagePayload {
  shippingInfo: ShippingInfo
  oldShippingInfo: ShippingInfo
  type: String!
}

type OrderShippingRateInputSet implements MessagePayload & OrderMessagePayload {
  shippingRateInput: ShippingRateInput
  oldShippingRateInput: ShippingRateInput
  type: String!
}

enum OrderState {
  Cancelled
  Complete
  Confirmed
  Open
}

type OrderStateChanged implements MessagePayload & OrderMessagePayload {
  orderId: String!
  orderState: OrderState!
  oldOrderState: OrderState
  type: String!
}

type OrderStateTransition implements MessagePayload & OrderMessagePayload {
  force: Boolean!
  state: State
  oldState: State
  stateRef: Reference!
  oldStateRef: Reference
  type: String!
}

type OrderStoreSet implements MessagePayload & OrderMessagePayload {
  store: Store
  oldStore: Store
  storeRef: KeyReference
  oldStoreRef: KeyReference
  type: String!
}

input OrderUpdateAction {
  addDelivery: AddOrderDelivery
  addItemShippingAddress: AddOrderItemShippingAddress
  addParcelToDelivery: AddOrderParcelToDelivery
  addPayment: AddOrderPayment
  addReturnInfo: AddOrderReturnInfo
  changeOrderState: ChangeOrderState
  changePaymentState: ChangeOrderPaymentState
  changeShipmentState: ChangeOrderShipmentState
  importCustomLineItemState: ImportOrderCustomLineItemState
  importLineItemState: ImportOrderLineItemState
  removeDelivery: RemoveOrderDelivery
  removeItemShippingAddress: RemoveOrderItemShippingAddress
  removeParcelFromDelivery: RemoveOrderParcelFromDelivery
  removePayment: RemoveOrderPayment
  setBillingAddress: SetOrderBillingAddress
  setBillingAddressCustomField: SetOrderBillingAddressCustomField
  setBillingAddressCustomType: SetOrderBillingAddressCustomType
  setCustomField: SetOrderCustomField
  setCustomLineItemCustomField: SetOrderCustomLineItemCustomField
  setCustomLineItemCustomType: SetOrderCustomLineItemCustomType
  setCustomLineItemShippingDetails: SetOrderCustomLineItemShippingDetails
  setCustomType: SetOrderCustomType
  setCustomerEmail: SetOrderCustomerEmail
  setCustomerId: SetOrderCustomerId
  setDeliveryAddress: SetOrderDeliveryAddress
  setDeliveryAddressCustomField: SetOrderDeliveryAddressCustomField
  setDeliveryAddressCustomType: SetOrderDeliveryAddressCustomType
  setDeliveryCustomField: SetOrderDeliveryCustomField
  setDeliveryCustomType: SetOrderDeliveryCustomType
  setDeliveryItems: SetOrderDeliveryItems
  setItemShippingAddressCustomField: SetOrderItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetOrderItemShippingAddressCustomType
  setLineItemCustomField: SetOrderLineItemCustomField
  setLineItemCustomType: SetOrderLineItemCustomType
  setLineItemShippingDetails: SetOrderLineItemShippingDetails
  setLocale: SetOrderLocale
  setOrderNumber: SetOrderNumber
  setParcelCustomField: SetOrderParcelCustomField
  setParcelCustomType: SetOrderParcelCustomType
  setParcelItems: SetOrderParcelItems
  setParcelMeasurements: SetOrderParcelMeasurements
  setParcelTrackingData: SetOrderParcelTrackingData
  setPurchaseOrderNumber: SetOrderPurchaseOrderNumber
  setReturnInfo: SetOrderReturnInfo
  setReturnItemCustomField: SetOrderReturnItemCustomField
  setReturnItemCustomType: SetOrderReturnItemCustomType
  setReturnPaymentState: SetOrderReturnPaymentState
  setReturnShipmentState: SetOrderReturnShipmentState
  setShippingAddress: SetOrderShippingAddress
  setShippingAddressCustomField: SetOrderShippingAddressCustomField
  setShippingAddressCustomType: SetOrderShippingAddressCustomType
  setShippingCustomField: SetOrderShippingCustomField
  setShippingCustomType: SetOrderShippingCustomType
  setStore: SetOrderStore
  transitionCustomLineItemState: TransitionOrderCustomLineItemState
  transitionLineItemState: TransitionOrderLineItemState
  transitionState: TransitionOrderState
  updateItemShippingAddress: UpdateOrderItemShippingAddress
  updateSyncInfo: UpdateOrderSyncInfo
}

type Parcel {
  id: String!
  key: String
  createdAt: DateTime!
  measurements: ParcelMeasurements
  trackingData: TrackingData
  items: [DeliveryItem!]!
  custom: CustomFieldsType
}

type ParcelAddedToDelivery implements MessagePayload & OrderMessagePayload {
  delivery: Delivery!
  parcel: Parcel!
  shippingKey: String
  type: String!
}

type ParcelData {
  key: String
  measurements: ParcelMeasurements
  trackingData: TrackingData
  items: [DeliveryItem!]!
  custom: CustomFieldsCommand
}

input ParcelDataDraftType {
  key: String
  measurements: ParcelMeasurementsDraftType
  trackingData: TrackingDataDraftType
  items: [DeliveryItemDraftType!] = []
  custom: CustomFieldsDraft
}

input ParcelDraft {
  id: String!
  key: String
  createdAt: DateTime!
  measurements: ParcelMeasurementsDraftType
  trackingData: TrackingDataDraftType
  items: [DeliveryItemDraftType!] = []
  custom: CustomFieldsDraft
}

type ParcelItemsUpdated implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  parcelId: String!
  items: [DeliveryItem!]!
  oldItems: [DeliveryItem!]!
  shippingKey: String
  type: String!
}

type ParcelMeasurements {
  heightInMillimeter: Int
  lengthInMillimeter: Int
  widthInMillimeter: Int
  weightInGram: Int
}

input ParcelMeasurementsDraftType {
  heightInMillimeter: Int
  lengthInMillimeter: Int
  widthInMillimeter: Int
  weightInGram: Int
}

type ParcelMeasurementsUpdated implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  parcelId: String!
  measurements: ParcelMeasurements
  shippingKey: String
  type: String!
}

type ParcelRemovedFromDelivery implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  parcel: Parcel!
  shippingKey: String
  type: String!
}

type ParcelTrackingDataUpdated implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  parcelId: String!
  trackingData: TrackingData
  shippingKey: String
  type: String!
}

"""
Payments hold information about the current state of receiving and/or refunding money.
[documentation](https://docs.commercetools.com/api/projects/payments)
"""
type Payment implements Versioned {
  key: String
  customerRef: Reference
  customer: Customer
  anonymousId: String
  interfaceId: String
  amountPlanned: Money!
  paymentMethodInfo: PaymentMethodInfo!
  paymentStatus: PaymentStatus!
  transactions: [Transaction!]!
  interfaceInteractionsRaw(limit: Int, offset: Int): InterfaceInteractionsRawResult!
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type PaymentCreated implements MessagePayload {
  payment: Payment!
  type: String!
}

input PaymentDraft {
  amountPlanned: MoneyInput!
  paymentMethodInfo: PaymentMethodInfoInput
  custom: CustomFieldsDraft
  key: String
  customer: ResourceIdentifierInput
  anonymousId: String
  interfaceId: String
  paymentStatus: PaymentStatusInput
  transactions: [TransactionDraft!]
  interfaceInteractions: [CustomFieldsDraft!]
}

type PaymentInfo {
  payments: [Payment!]!
  paymentRefs: [Reference!]!
}

type PaymentInteractionAdded implements MessagePayload {
  interaction: CustomFieldsType!
  type: String!
}

type PaymentMethodInfo {
  paymentInterface: String
  method: String
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
}

input PaymentMethodInfoInput {
  paymentInterface: String
  method: String
  name: [LocalizedStringItemInputType!]
}

type PaymentQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Payment!]!
}

enum PaymentState {
  BalanceDue
  CreditOwed
  Failed
  Paid
  Pending
}

type PaymentStatus {
  interfaceCode: String
  interfaceText: String
  stateRef: Reference
  state: State
}

input PaymentStatusInput {
  interfaceCode: String
  interfaceText: String
  state: ResourceIdentifierInput
}

type PaymentStatusInterfaceCodeSet implements MessagePayload {
  paymentId: String!
  interfaceCode: String
  type: String!
}

type PaymentStatusStateTransition implements MessagePayload {
  force: Boolean!
  state: State
  stateRef: Reference
  type: String!
}

type PaymentTransactionAdded implements MessagePayload {
  transaction: Transaction!
  type: String!
}

type PaymentTransactionStateChanged implements MessagePayload {
  transactionId: String!
  state: TransactionState!
  type: String!
}

input PaymentUpdateAction {
  addInterfaceInteraction: AddPaymentInterfaceInteraction
  addTransaction: AddPaymentTransaction
  changeAmountPlanned: ChangePaymentAmountPlanned
  changeTransactionInteractionId: ChangePaymentTransactionInteractionId
  changeTransactionState: ChangePaymentTransactionState
  changeTransactionTimestamp: ChangePaymentTransactionTimestamp
  setAmountPaid: SetPaymentAmountPaid
  setAmountRefunded: SetPaymentAmountRefunded
  setAnonymousId: SetPaymentAnonymousId
  setAuthorization: SetPaymentAuthorization
  setCustomField: SetPaymentCustomField
  setCustomType: SetPaymentCustomType
  setCustomer: SetPaymentCustomer
  setExternalId: SetPaymentExternalId
  setInterfaceId: SetPaymentInterfaceId
  setKey: SetPaymentKey
  setMethodInfoInterface: SetPaymentMethodInfoInterface
  setMethodInfoMethod: SetPaymentMethodInfoMethod
  setMethodInfoName: SetPaymentMethodInfoName
  setStatusInterfaceCode: SetPaymentStatusInterfaceCode
  setStatusInterfaceText: SetPaymentStatusInterfaceText
  setTransactionCustomField: SetPaymentTransactionCustomField
  setTransactionCustomType: SetPaymentTransactionCustomType
  transitionState: TransitionPaymentState
}

enum Permission {
  AcceptMyQuotes
  AcceptOthersQuotes
  AddChildUnits
  CreateApprovalRules
  CreateMyCarts
  CreateMyOrdersFromMyCarts
  CreateMyOrdersFromMyQuotes
  CreateMyQuoteRequestsFromMyCarts
  CreateOrdersFromOthersCarts
  CreateOrdersFromOthersQuotes
  CreateOthersCarts
  CreateQuoteRequestsFromOthersCarts
  DeclineMyQuotes
  DeclineOthersQuotes
  DeleteMyCarts
  DeleteOthersCarts
  ReassignMyQuotes
  ReassignOthersQuotes
  RenegotiateMyQuotes
  RenegotiateOthersQuotes
  UpdateApprovalFlows
  UpdateApprovalRules
  UpdateAssociates
  UpdateBusinessUnitDetails
  UpdateMyCarts
  UpdateMyOrders
  UpdateMyQuoteRequests
  UpdateOthersCarts
  UpdateOthersOrders
  UpdateOthersQuoteRequests
  UpdateParentUnit
  ViewMyCarts
  ViewMyOrders
  ViewMyQuoteRequests
  ViewMyQuotes
  ViewOthersCarts
  ViewOthersOrders
  ViewOthersQuoteRequests
  ViewOthersQuotes
}

type PlainEnumValue {
  key: String!
  label: String!
}

input PlainEnumValueDraft {
  key: String!
  label: String!
}

type PlainEnumValueResult {
  limit: Int
  offset: Int
  total: Int!
  results: [PlainEnumValue!]!
}

type PlatformFormat implements NotificationFormat {
  type: String!
}

input PlatformFormatInput {
  dummy: String
}

type Point implements Geometry {
  type: String!
  coordinates: [Float!]!
}

type PreviewFailure implements OrderEditResult {
  type: String!
  errors: [Json!]!
}

type PreviewSuccess implements OrderEditResult {
  type: String!
  preview: Order!
  messagePayloads: [OrderMessagePayload!]!
}

type PriceFunction {
  function: String!
  currencyCode: Currency!
}

input PriceFunctionDraft {
  function: String!
  currencyCode: Currency!
}

"""
This mode determines which type of Prices the system uses for
Product Price Selection as well as for LineItem Price selection
"""
enum PriceMode {
  "The system looks up prices from the `prices` field of the ProductVariant inside a Product."
  Embedded

  "The system looks up prices from Standalone Prices, stored separately from Products."
  Standalone
}

input PriceSelectorInput {
  currency: Currency!
  country: Country
  customerGroup: ReferenceInput
  channel: ReferenceInput
  date: DateTime
}

type Product implements Versioned & ReviewTarget & ReferenceExpandable {
  id: String!
  key: String
  version: Long!
  productTypeRef: Reference!
  productType: ProductTypeDefinition
  masterData: ProductCatalogData!
  skus: [String!]!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  stateRef: Reference
  state: State
  priceMode: PriceMode
  taxCategoryRef: Reference
  taxCategory: TaxCategory
  reviewRatingStatistics: ReviewRatingStatistics
  productSelectionRefs(where: String, sort: [String!], limit: Int, offset: Int): SelectionOfProductQueryResult!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type ProductAddedToCategory implements MessagePayload {
  category: ReferenceId!
  staged: Boolean!
  type: String!
}

type ProductAssignment {
  productRef: Reference!
  product: Product
  productSelectionRef: Reference!
  productSelection: ProductSelection
  variantSelection: ProductVariantSelection
  variantExclusion: ProductVariantExclusion
}

type ProductAssignmentQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [ProductAssignment!]!
}

"""
An input object used to define a ProductAttribute.

The value should be passed in a form of escaped JSON.


Examples for `value`:

* FieldType `String`: `"\"This is a string\""`
* FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
* FieldType `Number`: `"4"`
* FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
* FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
"""
input ProductAttributeInput {
  name: String!

  """
  The value should be passed in a form of escaped JSON.


  Examples for `value`:

  * FieldType `String`: `"\"This is a string\""`
  * FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
  * FieldType `Number`: `"4"`
  * FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
  * FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
  """
  value: String!
}

type ProductCatalogData {
  current: ProductData
  staged: ProductData
  published: Boolean!
  hasStagedChanges: Boolean!
}

type ProductCreated implements MessagePayload {
  productProjection: ProductProjectionMessagePayload!
  type: String!
}

type ProductData {
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  descriptionAllLocales: [LocalizedString!]
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  categoryOrderHint(categoryId: String!): String
  categoryOrderHints: [CategoryOrderHint!]!
  categoriesRef: [Reference!]!
  categories: [Category!]!
  searchKeyword(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale!): [SearchKeyword!]
  searchKeywords: [SearchKeywords!]!
  metaTitle(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaKeywords(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaDescription(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]
  masterVariant: ProductVariant!
  variants(
    "Queries for products with specified SKUs"
    skus: [String!], isOnStock: Boolean,

    """
    The IDs of channels for which to check the stock of the `isOnStock`.

    Variant is returned if at least one of the channels is matching the `isOnStock`

    If the list is not provided then noChannel is checked for `isOnStock`
    """
    stockChannelIds: [String!], hasImages: Boolean): [ProductVariant!]!
  allVariants(
    "Queries for products with specified SKUs"
    skus: [String!], isOnStock: Boolean,

    """
    The IDs of channels for which to check the stock of the `isOnStock`.

    Variant is returned if at least one of the channels is matching the `isOnStock`

    If the list is not provided then noChannel is checked for `isOnStock`
    """
    stockChannelIds: [String!], hasImages: Boolean): [ProductVariant!]!
  variant(
    "Queries for a variant with specified SKU"
    sku: String,

    "Queries for a [ProductVariant](https://docs.commercetools.com/api/projects/products#productvariant) with specified `key`"
    key: String): ProductVariant
  skus: [String!]!
}

type ProductDeleted implements MessagePayload {
  removedImageUrls: Set!
  currentProjection: ProductProjectionMessagePayload
  type: String!
}

"\nA product price can be discounted in two ways:\n\n* with a relative or an absolute product discount, which will be automatically applied to all prices in a product that match a discount predicate.\n  A relative discount reduces the matching price by a fraction (for example 10 % off). An absolute discount reduces the matching price by a fixed amount (for example 10\u20AC off). If more than one product discount matches a price, the discount sort order determines which one will be applied.\n* with an external product discount, which can then be used to explicitly set a discounted value on a particular product price.\n\nThe discounted price is stored in the discounted field of the Product Price.\n\nNote that when a discount is created, updated or removed it can take up to 15 minutes to update all the prices with the discounts.\n\nThe maximum number of ProductDiscounts that can be active at the same time is **200**.\n      "
type ProductDiscount implements Versioned & ReferenceExpandable {
  predicate: String!
  validFrom: DateTime
  validUntil: DateTime
  isActive: Boolean!
  isValid: Boolean!
  sortOrder: String!
  key: String
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  referenceRefs: [Reference!]!
  nameAllLocales: [LocalizedString!]!
  descriptionAllLocales: [LocalizedString!]
  value: ProductDiscountValue!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

input ProductDiscountDraft {
  value: ProductDiscountValueInput!
  predicate: String!
  sortOrder: String!
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  validFrom: DateTime
  validUntil: DateTime
  isActive: Boolean = true
  key: String
}

type ProductDiscountLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type ProductDiscountLimitsProjection {
  totalActive: ProductDiscountLimitWithCurrent!
}

type ProductDiscountQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [ProductDiscount!]!
}

input ProductDiscountUpdateAction {
  changeIsActive: ChangeProductDiscountIsActive
  changeName: ChangeProductDiscountName
  changePredicate: ChangeProductDiscountPredicate
  changeSortOrder: ChangeProductDiscountSortOrder
  changeValue: ChangeProductDiscountValue
  setDescription: SetProductDiscountDescription
  setKey: SetProductDiscountKey
  setValidFrom: SetProductDiscountValidFrom
  setValidFromAndUntil: SetProductDiscountValidFromAndUntil
  setValidUntil: SetProductDiscountValidUntil
}

interface ProductDiscountValue {
  type: String!
}

input ProductDiscountValueInput {
  relative: RelativeDiscountValueInput
  absolute: AbsoluteDiscountValueInput
  external: ExternalDiscountValueInput
}

input ProductDraft {
  name: [LocalizedStringItemInputType!]!
  productType: ResourceIdentifierInput!
  slug: [LocalizedStringItemInputType!]!
  key: String
  description: [LocalizedStringItemInputType!]
  categories: [ResourceIdentifierInput!]
  categoryOrderHints: [CategoryOrderHintInput!]
  metaTitle: [LocalizedStringItemInputType!]
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  masterVariant: ProductVariantInput
  variants: [ProductVariantInput!] = []
  taxCategory: ResourceIdentifierInput
  state: ResourceIdentifierInput
  priceMode: PriceMode
  searchKeywords: [SearchKeywordInput!]
  publish: Boolean
}

type ProductImageAdded implements MessagePayload {
  variantId: Int!
  image: Image!
  staged: Boolean!
  type: String!
}

type ProductLimitsProjection {
  pricesPerVariant: Limit!
  variants: Limit!
  productTailoring: Limit!
}

type ProductOfSelection {
  productRef: Reference!
  product: Product
  variantSelection: ProductVariantSelection
  variantExclusion: ProductVariantExclusion
}

type ProductOfSelectionQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [ProductOfSelection!]!
}

type ProductPrice {
  id: String
  value: BaseMoney!
  key: String
  country: Country
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  channel: Channel
  channelRef: Reference
  validFrom: DateTime
  validUntil: DateTime
  discounted: DiscountedProductPriceValue
  tiers: [ProductPriceTier!]
  custom: CustomFieldsType
}

type ProductPriceAdded implements MessagePayload {
  variantId: Int!
  price: ProductPrice!
  staged: Boolean!
  type: String!
}

type ProductPriceChanged implements MessagePayload {
  variantId: Int!
  oldPrice: ProductPrice!
  newPrice: ProductPrice!
  staged: Boolean!
  oldStagedPrice: ProductPrice
  type: String!
}

type ProductPriceCustomFieldAdded implements MessagePayload {
  priceId: String!
  variantId: Int!
  staged: Boolean!
  name: String!
  value: Json!
  type: String!
}

type ProductPriceCustomFieldChanged implements MessagePayload {
  priceId: String!
  variantId: Int!
  staged: Boolean!
  name: String!
  value: Json!
  type: String!
}

type ProductPriceCustomFieldRemoved implements MessagePayload {
  priceId: String!
  variantId: Int!
  staged: Boolean!
  name: String!
  type: String!
}

type ProductPriceCustomFieldsRemoved implements MessagePayload {
  priceId: String!
  variantId: Int!
  staged: Boolean!
  type: String!
}

type ProductPriceCustomFieldsSet implements MessagePayload {
  priceId: String!
  variantId: Int!
  staged: Boolean!
  customField: CustomFieldsType!
  oldTypeId: String
  type: String!
}

input ProductPriceDataInput {
  value: BaseMoneyInput!
  key: String
  country: Country
  customerGroup: ReferenceInput
  channel: ResourceIdentifierInput
  validFrom: DateTime
  validUntil: DateTime
  tiers: [ProductPriceTierInput!] = []
  custom: CustomFieldsDraft
  discounted: DiscountedProductPriceValueInput
}

type ProductPriceDiscountUpdateMessagePayload {
  variantId: Int!
  variantKey: String
  sku: String
  priceId: String!
  discounted: DiscountedProductPriceValue
  staged: Boolean!
}

type ProductPriceDiscountsSet implements MessagePayload {
  updatedPrices: [ProductPriceDiscountUpdateMessagePayload!]!
  type: String!
}

type ProductPriceExternalDiscountSet implements MessagePayload {
  variantId: Int!
  variantKey: String
  sku: String
  priceId: String!
  discounted: DiscountedProductPriceValue
  staged: Boolean!
  type: String!
}

type ProductPriceKeySet implements MessagePayload {
  variantId: Int!
  priceId: String
  oldKey: String
  key: String
  staged: Boolean!
  type: String!
}

type ProductPriceModeSet implements MessagePayload {
  to: PriceMode
  type: String!
}

type ProductPriceRemoved implements MessagePayload {
  variantId: Int!
  price: ProductPrice!
  staged: Boolean!
  type: String!
}

type ProductPriceSearch {
  id: String
  value: BaseMoney!
  key: String
  country: Country
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  channel: Channel
  channelRef: Reference
  validFrom: DateTime
  validUntil: DateTime
  discounted: DiscountedProductSearchPriceValue
  tiers: [ProductSearchPriceTier!]
  custom: CustomFieldsType
}

type ProductPriceTier {
  minimumQuantity: Int!
  value: BaseMoney!
}

input ProductPriceTierInput {
  minimumQuantity: Int!
  value: BaseMoneyInput!
}

type ProductPricesSet implements MessagePayload {
  variantId: Int!
  prices: [ProductPrice!]!
  staged: Boolean!
  type: String!
}

type ProductProjection {
  id: String!
  key: String
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  productTypeRef: Reference!
  productType: ProductTypeDefinition
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  categoryOrderHints: [CategoryOrderHintProductSearch!]!
  categoriesRef: [Reference!]!
  categories: [Category!]!
  searchKeywords: [SearchKeywordsProductSearch!]!
  metaTitle(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaKeywords(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaDescription(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]
  hasStagedChanges: Boolean!
  published: Boolean!
  masterVariant: ProductSearchVariant!
  variants: [ProductSearchVariant!]!
  taxCategoryRef: Reference
  taxCategory: TaxCategory
  stateRef: Reference
  state: State
  reviewRatingStatistics: ReviewRatingStatistics
}

type ProductProjectionMessagePayload {
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  productTypeRef: Reference!
  productType: ProductTypeDefinition
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  categoryOrderHints: [CategoryOrderHint!]!
  categoriesRef: [Reference!]!
  categories: [Category!]!
  searchKeywords: [SearchKeywords!]!
  metaTitle(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaKeywords(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaDescription(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]
  hasStagedChanges: Boolean!
  published: Boolean!
  masterVariant: ProductVariant!
  variants: [ProductVariant!]!
  taxCategoryRef: Reference
  taxCategory: TaxCategory
  stateRef: Reference
  state: State
  reviewRatingStatistics: ReviewRatingStatistics
}

type ProductProjectionSearchResult {
  offset: Int!
  count: Int!
  total: Int!
  results: [ProductProjection!]!
  facets: [FacetResultValue!]!
}

type ProductPublished implements MessagePayload {
  productProjection: ProductProjectionMessagePayload!
  removedImageUrls: [String!]!
  scope: PublishScope!
  type: String!
}

type ProductQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Product!]!
}

type ProductReferenceIdentifier {
  typeId: String!
  id: String
  key: String
}

type ProductRemovedFromCategory implements MessagePayload {
  category: ReferenceId!
  staged: Boolean!
  type: String!
}

type ProductRevertedStagedChanges implements MessagePayload {
  removedImageUrls: Set!
  type: String!
}

type ProductSearchPriceTier {
  minimumQuantity: Int!
  value: BaseMoney!
}

type ProductSearchVariant {
  id: Int!
  key: String
  sku: String
  prices: [ProductPriceSearch!]

  "Returns a single price based on the price selection rules."
  price(currency: Currency!, country: Country, customerGroupId: String, channelId: String, date: DateTime): ProductPriceSearch
  images: [ImageProductSearch!]!
  assets: [Asset!]!
  availability: ProductSearchVariantAvailabilityWithChannels

  "This field contains raw attributes data"
  attributesRaw(
    """
    The names of the attributes to include.

    If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
    """
    includeNames: [String!],

    """
    The names of the attributes to exclude.

    If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
    """
    excludeNames: [String!]): [RawProductSearchAttribute!]!
  isMatchingVariant: Boolean
  scopedPrice: ScopedPrice
  scopedPriceDiscounted: Boolean
}

"Product variant availabilities"
type ProductSearchVariantAvailabilitiesResult {
  limit: Int
  offset: Int
  total: Int!
  results: [ProductSearchVariantAvailabilityWithChannel!]!
}

"Product variant availability"
type ProductSearchVariantAvailability {
  isOnStock: Boolean!
  restockableInDays: Int
  availableQuantity: Long
  version: Long
  id: String
}

type ProductSearchVariantAvailabilityWithChannel {
  channelRef: Reference!
  channel: Channel
  availability: ProductSearchVariantAvailability!
}

type ProductSearchVariantAvailabilityWithChannels {
  noChannel: ProductSearchVariantAvailability
  channels(
    """
    The IDs of channels to include.

    If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
    """
    includeChannelIds: [String!],

    """
    The IDs of channels to exclude.

    If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
    """
    excludeChannelIds: [String!], limit: Int, offset: Int): ProductSearchVariantAvailabilitiesResult!
}

type ProductSelection implements Versioned {
  key: String
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  productRefs(where: String, sort: [String!], limit: Int, offset: Int): ProductOfSelectionQueryResult!
  productCount: Int!
  custom: CustomFieldsType
  mode: ProductSelectionMode!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type ProductSelectionCreated implements MessagePayload {
  productSelection: ProductSelection!
  type: String!
}

type ProductSelectionDeleted implements MessagePayload {
  type: String!
}

enum ProductSelectionMode {
  "Mode of Product Selection used to include a specific list of individual Products"
  Individual

  "Mode of Product Selection used to exclude a specific list of individual Products"
  IndividualExclusion
}

type ProductSelectionProductAdded implements MessagePayload {
  variantSelection: ProductVariantSelection
  product: Product
  productRef: Reference!
  type: String!
}

type ProductSelectionProductExcluded implements MessagePayload {
  variantExclusion: ProductVariantExclusion
  product: Product
  productRef: Reference!
  type: String!
}

type ProductSelectionProductRemoved implements MessagePayload {
  product: Product
  productRef: Reference!
  type: String!
}

"Fields to access product selection assignments."
interface ProductSelectionQueryInterface {
  productSelectionAssignments(where: String, sort: [String!], limit: Int, offset: Int): ProductAssignmentQueryResult!
}

type ProductSelectionQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [ProductSelection!]!
}

type ProductSelectionSetting {
  productSelectionRef: Reference!
  productSelection: ProductSelection
  active: Boolean!
}

input ProductSelectionSettingDraft {
  productSelection: ResourceIdentifierInput!
  active: Boolean!
}

input ProductSelectionSettingInActionInput {
  productSelection: ResourceIdentifierInput!
  active: Boolean
}

input ProductSelectionUpdateAction {
  addProduct: AddProductSelectionProduct
  changeName: ChangeProductSelectionName
  excludeProduct: ExcludeProductSelectionProduct
  removeProduct: RemoveProductSelectionProduct
  setCustomField: SetProductSelectionCustomField
  setCustomType: SetProductSelectionCustomType
  setKey: SetProductSelectionKey
  setVariantExclusion: SetProductSelectionVariantExclusion
  setVariantSelection: SetProductSelectionVariantSelection
}

type ProductSelectionVariantExclusionChanged implements MessagePayload {
  oldVariantExclusion: ProductVariantExclusion
  newVariantExclusion: ProductVariantExclusion
  product: Product
  productRef: Reference!
  type: String!
}

type ProductSelectionVariantSelectionChanged implements MessagePayload {
  oldVariantSelection: ProductVariantSelection
  newVariantSelection: ProductVariantSelection
  product: Product
  productRef: Reference!
  type: String!
}

type ProductSlugChanged implements MessagePayload {
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  oldSlug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  oldSlugAllLocales: [LocalizedString!]
  type: String!
}

type ProductStateTransition implements MessagePayload {
  force: Boolean!
  state: State
  stateRef: Reference!
  type: String!
}

type ProductTailoring implements Versioned {
  key: String
  productRef: Reference!
  product: Product
  storeRef: KeyReference!
  store: Store
  current: ProductTailoringData
  staged: ProductTailoringData
  published: Boolean!
  hasStagedChanges: Boolean!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type ProductTailoringCreated implements MessagePayload & HasProductTailoringData {
  type: String!
  storeRef: KeyReference!
  productRef: Reference!
  key: String
  productKey: String
  publish: Boolean!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]
  metaTitle(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaDescription(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]
  metaKeywords(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  variants: [ProductVariantTailoring!]!
}

type ProductTailoringData implements HasProductTailoringData {
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]
  metaTitle(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaDescription(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]
  metaKeywords(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  variants: [ProductVariantTailoring!]!
}

type ProductTailoringDeleted implements MessagePayload {
  storeRef: KeyReference!
  productRef: Reference!
  productKey: String
  type: String!
}

type ProductTailoringDescriptionSet implements MessagePayload {
  storeRef: KeyReference!
  productRef: Reference!
  productKey: String
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  oldDescription(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  oldDescriptionAllLocales: [LocalizedString!]
  type: String!
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
type ProductTailoringImageAdded implements MessagePayload {
  variantId: Int!
  storeRef: KeyReference!
  productRef: Reference!
  productKey: String
  image: Image!
  type: String!
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
type ProductTailoringImagesSet implements MessagePayload {
  variantId: Int!
  storeRef: KeyReference!
  productRef: Reference!
  productKey: String
  oldImages: [Image!]!
  images: [Image!]!
  type: String!
}

input ProductTailoringDraft {
  product: ResourceIdentifierInput!
  name: [LocalizedStringItemInputType!]
  key: String
  description: [LocalizedStringItemInputType!]
  slug: [LocalizedStringItemInputType!]
  metaTitle: [LocalizedStringItemInputType!]
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  publish: Boolean

 "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  variants: [ProductVariantTailoringInput!] = []
}

type ProductTailoringNameSet implements MessagePayload {
  storeRef: KeyReference!
  productRef: Reference!
  productKey: String
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  oldName(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  oldNameAllLocales: [LocalizedString!]
  type: String!
}

type ProductTailoringPublished implements MessagePayload {
  storeRef: KeyReference!
  productRef: Reference!
  productKey: String
  type: String!
}

type ProductTailoringQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [ProductTailoring!]!
}

type ProductTailoringSlugSet implements MessagePayload {
  storeRef: KeyReference!
  productRef: Reference!
  productKey: String
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  oldSlug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]
  oldSlugAllLocales: [LocalizedString!]
  type: String!
}

type ProductTailoringUnpublished implements MessagePayload {
  storeRef: KeyReference!
  productRef: Reference!
  productKey: String
  type: String!
}

input ProductTailoringUpdateAction {
  moveImageToPosition: MoveProductTailoringImageToPosition
  addVariant: AddProductVariantTailoring
  removeVariant: RemoveProductVariantTailoring
  publish: PublishTailoring
  unpublish: UnpublishTailoring
  addAsset: AddProductTailoringAsset
  addExternalImage: AddProductTailoringExternalImage
  changeAssetName: ChangeProductTailoringAssetName
  changeAssetOrder: ChangeProductTailoringAssetOrder
  removeAsset: RemoveProductTailoringAsset
  removeImage: RemoveProductTailoringImage
  setAssetCustomField: SetProductTailoringAssetCustomField
  setAssetCustomType: SetProductTailoringAssetCustomType
  setAssetDescription: SetProductTailoringAssetDescription
  setAssetKey: SetProductTailoringAssetKey
  setAssetSources: SetProductTailoringAssetSources
  setAssetTags: SetProductTailoringAssetTags
  setImages: SetProductTailoringImages
  setDescription: SetProductTailoringDescription
  setImageLabel: SetProductTailoringImageLabel
  setMetaAttributes: SetProductTailoringMetaAttributes
  setMetaDescription: SetProductTailoringMetaDescription
  setMetaKeywords: SetProductTailoringMetaKeywords
  setMetaTitle: SetProductTailoringMetaTitle
  setName: SetProductTailoringName
  setSlug: SetProductTailoringSlug
}

type ProductTypeDefinition implements Versioned & ReferenceExpandable {
  key: String
  name: String!
  description: String!
  attributeDefinitions(
    """
    The names of the attribute definitions to include.

    If neither `includeNames` nor `excludeNames` are provided, then all attribute definitions are returned.
    """
    includeNames: [String!],

    """
    The names of the attribute definitions to exclude.

    If neither `includeNames` nor `excludeNames` are provided, then all attribute definitions are returned.
    """
    excludeNames: [String!], limit: Int, offset: Int, sort: [String!]): AttributeDefinitionResult!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type ProductTypeDefinitionQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [ProductTypeDefinition!]!
}

input ProductTypeDraft {
  name: String!
  description: String!
  key: String
  attributeDefinitions: [AttributeDefinitionDraft!]
}

type ProductTypeLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type ProductTypeLimitsProjection {
  total: ProductTypeLimitWithCurrent!
}

input ProductTypeUpdateAction {
  setKey: setKey
  changeName: changeName
  changeDescription: changeDescription
  removeAttributeDefinition: removeAttributeDefinition
  changeLabel: changeLabel
  setInputTip: setInputTip
  changeIsSearchable: changeIsSearchable
  changeInputHint: changeInputHint
  addAttributeDefinition: addAttributeDefinition
  changeAttributeOrder: changeAttributeOrder
  changeAttributeOrderByName: changeAttributeOrderByName
  removeEnumValues: removeEnumValues
  addPlainEnumValue: addPlainEnumValue
  changePlainEnumValueLabel: changePlainEnumValueLabel
  changePlainEnumValueOrder: changePlainEnumValueOrder
  addLocalizedEnumValue: addLocalizedEnumValue
  changeLocalizedEnumValueLabel: changeLocalizedEnumValueLabel
  changeLocalizedEnumValueOrder: changeLocalizedEnumValueOrder
  changeAttributeName: changeAttributeName
  changeEnumKey: changeEnumKey
}

type ProductUnpublished implements MessagePayload {
  type: String!
}

input ProductUpdateAction {
  moveImageToPosition: MoveProductImageToPosition
  setSearchKeywords: SetSearchKeywords
  revertStagedChanges: RevertStagedChanges
  revertStagedVariantChanges: RevertStagedVariantChanges
  publish: PublishProduct
  unpublish: UnpublishProduct
  transitionState: TransitionProductState
  removePrice: RemoveProductPrice
  addAsset: AddProductAsset
  addExternalImage: AddProductExternalImage
  addPrice: AddProductPrice
  addToCategory: AddProductToCategory
  addVariant: AddProductVariant
  changeAssetName: ChangeProductAssetName
  changeAssetOrder: ChangeProductAssetOrder
  changeMasterVariant: ChangeProductMasterVariant
  changeImageLabel: ChangeProductImageLabel
  changeName: ChangeProductName
  changePrice: ChangeProductPrice
  changeSlug: ChangeProductSlug
  removeAsset: RemoveProductAsset
  removeFromCategory: RemoveProductFromCategory
  removeImage: RemoveProductImage
  removeVariant: RemoveProductVariant
  setAssetCustomField: SetProductAssetCustomField
  setAssetCustomType: SetProductAssetCustomType
  setAssetDescription: SetProductAssetDescription
  setAssetKey: SetProductAssetKey
  setAssetSources: SetProductAssetSources
  setAssetTags: SetProductAssetTags
  setCategoryOrderHint: SetProductCategoryOrderHint
  setDiscountedPrice: SetProductDiscountedPrice
  setAttribute: SetProductAttribute
  setAttributeInAllVariants: SetProductAttributeInAllVariants
  setDescription: SetProductDescription
  setImageLabel: SetProductImageLabel
  setKey: SetProductKey
  setMetaAttributes: SetProductMetaAttributes
  setMetaDescription: SetProductMetaDescription
  setMetaKeywords: SetProductMetaKeywords
  setMetaTitle: SetProductMetaTitle
  setProductPriceCustomField: SetProductPriceCustomField
  setProductPriceCustomType: SetProductPriceCustomType
  setPriceKey: SetProductPriceKey
  setPriceMode: SetProductPriceMode
  setPrices: SetProductPrices
  setSku: SetProductSku
  setTaxCategory: SetProductTaxCategory
  setProductVariantKey: SetProductVariantKey
}

type ProductVariant {
  id: Int!
  key: String
  sku: String
  prices: [ProductPrice!]

  "Returns a single price based on the price selection rules."
  price(currency: Currency!, country: Country, customerGroupId: String, channelId: String, date: DateTime): ProductPrice
  images: [Image!]!
  assets: [Asset!]!
  availability: ProductVariantAvailabilityWithChannels

  "This field contains raw attributes data"
  attributesRaw(
    """
    The names of the attributes to include.

    If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
    """
    includeNames: [String!],

    """
    The names of the attributes to exclude.

    If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
    """
    excludeNames: [String!]): [RawProductAttribute!]!
}

type ProductVariantAdded implements MessagePayload {
  variant: ProductVariant!
  staged: Boolean!
  type: String!
}

"Product variant availabilities"
type ProductVariantAvailabilitiesResult {
  limit: Int
  offset: Int
  total: Int!
  results: [ProductVariantAvailabilityWithChannel!]!
}

"Product variant availability"
type ProductVariantAvailability {
  isOnStock: Boolean!
  restockableInDays: Int
  availableQuantity: Long
  version: Long
  id: String
}

type ProductVariantAvailabilityWithChannel {
  channelRef: Reference!
  channel: Channel
  availability: ProductVariantAvailability!
}

type ProductVariantAvailabilityWithChannels {
  noChannel: ProductVariantAvailability
  channels(
    """
    The IDs of channels to include.

    If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
    """
    includeChannelIds: [String!],

    """
    The IDs of channels to exclude.

    If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
    """
    excludeChannelIds: [String!], limit: Int, offset: Int): ProductVariantAvailabilitiesResult!
}

type ProductVariantDeleted implements MessagePayload {
  removedImageUrls: Set!
  variant: ProductVariant
  type: String!
}

type ProductVariantExclusion {
  skus: [String!]!
}

input ProductVariantExclusionDraft {
  skus: [String!]
}

input ProductVariantImportDraft {
  id: Int
  sku: String
  prices: [ProductPriceDataInput!] = []
  images: [ImageInput!] = []
  attributes: [ProductAttributeInput!] = []
}

input ProductVariantInput {
  sku: String
  key: String
  prices: [ProductPriceDataInput!] = []
  images: [ImageInput!] = []
  attributes: [ProductAttributeInput!] = []
  assets: [AssetDraftInput!] = []
}

interface ProductVariantSelection {
  type: String!
  skus: [String!]!
}

input ProductVariantSelectionDraft {
  includeOnly: [String!]
  includeAllExcept: [String!]
}

type ProductVariantSelectionIncludeAllExcept implements ProductVariantSelection {
  type: String!
  skus: [String!]!
}

type ProductVariantSelectionIncludeOnly implements ProductVariantSelection {
  type: String!
  skus: [String!]!
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
type ProductVariantTailoring {
  id: Int!
  images: [Image!]!
  assets: [Asset!]!
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
type ProductVariantTailoringAdded implements MessagePayload {
  variantId: Int!
  variant: VariantTailoring!
  storeRef: KeyReference!
  productRef: Reference!
  productKey: String
  type: String!
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input ProductVariantTailoringInput {
  id: Int
  sku: String
  images: [ImageInput!]! = []
  assets: [AssetDraftInput!] = []
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
type ProductVariantTailoringRemoved implements MessagePayload {
  variantId: Int!
  variant: VariantTailoring!
  storeRef: KeyReference!
  productRef: Reference!
  productKey: String
  type: String!
}

"Contains information about the limits of your project."
type ProjectCustomLimitsProjection {
  query: QueryLimitsProjection!
  products: ProductLimitsProjection!
  shoppingLists: ShoppingListLimitsProjection!
  extensions: ExtensionLimitsProjection!
  subscriptions: SubscriptionsLimitsProjection!
  productDiscounts: ProductDiscountLimitsProjection!
  cartDiscounts: CartDiscountLimitsProjection!
  orderEdits: OrderEditLimitsProjection!
  stores: StoreLimitsProjection!
  customers: CustomerLimitsProjection!
  customerGroups: CustomerGroupLimitsProjection!
  zones: ZoneLimitsProjection!
  taxCategories: TaxCategoryLimitsProjection!
  refreshTokens: RefreshTokenLimitsProjection!
  shippingMethods: ShippingMethodLimitsProjection!
  carts: CartLimitsProjection!
  customObjects: CustomObjectLimitsProjection!
  search: SearchLimitsProjection!
  category: CategoryLimitsProjection!
  productType: ProductTypeLimitsProjection!
}

"Project contains information about project."
type ProjectProjection {
  key: String!
  name: String!
  languages: [Locale!]!
  createdAt: DateTime!
  trialUntil: YearMonth
  carts: CartsConfiguration!
  shoppingLists: ShoppingListsConfiguration!
  version: Long!
  externalOAuth: ExternalOAuth
  searchIndexing: SearchIndexingConfiguration
  messages: MessagesConfiguration!
  countries: [Country!]!
  currencies: [Currency!]!
  shippingRateInputType: ShippingRateInputType
}

input ProjectSettingsUpdateAction {
  changeCartsConfiguration: ChangeProjectSettingsCartsConfiguration
  changeCountries: ChangeProjectSettingsCountries
  changeCountryTaxRateFallbackEnabled: ChangeProjectSettingsCountryTaxRateFallbackEnabled
  changeCurrencies: ChangeProjectSettingsCurrencies
  changeLanguages: ChangeProjectSettingsLanguages
  changeMessagesConfiguration: ChangeProjectSettingsMessagesConfiguration
  changeMessagesEnabled: ChangeProjectSettingsMessagesEnabled
  changeMyBusinessUnitStatusOnCreation: ChangeProjectSettingsMyBusinessUnitStatusOnCreation
  changeName: ChangeProjectSettingsName
  changeOrderSearchStatus: ChangeProjectSettingsOrderSearchStatus
  changeShoppingListsConfiguration: ChangeProjectSettingsShoppingListsConfiguration
  setExternalOAuth: SetProjectSettingsExternalOAuth
  setShippingRateInputType: SetProjectSettingsShippingRateInputType

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  setMyBusinessUnitAssociateRoleOnCreation: SetProjectSettingsMyBusinessUnitAssociateRoleOnCreation
  changeProductSearchIndexingEnabled: ChangeProjectSettingsProductSearchIndexingEnabled
}

input PublishProduct {
  scope: PublishScope
}

enum PublishScope {
  "Publishes the complete staged projection"
  All

  "Publishes only prices on the staged projection"
  Prices
}

input PublishTailoring {
  dummy: String
}

type PurchaseOrderNumberSet implements MessagePayload & OrderMessagePayload {
  purchaseOrderNumber: String
  oldPurchaseOrderNumber: String
  type: String!
}

type Query implements CartQueryInterface & CustomerActiveCartInterface & OrderQueryInterface & CustomerQueryInterface & ShoppingListQueryInterface & ShippingMethodsByCartInterface & MeFieldInterface & ProductSelectionQueryInterface {
  """
  This field can only be used with an access token created with the password flow or with an anonymous session.

  It gives access to the data that is specific to the customer or the anonymous session linked to the access token.
  """
  me: Me!

  "This field gives access to the resources (such as carts) that are inside the given store."
  inStore(key: KeyReferenceInput!): InStore!

  "This field gives access to the resources (such as carts) that are inside one of the given stores."
  inStores(keys: [KeyReferenceInput!]!): InStore!

  "This field gives access to the resources (such as carts) as an associate of a given business unit."
  asAssociate(businessUnitKey: KeyReferenceInput!, associateId: String!): AsAssociate!
  customerGroup(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CustomerGroup
  customerGroups(where: String, sort: [String!], limit: Int, offset: Int): CustomerGroupQueryResult!
  category(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Category
  categories(where: String, sort: [String!], limit: Int, offset: Int): CategoryQueryResult!
  channel(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Channel
  channels(where: String, sort: [String!], limit: Int, offset: Int): ChannelQueryResult!
  customObject(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String, container: String): CustomObject
  customObjects(where: String, sort: [String!], limit: Int, offset: Int, container: String!): CustomObjectQueryResult!
  productType(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ProductTypeDefinition
  productTypes(where: String, sort: [String!], limit: Int, offset: Int): ProductTypeDefinitionQueryResult!
  typeDefinition(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): TypeDefinition
  typeDefinitions(where: String, sort: [String!], limit: Int, offset: Int): TypeDefinitionQueryResult!
  shippingMethod(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShippingMethod
  shippingMethods(where: String, sort: [String!], limit: Int, offset: Int): ShippingMethodQueryResult!
  shippingMethodsByCart(id: String!): [ShippingMethod!]!
  shippingMethodsByLocation(country: Country!, state: String, currency: Currency): [ShippingMethod!]!
  zone(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Zone
  zones(where: String, sort: [String!], limit: Int, offset: Int): ZoneQueryResult!
  taxCategory(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): TaxCategory
  taxCategories(where: String, sort: [String!], limit: Int, offset: Int): TaxCategoryQueryResult!
  cartDiscount(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CartDiscount
  cartDiscounts(where: String, sort: [String!], limit: Int, offset: Int): CartDiscountQueryResult!
  discountCode(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): DiscountCode
  discountCodes(where: String, sort: [String!], limit: Int, offset: Int): DiscountCodeQueryResult!
  productDiscount(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ProductDiscount
  productDiscounts(where: String, sort: [String!], limit: Int, offset: Int): ProductDiscountQueryResult!
  attributeGroup(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): AttributeGroup
  attributeGroups(where: String, sort: [String!], limit: Int, offset: Int): AttributeGroupQueryResult!
  product(projectExpandedProducts: Boolean = false, localeProjection: [Locale!],

    "Queries for a product with specified SKU"
    sku: String,

    "Queries for a [Product](https://docs.commercetools.com/api/projects/products#product) with specified [ProductVariant](https://docs.commercetools.com/api/projects/products#productvariant) `key`"
    variantKey: String,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Product
  products(where: String, sort: [String!], limit: Int, offset: Int, projectExpandedProducts: Boolean = false, localeProjection: [Locale!],

    "Queries for products with specified SKUs"
    skus: [String!]): ProductQueryResult!
  state(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): State
  states(where: String, sort: [String!], limit: Int, offset: Int): StateQueryResult!
  customer(
    "Queries a customer with specified email token"
    emailToken: String,

    "Queries a customer with specified password token"
    passwordToken: String,

    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Customer
  customers(where: String, sort: [String!], limit: Int, offset: Int): CustomerQueryResult!
  inventoryEntry(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): InventoryEntry
  inventoryEntries(where: String, sort: [String!], limit: Int, offset: Int): InventoryEntryQueryResult!
  cart(id: String!): Cart
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  customerActiveCart(customerId: String!): Cart
  message(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Message
  messages(where: String, sort: [String!], limit: Int, offset: Int): MessageQueryResult!
  order(
    "Queries with specified ID"
    id: String, orderNumber: String): Order
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
  orderEdit(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): OrderEdit
  orderEdits(where: String, sort: [String!], limit: Int, offset: Int): OrderEditQueryResult!
  shoppingList(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShoppingList
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
  payment(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Payment
  payments(where: String, sort: [String!], limit: Int, offset: Int): PaymentQueryResult!
  productSelection(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ProductSelection
  productSelections(where: String, sort: [String!], limit: Int, offset: Int): ProductSelectionQueryResult!
  productTailoring(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String,

    "Queries with specified Product ID"
    productId: String,

    "Queries with specified Product key"
    productKey: String,

    "The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions."
    storeKey: KeyReferenceInput): ProductTailoring
  productTailoringList(where: String, sort: [String!], limit: Int, offset: Int): ProductTailoringQueryResult!
  productProjectionsSuggest(searchKeywords: [SearchKeywordArgument!]!, fuzzy: Boolean, limit: Int = 10, staged: Boolean = false): SuggestResult!
  project: ProjectProjection!
  store(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Store
  stores(where: String, sort: [String!], limit: Int, offset: Int): StoreQueryResult!
  review(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Review
  reviews(where: String, sort: [String!], limit: Int, offset: Int): ReviewQueryResult!
  subscription(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): CommercetoolsSubscription
  subscriptions(where: String, sort: [String!], limit: Int, offset: Int): CommercetoolsSubscriptionQueryResult!
  extension(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Extension
  extensions(where: String, sort: [String!], limit: Int, offset: Int): ExtensionQueryResult!
  apiClient(id: String!): APIClientWithoutSecret
  apiClients(where: String, sort: [String!], limit: Int, offset: Int): APIClientWithoutSecretQueryResult!
  limits: ProjectCustomLimitsProjection!
  productProjectionSearch(projectExpandedProducts: Boolean = false, locale: Locale, text: String, facets: [SearchFacetInput!] = [], filters: [SearchFilterInput!] = [], queryFilters: [SearchFilterInput!] = [], facetFilters: [SearchFilterInput!] = [], sorts: [String!] = [], limit: Int = 10, offset: Int = 0, fuzzy: Boolean = false, fuzzyLevel: Int, priceSelector: PriceSelectorInput, markMatchingVariants: Boolean = false,

    "Deprecated: please use 'markMatchingVariants'."
    markMatchingVariant: Boolean = false, storeProjection: String, localeProjection: [Locale!], staged: Boolean = false): ProductProjectionSearchResult!

  """
  StandalonePrices are managed and queried through the StandalonePrices API
  and associated to a ProductVariant through the sku field.
  """
  standalonePrice(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): StandalonePrice

  """
  StandalonePrices are managed and queried through the StandalonePrices API
  and associated to a ProductVariant through the sku field.
  """
  standalonePrices(where: String, sort: [String!], limit: Int, offset: Int): StandalonePriceQueryResult!
  quoteRequest(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): QuoteRequest
  quoteRequests(where: String, sort: [String!], limit: Int, offset: Int): QuoteRequestQueryResult!
  stagedQuote(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): StagedQuote
  stagedQuotes(where: String, sort: [String!], limit: Int, offset: Int): StagedQuoteQueryResult!
  quote(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Quote
  quotes(where: String, sort: [String!], limit: Int, offset: Int): QuoteQueryResult!
  businessUnit(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): BusinessUnit
  businessUnits(where: String, sort: [String!], limit: Int, offset: Int): BusinessUnitQueryResult!
  associateRole(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): AssociateRole
  associateRoles(where: String, sort: [String!], limit: Int, offset: Int): AssociateRoleQueryResult!
  productSelectionAssignments(where: String, sort: [String!], limit: Int, offset: Int): ProductAssignmentQueryResult!
}

type QueryLimitsProjection {
  offset: Limit!
}

type Quote implements Versioned {
  customerRef: Reference
  customer: Customer
  customerGroupRef: Reference
  customerGroup: CustomerGroup
  lineItems(
    "Queries with specified ID"
    id: String): [LineItem!]!
  customLineItems: [CustomLineItem!]!
  totalPrice: Money!
  taxedPrice: TaxedPrice
  shippingAddress: Address
  billingAddress: Address
  itemShippingAddresses: [Address!]!
  inventoryMode: InventoryMode!
  taxMode: TaxMode!
  taxRoundingMode: RoundingMode!
  taxCalculationMode: TaxCalculationMode!
  country: Country
  shippingInfo: ShippingInfo
  paymentInfo: PaymentInfo

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  directDiscounts: [DirectDiscount!]!
  shippingRateInput: ShippingRateInput
  storeRef: KeyReference
  store: Store
  businessUnit: BusinessUnit
  businessUnitRef: KeyReference
  key: String
  quoteState: QuoteState!
  stagedQuoteRef: Reference!
  stagedQuote: StagedQuote
  quoteRequestRef: Reference!
  quoteRequest: QuoteRequest
  validTo: DateTime
  sellerComment: String
  buyerComment: String
  custom: CustomFieldsType
  stateRef: Reference
  state: State
  purchaseOrderNumber: String
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type QuoteCreated implements MessagePayload {
  quote: Quote!
  type: String!
}

type QuoteCustomerChanged implements MessagePayload {
  customerRef: Reference!
  previousCustomerRef: Reference!
  customer: Customer
  previousCustomer: Customer
  type: String!
}

type QuoteDeleted implements MessagePayload {
  type: String!
}

input QuoteDraft {
  key: String
  stagedQuote: ResourceIdentifierInput
  stagedQuoteVersion: Long
  stagedQuoteStateToSent: Boolean = false
  custom: CustomFieldsDraft
  state: ReferenceInput
}

"Fields to access Quotes."
interface QuoteQueryInterface {
  quote(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): Quote
  quotes(where: String, sort: [String!], limit: Int, offset: Int): QuoteQueryResult!
}

type QuoteQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Quote!]!
}

type QuoteRenegotiationRequested implements MessagePayload {
  buyerComment: String
  type: String!
}

type QuoteRequest implements Versioned {
  customerRef: Reference
  customer: Customer
  customerGroupRef: Reference
  customerGroup: CustomerGroup
  lineItems(
    "Queries with specified ID"
    id: String): [LineItem!]!
  customLineItems: [CustomLineItem!]!
  totalPrice: Money!
  taxedPrice: TaxedPrice
  shippingAddress: Address
  billingAddress: Address
  itemShippingAddresses: [Address!]!
  inventoryMode: InventoryMode!
  taxMode: TaxMode!
  taxRoundingMode: RoundingMode!
  taxCalculationMode: TaxCalculationMode!
  country: Country
  shippingInfo: ShippingInfo
  paymentInfo: PaymentInfo

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  directDiscounts: [DirectDiscount!]!
  shippingRateInput: ShippingRateInput
  storeRef: KeyReference
  store: Store
  businessUnit: BusinessUnit
  businessUnitRef: KeyReference
  key: String
  quoteRequestState: QuoteRequestState!
  comment: String
  custom: CustomFieldsType
  stateRef: Reference
  state: State
  purchaseOrderNumber: String
  cartRef: Reference
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type QuoteRequestCreated implements MessagePayload {
  quoteRequest: QuoteRequest!
  type: String!
}

type QuoteRequestCustomerChanged implements MessagePayload {
  customerRef: Reference!
  previousCustomerRef: Reference!
  customer: Customer
  previousCustomer: Customer
  type: String!
}

type QuoteRequestDeleted implements MessagePayload {
  type: String!
}

input QuoteRequestDraft {
  key: String
  cart: ResourceIdentifierInput
  comment: String
  cartVersion: Long
  custom: CustomFieldsDraft
  state: ReferenceInput
  purchaseOrderNumber: String
}

"Fields to access QuoteRequests."
interface QuoteRequestQueryInterface {
  quoteRequest(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): QuoteRequest
  quoteRequests(where: String, sort: [String!], limit: Int, offset: Int): QuoteRequestQueryResult!
}

type QuoteRequestQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [QuoteRequest!]!
}

enum QuoteRequestState {
  Accepted
  Cancelled
  Closed
  Rejected
  Submitted
  UnderReview
}

type QuoteRequestStateChanged implements MessagePayload {
  quoteRequestState: QuoteRequestState!
  oldQuoteRequestState: QuoteRequestState!
  type: String!
}

type QuoteRequestStateTransition implements MessagePayload {
  stateRef: Reference!
  oldStateRef: Reference
  force: Boolean!
  state: State
  oldState: State
  type: String!
}

input QuoteRequestUpdateAction {
  changeCustomer: ChangeQuoteRequestCustomer
  changeQuoteRequestState: ChangeQuoteRequestState
  setCustomField: SetQuoteRequestCustomField
  setCustomType: SetQuoteRequestCustomType
  transitionState: TransitionQuoteRequestState
}

enum QuoteState {
  Accepted
  Declined
  DeclinedForRenegotiation
  Pending
  RenegotiationAddressed
  Withdrawn
}

type QuoteStateChanged implements MessagePayload {
  quoteState: QuoteState!
  oldQuoteState: QuoteState!
  type: String!
}

type QuoteStateTransition implements MessagePayload {
  stateRef: Reference!
  oldStateRef: Reference
  force: Boolean!
  state: State
  oldState: State
  type: String!
}

input QuoteUpdateAction {
  changeCustomer: ChangeQuoteCustomer
  changeQuoteState: ChangeQuoteState
  requestQuoteRenegotiation: RequestQuoteRenegotiation
  setCustomField: SetQuoteCustomField
  setCustomType: SetQuoteCustomType
  transitionState: TransitionQuoteState
}

interface RangeCount {
  type: String!
}

type RangeCountDouble implements RangeCount {
  from: Float!
  fromStr: String!
  to: Float!
  toStr: String!
  count: Int!
  productCount: Int
  totalCount: Int!
  total: Float!
  min: Float!
  max: Float!
  mean: Float!
  type: String!
}

type RangeCountLong implements RangeCount {
  from: Long!
  fromStr: String!
  to: Long!
  toStr: String!
  count: Int!
  productCount: Int
  totalCount: Int!
  total: Long!
  min: Long!
  max: Long!
  mean: Float!
  type: String!
}

input RangeElementInput {
  from: String!
  to: String!
}

input RangeFacetInput {
  path: String!
  ranges: [RangeElementInput!]!
  alias: String
  countProducts: Boolean! = false
}

type RangeFacetResult implements FacetResult {
  dataType: String!
  ranges: [RangeCount!]!
  type: String!
}

input RangeFilterInput {
  path: String!
  ranges: [RangeElementInput!]!
}

type RawCustomField {
  name: String!
  value: Json!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  referencedResource: ReferenceExpandable

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  referencedResourceSet: [ReferenceExpandable!]!
}

type RawProductAttribute {
  name: String!
  value: Json!
  attributeDefinition: AttributeDefinition

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  referencedResource: ReferenceExpandable

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  referencedResourceSet: [ReferenceExpandable!]!
}

type RawProductSearchAttribute {
  name: String!
  value: Json!

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  referencedResource: ReferenceExpandable

  "BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
  referencedResourceSet: [ReferenceExpandable!]!
}

input RecalculateCart {
  updateProductData: Boolean = false
}

type Reference {
  typeId: String!
  id: String!
}

type ReferenceAttribute implements Attribute {
  typeId: String!
  id: String!
  name: String!
}

type ReferenceAttributeDefinitionType implements AttributeDefinitionType {
  referenceTypeId: String!
  name: String!
}

interface ReferenceExpandable {
  id: String!
}

type ReferenceField implements CustomField {
  typeId: String!
  id: String!
  name: String!
}

type ReferenceId {
  typeId: String!
  id: String!
}

input ReferenceInput {
  typeId: String!
  id: String!
}

type ReferenceType implements FieldType {
  referenceTypeId: String!
  name: String!
}

input ReferenceTypeDefinitionDraft {
  referenceTypeId: String!
}

type RefreshTokenLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type RefreshTokenLimitsProjection {
  total: RefreshTokenLimitWithCurrent!
}

input RejectApprovalFlow {
  reason: String
}

type RelativeDiscountValue implements CartDiscountValue & ProductDiscountValue {
  permyriad: Int!
  type: String!
}

input RelativeDiscountValueInput {
  permyriad: Int!
}

input RemoveAssociateRolePermission {
  permission: Permission!
}

input RemoveAttributeGroupAttribute {
  attribute: AttributeReferenceInput!
}

input RemoveBusinessUnitAddress {
  addressId: String
  addressKey: String
}

input RemoveBusinessUnitAssociate {
  customer: ResourceIdentifierInput!
}

input RemoveBusinessUnitBillingAddressId {
  addressId: String
  addressKey: String
}

input RemoveBusinessUnitShippingAddressId {
  addressId: String
  addressKey: String
}

input RemoveBusinessUnitStore {
  store: ResourceIdentifierInput!
}

input RemoveCartCustomLineItem {
  customLineItemId: String
  customLineItemKey: String
}

input RemoveCartDiscountCode {
  discountCode: ReferenceInput!
}

input RemoveCartDiscountStore {
  store: ResourceIdentifierInput!
}

input RemoveCartItemShippingAddress {
  addressKey: String!
}

input RemoveCartLineItem {
  lineItemId: String
  quantity: Long
  lineItemKey: String
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  shippingDetailsToRemove: ItemShippingDetailsDraft
}

input RemoveCartPayment {
  payment: ResourceIdentifierInput!
}

input RemoveCartShippingMethod {
  shippingKey: String!
}

input RemoveCategoryAsset {
  assetKey: String
  assetId: String
}

input RemoveChannelRoles {
  roles: [ChannelRole!]!
}

input RemoveCustomerAddress {
  addressId: String
  addressKey: String
}

input RemoveCustomerBillingAddressId {
  addressId: String
  addressKey: String
}

input RemoveCustomerShippingAddressId {
  addressId: String
  addressKey: String
}

input RemoveCustomerStore {
  store: ResourceIdentifierInput!
}

input RemoveInventoryEntryQuantity {
  quantity: Long!
}

input RemoveMyBusinessUnitAddress {
  addressId: String
  addressKey: String
}

input RemoveMyBusinessUnitAssociate {
  customer: ResourceIdentifierInput!
}

input RemoveMyBusinessUnitBillingAddressId {
  addressId: String
  addressKey: String
}

input RemoveMyBusinessUnitShippingAddressId {
  addressId: String
  addressKey: String
}

input RemoveOrderDelivery {
  deliveryId: String
  deliveryKey: String
}

input RemoveOrderItemShippingAddress {
  addressKey: String!
}

input RemoveOrderParcelFromDelivery {
  parcelId: String
  parcelKey: String
}

input RemoveOrderPayment {
  payment: ResourceIdentifierInput!
}

input RemoveProductAsset {
  variantId: Int
  sku: String
  staged: Boolean = true
  assetKey: String
  assetId: String
}

input RemoveProductFromCategory {
  category: ResourceIdentifierInput!
  staged: Boolean = true
}

input RemoveProductImage {
  variantId: Int
  sku: String
  imageUrl: String!
  staged: Boolean = true
}

input RemoveProductPrice {
  priceId: String
  staged: Boolean = true
}

input RemoveProductSelectionProduct {
  product: ResourceIdentifierInput!
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input RemoveProductTailoringAsset {
  variantId: Int
  sku: String
  staged: Boolean = true
  assetKey: String
  assetId: String
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input RemoveProductTailoringImage {
  variantId: Int
  sku: String
  imageUrl: String!
  staged: Boolean = true
}

input RemoveProductVariant {
  id: Int
  sku: String
  staged: Boolean = true
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input RemoveProductVariantTailoring {
  id: Int
  sku: String
  staged: Boolean = true
}

input RemoveShippingMethodShippingRate {
  zone: ResourceIdentifierInput!
  shippingRate: ShippingRateDraft!
}

input RemoveShippingMethodZone {
  zone: ResourceIdentifierInput!
}

input RemoveShoppingListLineItem {
  lineItemId: String
  lineItemKey: String
  quantity: Int
}

input RemoveShoppingListTextLineItem {
  textLineItemId: String
  textLineItemKey: String
  quantity: Int
}

input RemoveStagedChanges {
  dummy: String
}

input RemoveStagedOrderCustomLineItem {
  customLineItemId: String
  customLineItemKey: String
}

type RemoveStagedOrderCustomLineItemOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String
  customLineItemKey: String
}

input RemoveStagedOrderDelivery {
  deliveryId: String
  deliveryKey: String
}

type RemoveStagedOrderDeliveryOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String
  deliveryKey: String
}

input RemoveStagedOrderDiscountCode {
  discountCode: ReferenceInput!
}

type RemoveStagedOrderDiscountCodeOutput implements StagedOrderUpdateActionOutput {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}

input RemoveStagedOrderItemShippingAddress {
  addressKey: String!
}

type RemoveStagedOrderItemShippingAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  addressKey: String!
}

input RemoveStagedOrderLineItem {
  lineItemId: String
  quantity: Long
  lineItemKey: String
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  shippingDetailsToRemove: ItemShippingDetailsDraftType
}

type RemoveStagedOrderLineItemOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  quantity: Long
  lineItemKey: String
  externalPrice: BaseMoney
  externalTotalPrice: ExternalLineItemTotalPrice
  shippingDetailsToRemove: ItemShippingDetailsDraftOutput
}

input RemoveStagedOrderParcelFromDelivery {
  parcelId: String
  parcelKey: String
}

type RemoveStagedOrderParcelFromDeliveryOutput implements StagedOrderUpdateActionOutput {
  type: String!
  parcelId: String
  parcelKey: String
}

input RemoveStagedOrderPayment {
  payment: ResourceIdentifierInput!
}

type RemoveStagedOrderPaymentOutput implements StagedOrderUpdateActionOutput {
  type: String!
  paymentResId: ResourceIdentifier!
}

input RemoveStandalonePriceTier {
  minimumQuantity: Int!
}

input RemoveStateRoles {
  roles: [StateRole!]!
}

input RemoveStoreCountry {
  country: StoreCountryInput!
}

input RemoveStoreDistributionChannel {
  distributionChannel: ResourceIdentifierInput!
}

input RemoveStoreProductSelection {
  productSelection: ResourceIdentifierInput!
}

input RemoveStoreSupplyChannel {
  supplyChannel: ResourceIdentifierInput!
}

input RemoveTypeFieldDefinition {
  fieldName: String!
}

input RemoveZoneLocation {
  location: ZoneLocation!
}

input RequestQuoteRenegotiation {
  buyerComment: String
}

type ResourceIdentifier {
  typeId: String!
  key: String
  id: String
}

input ResourceIdentifierInput {
  typeId: String
  id: String
  key: String
}

"Stores information about returns connected to this order."
type ReturnInfo {
  items: [ReturnItem!]!
  returnTrackingId: String
  returnDate: DateTime
}

type ReturnInfoAdded implements MessagePayload & OrderMessagePayload {
  returnInfo: ReturnInfo!
  type: String!
}

input ReturnInfoDraftType {
  items: [ReturnItemDraftType!]!
  returnDate: DateTime
  returnTrackingId: String
}

type ReturnInfoDraftTypeOutput {
  items: [ReturnItemDraftTypeOutput!]!
  returnDate: DateTime
  returnTrackingId: String
}

type ReturnInfoSet implements MessagePayload & OrderMessagePayload {
  returnInfo: [ReturnInfo!]
  type: String!
}

interface ReturnItem {
  type: String!
  id: String!
  key: String
  quantity: Long!
  comment: String
  shipmentState: ReturnShipmentState!
  paymentState: ReturnPaymentState!
  custom: CustomFieldsType
  lastModifiedAt: DateTime!
  createdAt: DateTime!
}

input ReturnItemDraftType {
  key: String
  quantity: Long!
  lineItemId: String
  customLineItemId: String
  comment: String
  shipmentState: ReturnShipmentState!
  custom: CustomFieldsDraft
}

type ReturnItemDraftTypeOutput {
  key: String
  quantity: Long!
  lineItemId: String
  customLineItemId: String
  comment: String
  shipmentState: ReturnShipmentState!
  custom: CustomFieldsCommand
}

enum ReturnPaymentState {
  Initial
  NonRefundable
  NotRefunded
  Refunded
}

enum ReturnShipmentState {
  Advised
  BackInStock
  Returned
  Unusable
}

input RevertStagedChanges {
  dummy: String
}

input RevertStagedVariantChanges {
  variantId: Int!
}

type Review implements Versioned & ReferenceExpandable {
  key: String
  uniquenessValue: String
  locale: Locale
  authorName: String
  title: String
  text: String
  targetRef: Reference
  target: ReviewTarget
  rating: Int
  stateRef: Reference
  state: State
  includedInStatistics: Boolean!
  customerRef: Reference
  customer: Customer
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type ReviewCreated implements MessagePayload {
  review: Review!
  type: String!
}

input ReviewDraft {
  key: String
  uniquenessValue: String
  locale: Locale
  authorName: String
  title: String
  text: String
  target: TargetReferenceInput
  state: ResourceIdentifierInput
  rating: Int
  customer: ResourceIdentifierInput
  custom: CustomFieldsDraft
}

type ReviewQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Review!]!
}

type ReviewRatingSet implements MessagePayload {
  oldRating: Int
  newRating: Int
  includedInStatistics: Boolean!
  target: ReviewTarget
  targetRef: Reference
  type: String!
}

type ReviewRatingStatistics {
  averageRating: Float!
  highestRating: Int!
  lowestRating: Int!
  count: Long!
  ratingsDistribution: Json!
}

type ReviewStateTransition implements MessagePayload {
  oldIncludedInStatistics: Boolean!
  newIncludedInStatistics: Boolean!
  force: Boolean!
  target: ReviewTarget
  oldState: State
  newState: State
  targetRef: Reference
  oldStateRef: Reference
  newStateRef: Reference!
  type: String!
}

interface ReviewTarget {
  id: String!
}

input ReviewUpdateAction {
  setAuthorName: SetReviewAuthorName
  setCustomField: SetReviewCustomField
  setCustomType: SetReviewCustomType
  setCustomer: SetReviewCustomer
  setKey: SetReviewKey
  setLocale: SetReviewLocale
  setRating: SetReviewRating
  setTarget: SetReviewTarget
  setText: SetReviewText
  setTitle: SetReviewTitle
  transitionState: TransitionReviewState
}

enum RoundingMode {
  "[Round half down](https://en.wikipedia.org/wiki/Rounding#Round_half_down)"
  HalfDown

  "[Round half to even](https://en.wikipedia.org/wiki/Rounding#Round_half_to_even). Default rounding mode as used in IEEE 754 computing functions and operators."
  HalfEven

  "[Round half up](https://en.wikipedia.org/wiki/Rounding#Round_half_up)"
  HalfUp
}

type RuleApprover {
  associateRole: AssociateRole!
  associateRoleRef: KeyReference!
}

input RuleApproverDraft {
  associateRole: ResourceIdentifierInput!
}

type RuleRequester {
  associateRole: AssociateRole!
  associateRoleRef: KeyReference!
}

input RuleRequesterDraft {
  associateRole: ResourceIdentifierInput!
}

type SNSDestination implements Destination {
  topicArn: String!
  accessKey: String
  accessSecret: String
  authenticationMode: AwsAuthenticationMode!
  type: String!
}

input SNSDestinationInput {
  topicArn: String!
  accessKey: String
  accessSecret: String
  authenticationMode: AwsAuthenticationMode = Credentials
}

type SQSDestination implements Destination {
  queueUrl: String!
  accessKey: String
  accessSecret: String
  region: String!
  authenticationMode: AwsAuthenticationMode!
  type: String!
}

input SQSDestinationInput {
  queueUrl: String!
  accessKey: String
  accessSecret: String
  region: String!
  authenticationMode: AwsAuthenticationMode = Credentials
}

type ScopedPrice {
  id: String!
  value: BaseMoney!
  currentValue: BaseMoney!
  country: String
  customerGroupRef: Reference
  customerGroup: CustomerGroup
  channelRef: Reference
  channel: Channel
  validFrom: DateTime
  validUntil: DateTime
  discounted: DiscountedProductSearchPriceValue
  custom: CustomFieldsType
}

type ScoreShippingRateInput implements ShippingRateInput {
  score: Int!
  type: String!
}

input ScoreShippingRateInputDraft {
  score: Int!
}

type ScoreShippingRateInputDraftOutput implements ShippingRateInputDraftOutput {
  score: Int!
  type: String!
}

input SearchFacetInput {
  model: SearchFacetModelInput
  string: String
}

input SearchFacetModelInput {
  terms: TermsFacetInput
  range: RangeFacetInput
}

input SearchFilterInput {
  model: SearchFilterModelInput
  string: String
}

input SearchFilterModelInput {
  value: ValueFilterInput
  range: RangeFilterInput
  missing: MissingFilterInput
  exists: ExistsFilterInput
  tree: TreeFilterInput
}

type SearchIndexingConfiguration {
  products: SearchIndexingConfigurationValues
  orders: OrderSearchConfiguration
}

type SearchIndexingConfigurationValues {
  status: SearchIndexingStatus
  lastModifiedAt: DateTime
  lastModifiedBy: Initiator
}

enum SearchIndexingStatus {
  Activated
  Indexing
  Deactivated
}

type SearchKeyword {
  text: String!
  suggestTokenizer: SuggestTokenizer
}

input SearchKeywordArgument {
  searchKeyword: String!
  locale: Locale!
}

input SearchKeywordInput {
  locale: Locale!
  keywords: [SearchKeywordItemInput!]!
}

input SearchKeywordItemInput {
  text: String!
  suggestTokenizer: BaseSearchKeywordInput
}

type SearchKeywordProductSearch {
  text: String!
  suggestTokenizer: SuggestTokenizerProductSearch
}

type SearchKeywords {
  locale: Locale!
  searchKeywords: [SearchKeyword!]!
}

type SearchKeywordsProductSearch {
  locale: Locale!
  searchKeywords: [SearchKeywordProductSearch!]!
}

type SearchLimitsProjection {
  maxTextSize: Limit!
}

"In order to decide which of the matching items will actually be discounted"
enum SelectionMode {
  Cheapest
  MostExpensive
}

type SelectionOfProduct {
  productSelectionRef: Reference!
  productSelection: ProductSelection
  variantSelection: ProductVariantSelection
  variantExclusion: ProductVariantExclusion
  createdAt: DateTime!
}

type SelectionOfProductQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [SelectionOfProduct!]!
}

"A set."
scalar Set

input SetApprovalFlowCustomField {
  name: String!
  value: String
}

input SetApprovalFlowCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetApprovalRuleApprovers {
  approvers: ApproverHierarchyDraft!
}

input SetApprovalRuleDescription {
  description: String
}

input SetApprovalRuleKey {
  key: String
}

input SetApprovalRuleName {
  name: String!
}

input SetApprovalRulePredicate {
  predicate: String!
}

input SetApprovalRuleRequesters {
  requesters: [RuleRequesterDraft!]!
}

input SetApprovalRuleStatus {
  status: ApprovalRuleStatus!
}

input SetAssociateRoleCustomField {
  name: String!
  value: String
}

input SetAssociateRoleCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetAssociateRoleName {
  name: String
}

input SetAssociateRolePermissions {
  permissions: [Permission!]
}

type SetAttributeDefinitionType implements AttributeDefinitionType {
  elementType: AttributeDefinitionType!
  name: String!
}

input SetAttributeGroupAttributes {
  attributes: [AttributeReferenceInput!]!
}

input SetAttributeGroupDescription {
  description: [LocalizedStringItemInputType!]
}

input SetAttributeGroupKey {
  key: String
}

input SetBusinessUnitAddressCustomField {
  addressId: String
  addressKey: String
  name: String!
  value: String
}

input SetBusinessUnitAddressCustomType {
  addressId: String
  addressKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetBusinessUnitAssociates {
  associates: [AssociateDraft!] = []
}

input SetBusinessUnitContactEmail {
  contactEmail: String
}

input SetBusinessUnitCustomField {
  name: String!
  value: String
}

input SetBusinessUnitCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetBusinessUnitDefaultBillingAddress {
  addressId: String
  addressKey: String
}

input SetBusinessUnitDefaultShippingAddress {
  addressId: String
  addressKey: String
}

input SetBusinessUnitStoreMode {
  stores: [ResourceIdentifierInput!]
  storeMode: String
}

input SetBusinessUnitStores {
  stores: [ResourceIdentifierInput!]!
}

input SetCartAnonymousId {
  anonymousId: String
}

input SetCartBillingAddress {
  address: AddressInput
}

input SetCartBillingAddressCustomField {
  name: String!
  value: String
}

input SetCartBillingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetCartBusinessUnit {
  businessUnit: ResourceIdentifierInput!
}

input SetCartCountry {
  country: Country
}

input SetCartCustomField {
  name: String!
  value: String
}

input SetCartCustomLineItemCustomField {
  customLineItemId: String
  customLineItemKey: String
  name: String!
  value: String
}

input SetCartCustomLineItemCustomType {
  customLineItemId: String
  customLineItemKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetCartCustomLineItemShippingDetails {
  customLineItemId: String
  customLineItemKey: String
  shippingDetails: ItemShippingDetailsDraft
}

input SetCartCustomLineItemTaxAmount {
  customLineItemId: String
  customLineItemKey: String
  externalTaxAmount: ExternalTaxAmountDraft
  shippingKey: String
}

input SetCartCustomLineItemTaxRate {
  customLineItemId: String
  customLineItemKey: String
  externalTaxRate: ExternalTaxRateDraft
  shippingKey: String
}

input SetCartCustomShippingMethod {
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  taxCategory: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}

input SetCartCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetCartCustomerEmail {
  email: String
}

input SetCartCustomerGroup {
  customerGroup: ResourceIdentifierInput
}

input SetCartCustomerId {
  customerId: String
}

input SetCartDeleteDaysAfterLastModification {
  deleteDaysAfterLastModification: Int
}

input SetCartDirectDiscounts {
  discounts: [DirectDiscountDraft!]!
}

input SetCartDiscountCustomField {
  name: String!
  value: String
}

input SetCartDiscountCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetCartDiscountDescription {
  description: [LocalizedStringItemInputType!]
}

input SetCartDiscountKey {
  key: String
}

input SetCartDiscountStores {
  stores: [ResourceIdentifierInput!]
}

input SetCartDiscountValidFrom {
  validFrom: DateTime
}

input SetCartDiscountValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}

input SetCartDiscountValidUntil {
  validUntil: DateTime
}

input SetCartItemShippingAddressCustomField {
  addressKey: String!
  name: String!
  value: String
}

input SetCartItemShippingAddressCustomType {
  addressKey: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetCartKey {
  key: String
}

input SetCartLineItemCustomField {
  lineItemId: String
  name: String!
  value: String
  lineItemKey: String
}

input SetCartLineItemCustomType {
  lineItemId: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  lineItemKey: String
}

input SetCartLineItemDistributionChannel {
  lineItemId: String
  distributionChannel: ResourceIdentifierInput
  lineItemKey: String
}

input SetCartLineItemInventoryMode {
  lineItemId: String
  inventoryMode: InventoryMode
  lineItemKey: String
}

input SetCartLineItemPrice {
  lineItemId: String
  externalPrice: BaseMoneyInput
  lineItemKey: String
}

input SetCartLineItemShippingDetails {
  lineItemId: String
  shippingDetails: ItemShippingDetailsDraft
  lineItemKey: String
}

input SetCartLineItemSupplyChannel {
  lineItemId: String
  supplyChannel: ResourceIdentifierInput
  lineItemKey: String
}

input SetCartLineItemTaxAmount {
  lineItemId: String
  externalTaxAmount: ExternalTaxAmountDraft
  shippingKey: String
  lineItemKey: String
}

input SetCartLineItemTaxRate {
  lineItemId: String
  externalTaxRate: ExternalTaxRateDraft
  shippingKey: String
  lineItemKey: String
}

input SetCartLineItemTotalPrice {
  lineItemId: String
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  lineItemKey: String
}

input SetCartLocale {
  locale: Locale
}

input SetCartShippingAddress {
  address: AddressInput
}

input SetCartShippingAddressCustomField {
  name: String!
  value: String
}

input SetCartShippingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetCartShippingCustomField {
  shippingKey: String
  name: String!
  value: String
}

input SetCartShippingCustomType {
  shippingKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetCartShippingMethod {
  shippingMethod: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}

input SetCartShippingMethodTaxAmount {
  externalTaxAmount: ExternalTaxAmountDraft
  shippingKey: String
}

input SetCartShippingMethodTaxRate {
  externalTaxRate: ExternalTaxRateDraft
  shippingKey: String
}

input SetCartShippingRateInput {
  shippingRateInput: ShippingRateInputDraft
}

input SetCartTotalTax {
  externalTotalGross: MoneyInput
  externalTaxPortions: [TaxPortionDraft!] = []
}

input SetCategoryAssetCustomField {
  value: String
  name: String!
  assetKey: String
  assetId: String
}

input SetCategoryAssetCustomType {
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
  assetKey: String
  assetId: String
}

input SetCategoryAssetDescription {
  description: [LocalizedStringItemInputType!]
  assetKey: String
  assetId: String
}

input SetCategoryAssetKey {
  assetKey: String
  assetId: String!
}

input SetCategoryAssetSources {
  sources: [AssetSourceInput!] = []
  assetKey: String
  assetId: String
}

input SetCategoryAssetTags {
  tags: [String!] = []
  assetKey: String
  assetId: String
}

input SetCategoryCustomField {
  name: String!
  value: String
}

input SetCategoryCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetCategoryDescription {
  description: [LocalizedStringItemInputType!]
}

input SetCategoryExternalId {
  externalId: String
}

input SetCategoryKey {
  key: String
}

input SetCategoryMetaDescription {
  metaDescription: [LocalizedStringItemInputType!]
}

input SetCategoryMetaKeywords {
  metaKeywords: [LocalizedStringItemInputType!]
}

input SetCategoryMetaTitle {
  metaTitle: [LocalizedStringItemInputType!]
}

input SetChannelAddress {
  address: AddressInput
}

input SetChannelAddressCustomField {
  name: String!
  value: String
}

input SetChannelAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetChannelCustomField {
  name: String!
  value: String
}

input SetChannelCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetChannelGeoLocation {
  geoLocation: GeometryInput
}

input SetChannelRoles {
  roles: [ChannelRole!]!
}

input SetCustomerAddressCustomField {
  name: String!
  value: String
  addressId: String!
}

input SetCustomerAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  addressId: String!
}

input SetCustomerAuthenticationMode {
  authMode: AuthenticationMode!
  password: String
}

input SetCustomerCompanyName {
  companyName: String
}

input SetCustomerCustomField {
  name: String!
  value: String
}

input SetCustomerCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetCustomerDateOfBirth {
  dateOfBirth: Date
}

input SetCustomerDefaultBillingAddress {
  addressId: String
  addressKey: String
}

input SetCustomerDefaultShippingAddress {
  addressId: String
  addressKey: String
}

input SetCustomerExternalId {
  externalId: String
}

input SetCustomerFirstName {
  firstName: String
}

input SetCustomerGroup {
  customerGroup: ResourceIdentifierInput
}

input SetCustomerGroupCustomField {
  name: String!
  value: String
}

input SetCustomerGroupCustomType {
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
}

input SetCustomerGroupKey {
  key: String
}

input SetCustomerKey {
  key: String
}

input SetCustomerLastName {
  lastName: String
}

input SetCustomerLocale {
  locale: Locale
}

input SetCustomerMiddleName {
  middleName: String
}

input SetCustomerNumber {
  customerNumber: String
}

input SetCustomerSalutation {
  salutation: String
}

input SetCustomerStores {
  stores: [ResourceIdentifierInput!]!
}

input SetCustomerTitle {
  title: String
}

input SetCustomerVatId {
  vatId: String
}

input SetDiscountCodeCartPredicate {
  cartPredicate: String
}

input SetDiscountCodeCustomField {
  name: String!
  value: String
}

input SetDiscountCodeCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetDiscountCodeDescription {
  description: [LocalizedStringItemInputType!]
}

input SetDiscountCodeKey {
  key: String
}

input SetDiscountCodeMaxApplications {
  maxApplications: Long
}

input SetDiscountCodeMaxApplicationsPerCustomer {
  maxApplicationsPerCustomer: Long
}

input SetDiscountCodeName {
  name: [LocalizedStringItemInputType!]
}

input SetDiscountCodeValidFrom {
  validFrom: DateTime
}

input SetDiscountCodeValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}

input SetDiscountCodeValidUntil {
  validUntil: DateTime
}

input SetExtensionKey {
  key: String
}

input SetExtensionTimeoutInMs {
  timeoutInMs: Int
}

input SetInventoryEntryCustomField {
  name: String!
  value: String
}

input SetInventoryEntryCustomType {
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
}

input SetInventoryEntryExpectedDelivery {
  expectedDelivery: DateTime
}

input SetInventoryEntryRestockableInDays {
  restockableInDays: Int
}

input SetInventoryEntrySupplyChannel {
  supplyChannel: ResourceIdentifierInput
}

input SetMyBusinessUnitAddressCustomField {
  addressId: String
  addressKey: String
  name: String!
  value: String
}

input SetMyBusinessUnitAddressCustomType {
  addressId: String
  addressKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetMyBusinessUnitContactEmail {
  contactEmail: String
}

input SetMyBusinessUnitCustomField {
  name: String!
  value: String
}

input SetMyBusinessUnitCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetMyBusinessUnitDefaultBillingAddress {
  addressId: String
  addressKey: String
}

input SetMyBusinessUnitDefaultShippingAddress {
  addressId: String
  addressKey: String
}

input SetMyCartShippingMethod {
  shippingMethod: ResourceIdentifierInput
}

input SetMyQuoteRequestCustomField {
  name: String!
  value: String
}

input SetMyQuoteRequestCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetOrderBillingAddress {
  address: AddressInput
}

input SetOrderBillingAddressCustomField {
  name: String!
  value: String
}

input SetOrderBillingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetOrderCustomField {
  name: String!
  value: String
}

input SetOrderCustomLineItemCustomField {
  customLineItemId: String
  customLineItemKey: String
  name: String!
  value: String
}

input SetOrderCustomLineItemCustomType {
  customLineItemId: String
  customLineItemKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetOrderCustomLineItemShippingDetails {
  customLineItemId: String
  customLineItemKey: String
  shippingDetails: ItemShippingDetailsDraftType
}

input SetOrderCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetOrderCustomerEmail {
  email: String
}

input SetOrderCustomerId {
  customerId: String
}

input SetOrderDeliveryAddress {
  deliveryId: String
  deliveryKey: String
  address: AddressInput
}

input SetOrderDeliveryAddressCustomField {
  deliveryId: String
  deliveryKey: String
  name: String!
  value: String
}

input SetOrderDeliveryAddressCustomType {
  deliveryId: String
  deliveryKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetOrderDeliveryCustomField {
  name: String!
  value: String
  deliveryId: String
  deliveryKey: String
}

input SetOrderDeliveryCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  deliveryId: String
  deliveryKey: String
}

input SetOrderDeliveryItems {
  deliveryId: String
  deliveryKey: String
  items: [DeliveryItemDraftType!]!
}

input SetOrderEditComment {
  comment: String
}

input SetOrderEditCustomField {
  name: String!
  value: String
}

input SetOrderEditCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetOrderEditKey {
  key: String
}

input SetOrderEditStagedActions {
  stagedActions: [StagedOrderUpdateAction!]!
}

input SetOrderItemShippingAddressCustomField {
  addressKey: String!
  name: String!
  value: String
}

input SetOrderItemShippingAddressCustomType {
  addressKey: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetOrderLineItemCustomField {
  lineItemId: String
  name: String!
  value: String
  lineItemKey: String
}

input SetOrderLineItemCustomType {
  lineItemId: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  lineItemKey: String
}

input SetOrderLineItemShippingDetails {
  lineItemId: String
  shippingDetails: ItemShippingDetailsDraftType
  lineItemKey: String
}

input SetOrderLocale {
  locale: Locale
}

input SetOrderNumber {
  orderNumber: String
}

input SetOrderParcelCustomField {
  name: String!
  value: String
  parcelId: String
  parcelKey: String
}

input SetOrderParcelCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  parcelId: String
  parcelKey: String
}

input SetOrderParcelItems {
  parcelId: String
  parcelKey: String
  items: [DeliveryItemDraftType!]!
}

input SetOrderParcelMeasurements {
  parcelId: String
  parcelKey: String
  measurements: ParcelMeasurementsDraftType
}

input SetOrderParcelTrackingData {
  parcelId: String
  parcelKey: String
  trackingData: TrackingDataDraftType
}

input SetOrderPurchaseOrderNumber {
  purchaseOrderNumber: String
}

input SetOrderReturnInfo {
  items: [ReturnInfoDraftType!] = []
}

input SetOrderReturnItemCustomField {
  name: String!
  value: String
  returnItemId: String
  returnItemKey: String
}

input SetOrderReturnItemCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  returnItemId: String
  returnItemKey: String
}

input SetOrderReturnPaymentState {
  returnItemId: String
  returnItemKey: String
  paymentState: ReturnPaymentState!
}

input SetOrderReturnShipmentState {
  returnItemId: String
  returnItemKey: String
  shipmentState: ReturnShipmentState!
}

input SetOrderShippingAddress {
  address: AddressInput
}

input SetOrderShippingAddressCustomField {
  name: String!
  value: String
}

input SetOrderShippingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetOrderShippingCustomField {
  shippingKey: String
  name: String!
  value: String
}

input SetOrderShippingCustomType {
  shippingKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetOrderStore {
  store: ResourceIdentifierInput
}

input SetPaymentAmountPaid {
  amount: MoneyInput
}

input SetPaymentAmountRefunded {
  amount: MoneyInput
}

input SetPaymentAnonymousId {
  anonymousId: String
}

input SetPaymentAuthorization {
  amount: MoneyInput
  until: DateTime
}

input SetPaymentCustomField {
  name: String!
  value: String
}

input SetPaymentCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetPaymentCustomer {
  customer: ResourceIdentifierInput
}

input SetPaymentExternalId {
  externalId: String
}

input SetPaymentInterfaceId {
  interfaceId: String
}

input SetPaymentKey {
  key: String
}

input SetPaymentMethodInfoInterface {
  interface: String!
}

input SetPaymentMethodInfoMethod {
  method: String
}

input SetPaymentMethodInfoName {
  name: [LocalizedStringItemInputType!]
}

input SetPaymentStatusInterfaceCode {
  interfaceCode: String
}

input SetPaymentStatusInterfaceText {
  interfaceText: String
}

input SetPaymentTransactionCustomField {
  name: String!
  value: String
  transactionId: String!
}

input SetPaymentTransactionCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  transactionId: String!
}

input SetProductAssetCustomField {
  variantId: Int
  sku: String
  staged: Boolean = true
  value: String
  name: String!
  assetKey: String
  assetId: String
}

input SetProductAssetCustomType {
  variantId: Int
  sku: String
  staged: Boolean = true
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
  assetKey: String
  assetId: String
}

input SetProductAssetDescription {
  variantId: Int
  sku: String
  staged: Boolean = true
  description: [LocalizedStringItemInputType!]
  assetKey: String
  assetId: String
}

input SetProductAssetKey {
  variantId: Int
  sku: String
  staged: Boolean = true
  assetKey: String
  assetId: String!
}

input SetProductAssetSources {
  variantId: Int
  sku: String
  staged: Boolean = true
  sources: [AssetSourceInput!] = []
  assetKey: String
  assetId: String
}

input SetProductAssetTags {
  variantId: Int
  sku: String
  staged: Boolean = true
  tags: [String!] = []
  assetKey: String
  assetId: String
}

input SetProductAttribute {
  variantId: Int
  sku: String
  name: String!
  value: String
  staged: Boolean = true
}

input SetProductAttributeInAllVariants {
  name: String!
  value: String
  staged: Boolean = true
}

input SetProductCategoryOrderHint {
  categoryId: String!
  orderHint: String
  staged: Boolean = true
}

input SetProductDescription {
  description: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductDiscountDescription {
  description: [LocalizedStringItemInputType!]
}

input SetProductDiscountKey {
  key: String
}

input SetProductDiscountValidFrom {
  validFrom: DateTime
}

input SetProductDiscountValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}

input SetProductDiscountValidUntil {
  validUntil: DateTime
}

input SetProductDiscountedPrice {
  priceId: String!
  discounted: DiscountedProductPriceValueInput
  staged: Boolean = true
}

input SetProductImageLabel {
  variantId: Int
  sku: String
  imageUrl: String!
  label: String
  staged: Boolean = true
}

input SetProductKey {
  key: String
}

input SetProductMetaAttributes {
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  metaTitle: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductMetaDescription {
  metaDescription: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductMetaKeywords {
  metaKeywords: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductMetaTitle {
  metaTitle: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductPriceCustomField {
  priceId: String!
  staged: Boolean = true
  name: String!
  value: String
}

input SetProductPriceCustomType {
  priceId: String!
  staged: Boolean = true
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetProductPriceKey {
  priceId: String!
  key: String
  staged: Boolean = true
}

input SetProductPriceMode {
  priceMode: PriceMode
}

input SetProductPrices {
  variantId: Int
  sku: String
  prices: [ProductPriceDataInput!]!
  staged: Boolean = true
}

input SetProductSelectionCustomField {
  name: String!
  value: String
}

input SetProductSelectionCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetProductSelectionKey {
  key: String
}

input SetProductSelectionVariantExclusion {
  product: ResourceIdentifierInput!
  variantExclusion: ProductVariantExclusionDraft
}

input SetProductSelectionVariantSelection {
  product: ResourceIdentifierInput!
  variantSelection: ProductVariantSelectionDraft
}

input SetProductSku {
  variantId: Int!
  sku: String
  staged: Boolean = true
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input SetProductTailoringAssetCustomField {
  variantId: Int
  sku: String
  staged: Boolean = true
  value: String
  name: String!
  assetKey: String
  assetId: String
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input SetProductTailoringAssetCustomType {
  variantId: Int
  sku: String
  staged: Boolean = true
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
  assetKey: String
  assetId: String
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input SetProductTailoringAssetDescription {
  variantId: Int
  sku: String
  staged: Boolean = true
  description: [LocalizedStringItemInputType!]
  assetKey: String
  assetId: String
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input SetProductTailoringAssetKey {
  variantId: Int
  sku: String
  staged: Boolean = true
  assetKey: String
  assetId: String!
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input SetProductTailoringAssetSources {
  variantId: Int
  sku: String
  staged: Boolean = true
  sources: [AssetSourceInput!] = []
  assetKey: String
  assetId: String
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input SetProductTailoringAssetTags {
  variantId: Int
  sku: String
  staged: Boolean = true
  tags: [String!] = []
  assetKey: String
  assetId: String
}

input SetProductTailoringDescription {
  description: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input SetProductTailoringImageLabel {
  variantId: Int
  sku: String
  imageUrl: String!
  label: String
  staged: Boolean = true
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input SetProductTailoringImages {
  variantId: Int
  sku: String
  images: [ImageInput!]!
  staged: Boolean = true
}

input SetProductTailoringMetaAttributes {
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  metaTitle: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringMetaDescription {
  metaDescription: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringMetaKeywords {
  metaKeywords: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringMetaTitle {
  metaTitle: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringName {
  name: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringSlug {
  slug: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTaxCategory {
  taxCategory: ResourceIdentifierInput
}

input SetProductVariantKey {
  variantId: Int
  sku: String
  key: String
  staged: Boolean = true
}

input SetProjectSettingsExternalOAuth {
  externalOAuth: ExternalOAuthDraft
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
input SetProjectSettingsMyBusinessUnitAssociateRoleOnCreation {
  associateRole: ResourceIdentifierInput
}

input SetProjectSettingsShippingRateInputType {
  shippingRateInputType: ShippingRateInputTypeInput
}

input SetQuoteCustomField {
  name: String!
  value: String
}

input SetQuoteCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetQuoteRequestCustomField {
  name: String!
  value: String
}

input SetQuoteRequestCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetReviewAuthorName {
  authorName: String
}

input SetReviewCustomField {
  name: String!
  value: String
}

input SetReviewCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetReviewCustomer {
  customer: ResourceIdentifierInput
}

input SetReviewKey {
  key: String
}

input SetReviewLocale {
  locale: Locale
}

input SetReviewRating {
  rating: Int
}

input SetReviewTarget {
  target: TargetReferenceInput
}

input SetReviewText {
  text: String
}

input SetReviewTitle {
  title: String
}

input SetSearchKeywords {
  searchKeywords: [SearchKeywordInput!]!
  staged: Boolean
}

input SetShippingMethodCustomField {
  name: String!
  value: String
}

input SetShippingMethodCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetShippingMethodDescription {
  description: String
}

input SetShippingMethodKey {
  key: String
}

input SetShippingMethodLocalizedDescription {
  localizedDescription: [LocalizedStringItemInputType!]
}

input SetShippingMethodLocalizedName {
  localizedName: [LocalizedStringItemInputType!]
}

input SetShippingMethodPredicate {
  predicate: String
}

input SetShoppingListAnonymousId {
  anonymousId: String
}

input SetShoppingListCustomField {
  name: String!
  value: String
}

input SetShoppingListCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetShoppingListCustomer {
  customer: ResourceIdentifierInput
}

input SetShoppingListDeleteDaysAfterLastModification {
  deleteDaysAfterLastModification: Int
}

input SetShoppingListDescription {
  description: [LocalizedStringItemInputType!]
}

input SetShoppingListKey {
  key: String
}

input SetShoppingListLineItemCustomField {
  lineItemId: String
  lineItemKey: String
  name: String!
  value: String
}

input SetShoppingListLineItemCustomType {
  lineItemId: String
  lineItemKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetShoppingListSlug {
  slug: [LocalizedStringItemInputType!]
}

input SetShoppingListStore {
  store: ResourceIdentifierInput
}

input SetShoppingListTextLineItemCustomField {
  textLineItemId: String
  textLineItemKey: String
  name: String!
  value: String
}

input SetShoppingListTextLineItemCustomType {
  textLineItemId: String
  textLineItemKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetShoppingListTextLineItemDescription {
  textLineItemId: String
  textLineItemKey: String
  description: [LocalizedStringItemInputType!]
}

input SetStagedOrderBillingAddress {
  address: AddressInput
}

input SetStagedOrderBillingAddressCustomField {
  name: String!
  value: String
}

type SetStagedOrderBillingAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  name: String!
  value: Json
}

input SetStagedOrderBillingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

type SetStagedOrderBillingAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  custom: CustomFieldsCommand!
}

type SetStagedOrderBillingAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft
}

input SetStagedOrderCountry {
  country: Country
}

type SetStagedOrderCountryOutput implements StagedOrderUpdateActionOutput {
  type: String!
  country: Country
}

input SetStagedOrderCustomField {
  name: String!
  value: String
}

type SetStagedOrderCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  name: String!
  value: Json
}

input SetStagedOrderCustomLineItemCustomField {
  customLineItemId: String
  customLineItemKey: String
  name: String!
  value: String
}

type SetStagedOrderCustomLineItemCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String
  customLineItemKey: String
  name: String!
  value: Json
}

input SetStagedOrderCustomLineItemCustomType {
  customLineItemId: String
  customLineItemKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

type SetStagedOrderCustomLineItemCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String
  customLineItemKey: String
  custom: CustomFieldsCommand!
}

input SetStagedOrderCustomLineItemShippingDetails {
  customLineItemId: String
  customLineItemKey: String
  shippingDetails: ItemShippingDetailsDraftType
}

type SetStagedOrderCustomLineItemShippingDetailsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String
  customLineItemKey: String
  shippingDetails: ItemShippingDetailsDraftOutput
}

input SetStagedOrderCustomLineItemTaxAmount {
  customLineItemId: String
  customLineItemKey: String
  externalTaxAmount: ExternalTaxAmountDraft
  shippingKey: String
}

type SetStagedOrderCustomLineItemTaxAmountOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String
  customLineItemKey: String
  externalTaxAmount: ExternalTaxAmountDraftOutput
  shippingKey: String
}

input SetStagedOrderCustomLineItemTaxRate {
  customLineItemId: String
  customLineItemKey: String
  externalTaxRate: ExternalTaxRateDraft
  shippingKey: String
}

type SetStagedOrderCustomLineItemTaxRateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String
  customLineItemKey: String
  externalTaxRate: ExternalTaxRateDraftOutput
  shippingKey: String
}

input SetStagedOrderCustomShippingMethod {
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  taxCategory: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}

type SetStagedOrderCustomShippingMethodOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shippingMethodName: String!
  shippingRate: ShippingRate!
  taxCategoryResId: ResourceIdentifier
  externalTaxRate: ExternalTaxRateDraftOutput
}

input SetStagedOrderCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

type SetStagedOrderCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  custom: CustomFieldsCommand!
}

input SetStagedOrderCustomerEmail {
  email: String
}

type SetStagedOrderCustomerEmailOutput implements StagedOrderUpdateActionOutput {
  type: String!
  email: String
}

input SetStagedOrderCustomerGroup {
  customerGroup: ResourceIdentifierInput
}

type SetStagedOrderCustomerGroupOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customerGroupResId: CustomerGroupReferenceIdentifier
}

input SetStagedOrderCustomerId {
  customerId: String
}

type SetStagedOrderCustomerIdOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customerId: String
}

input SetStagedOrderDeliveryAddress {
  deliveryId: String
  deliveryKey: String
  address: AddressInput
}

input SetStagedOrderDeliveryAddressCustomField {
  deliveryId: String
  deliveryKey: String
  name: String!
  value: String
}

type SetStagedOrderDeliveryAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String
  deliveryKey: String
  name: String!
  value: Json
}

input SetStagedOrderDeliveryAddressCustomType {
  deliveryId: String
  deliveryKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

type SetStagedOrderDeliveryAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String
  deliveryKey: String
  custom: CustomFieldsCommand!
}

type SetStagedOrderDeliveryAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String
  deliveryKey: String
  address: AddressDraft
}

input SetStagedOrderDeliveryCustomField {
  name: String!
  value: String
  deliveryId: String
  deliveryKey: String
}

type SetStagedOrderDeliveryCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  name: String!
  value: Json
  deliveryId: String
  deliveryKey: String
}

input SetStagedOrderDeliveryCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  deliveryId: String
  deliveryKey: String
}

type SetStagedOrderDeliveryCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  custom: CustomFieldsCommand!
  deliveryId: String
  deliveryKey: String
}

input SetStagedOrderDeliveryItems {
  deliveryId: String
  deliveryKey: String
  items: [DeliveryItemDraftType!]!
}

type SetStagedOrderDeliveryItemsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String
  deliveryKey: String
  items: [DeliveryItem!]!
}

input SetStagedOrderDirectDiscounts {
  discounts: [DirectDiscountDraft!]!
}

type SetStagedOrderDirectDiscountsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  discounts: [DirectDiscountDraftOutput!]!
}

input SetStagedOrderItemShippingAddressCustomField {
  addressKey: String!
  name: String!
  value: String
}

type SetStagedOrderItemShippingAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  addressKey: String!
  name: String!
  value: Json
}

input SetStagedOrderItemShippingAddressCustomType {
  addressKey: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

type SetStagedOrderItemShippingAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  addressKey: String!
  custom: CustomFieldsCommand!
}

input SetStagedOrderLineItemCustomField {
  lineItemId: String
  name: String!
  value: String
  lineItemKey: String
}

type SetStagedOrderLineItemCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  name: String!
  value: Json
  lineItemKey: String
}

input SetStagedOrderLineItemCustomType {
  lineItemId: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  lineItemKey: String
}

type SetStagedOrderLineItemCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  custom: CustomFieldsCommand!
  lineItemKey: String
}

input SetStagedOrderLineItemDistributionChannel {
  lineItemId: String
  distributionChannel: ResourceIdentifierInput
  lineItemKey: String
}

type SetStagedOrderLineItemDistributionChannelOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  distributionChannelResId: ChannelReferenceIdentifier
  lineItemKey: String
}

input SetStagedOrderLineItemPrice {
  lineItemId: String
  externalPrice: BaseMoneyInput
  lineItemKey: String
}

type SetStagedOrderLineItemPriceOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  externalPrice: BaseMoney
  lineItemKey: String
}

input SetStagedOrderLineItemShippingDetails {
  lineItemId: String
  shippingDetails: ItemShippingDetailsDraftType
  lineItemKey: String
}

type SetStagedOrderLineItemShippingDetailsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  shippingDetails: ItemShippingDetailsDraftOutput
  lineItemKey: String
}

input SetStagedOrderLineItemTaxAmount {
  lineItemId: String
  externalTaxAmount: ExternalTaxAmountDraft
  shippingKey: String
  lineItemKey: String
}

type SetStagedOrderLineItemTaxAmountOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  externalTaxAmount: ExternalTaxAmountDraftOutput
  shippingKey: String
  lineItemKey: String
}

input SetStagedOrderLineItemTaxRate {
  lineItemId: String
  externalTaxRate: ExternalTaxRateDraft
  shippingKey: String
  lineItemKey: String
}

type SetStagedOrderLineItemTaxRateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  externalTaxRate: ExternalTaxRateDraftOutput
  shippingKey: String
  lineItemKey: String
}

input SetStagedOrderLineItemTotalPrice {
  lineItemId: String
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  lineItemKey: String
}

type SetStagedOrderLineItemTotalPriceOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  externalTotalPrice: ExternalLineItemTotalPrice
  lineItemKey: String
}

input SetStagedOrderLocale {
  locale: Locale
}

type SetStagedOrderLocaleOutput implements StagedOrderUpdateActionOutput {
  type: String!
  locale: Locale
}

input SetStagedOrderOrderNumber {
  orderNumber: String
}

type SetStagedOrderOrderNumberOutput implements StagedOrderUpdateActionOutput {
  type: String!
  orderNumber: String
}

input SetStagedOrderOrderTotalTax {
  externalTotalGross: MoneyInput
  externalTaxPortions: [TaxPortionDraft!] = []
}

type SetStagedOrderOrderTotalTaxOutput implements StagedOrderUpdateActionOutput {
  type: String!
  externalTotalGross: Money
  externalTaxPortions: [TaxPortion!]!
}

input SetStagedOrderParcelCustomField {
  name: String!
  value: String
  parcelId: String
  parcelKey: String
}

type SetStagedOrderParcelCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  name: String!
  value: Json
  parcelId: String
  parcelKey: String
}

input SetStagedOrderParcelCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  parcelId: String
  parcelKey: String
}

type SetStagedOrderParcelCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  custom: CustomFieldsCommand!
  parcelId: String
  parcelKey: String
}

input SetStagedOrderParcelItems {
  parcelId: String
  parcelKey: String
  items: [DeliveryItemDraftType!]!
}

type SetStagedOrderParcelItemsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  parcelId: String
  parcelKey: String
  items: [DeliveryItem!]!
}

input SetStagedOrderParcelMeasurements {
  parcelId: String
  parcelKey: String
  measurements: ParcelMeasurementsDraftType
}

type SetStagedOrderParcelMeasurementsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  parcelId: String
  parcelKey: String
  measurements: ParcelMeasurements
}

input SetStagedOrderParcelTrackingData {
  parcelId: String
  parcelKey: String
  trackingData: TrackingDataDraftType
}

type SetStagedOrderParcelTrackingDataOutput implements StagedOrderUpdateActionOutput {
  type: String!
  parcelId: String
  parcelKey: String
  trackingData: TrackingData
}

input SetStagedOrderPurchaseOrderNumber {
  purchaseOrderNumber: String
}

type SetStagedOrderPurchaseOrderNumberOutput implements StagedOrderUpdateActionOutput {
  type: String!
  purchaseOrderNumber: String
}

input SetStagedOrderReturnInfo {
  items: [ReturnInfoDraftType!] = []
}

type SetStagedOrderReturnInfoOutput implements StagedOrderUpdateActionOutput {
  type: String!
  items: [ReturnInfoDraftTypeOutput!]!
}

input SetStagedOrderReturnItemCustomField {
  name: String!
  value: String
  returnItemId: String
  returnItemKey: String
}

type SetStagedOrderReturnItemCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  name: String!
  value: Json
  returnItemId: String
  returnItemKey: String
}

input SetStagedOrderReturnItemCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  returnItemId: String
  returnItemKey: String
}

type SetStagedOrderReturnItemCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  custom: CustomFieldsCommand!
  returnItemId: String
  returnItemKey: String
}

input SetStagedOrderReturnPaymentState {
  returnItemId: String
  returnItemKey: String
  paymentState: ReturnPaymentState!
}

type SetStagedOrderReturnPaymentStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  returnItemId: String
  returnItemKey: String
  paymentState: ReturnPaymentState!
}

input SetStagedOrderReturnShipmentState {
  returnItemId: String
  returnItemKey: String
  shipmentState: ReturnShipmentState!
}

type SetStagedOrderReturnShipmentStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  returnItemId: String
  returnItemKey: String
  shipmentState: ReturnShipmentState!
}

input SetStagedOrderShippingAddress {
  address: AddressInput
}

input SetStagedOrderShippingAddressAndCustomShippingMethod {
  address: AddressInput!
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  taxCategory: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}

type SetStagedOrderShippingAddressAndCustomShippingMethodOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft!
  shippingMethodName: String!
  shippingRate: ShippingRate!
  taxCategoryResId: ResourceIdentifier
  externalTaxRate: ExternalTaxRateDraftOutput
}

input SetStagedOrderShippingAddressAndShippingMethod {
  address: AddressInput!
  shippingMethod: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}

type SetStagedOrderShippingAddressAndShippingMethodOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft!
  shippingMethodResId: ResourceIdentifier
  externalTaxRate: ExternalTaxRateDraftOutput
}

input SetStagedOrderShippingAddressCustomField {
  name: String!
  value: String
}

type SetStagedOrderShippingAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  name: String!
  value: Json
}

input SetStagedOrderShippingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

type SetStagedOrderShippingAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  custom: CustomFieldsCommand!
}

type SetStagedOrderShippingAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft
}

input SetStagedOrderShippingCustomField {
  shippingKey: String
  name: String!
  value: String
}

type SetStagedOrderShippingCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shippingKey: String
  name: String!
  value: Json
}

input SetStagedOrderShippingCustomType {
  shippingKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

type SetStagedOrderShippingCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shippingKey: String
  custom: CustomFieldsCommand!
}

input SetStagedOrderShippingMethod {
  shippingMethod: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}

type SetStagedOrderShippingMethodOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shippingMethodResId: ResourceIdentifier
  externalTaxRate: ExternalTaxRateDraftOutput
}

input SetStagedOrderShippingMethodTaxAmount {
  externalTaxAmount: ExternalTaxAmountDraft
  shippingKey: String
}

type SetStagedOrderShippingMethodTaxAmountOutput implements StagedOrderUpdateActionOutput {
  type: String!
  externalTaxAmount: ExternalTaxAmountDraftOutput
  shippingKey: String
}

input SetStagedOrderShippingMethodTaxRate {
  externalTaxRate: ExternalTaxRateDraft
  shippingKey: String
}

type SetStagedOrderShippingMethodTaxRateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  externalTaxRate: ExternalTaxRateDraftOutput
  shippingKey: String
}

input SetStagedOrderShippingRateInput {
  shippingRateInput: ShippingRateInputDraft
}

type SetStagedOrderShippingRateInputOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shippingRateInput: ShippingRateInputDraftOutput
}

input SetStagedOrderStore {
  store: ResourceIdentifierInput
}

type SetStagedOrderStoreOutput implements StagedOrderUpdateActionOutput {
  type: String!
  storeResId: ResourceIdentifier
}

input SetStagedQuoteCustomField {
  name: String!
  value: String
}

input SetStagedQuoteCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetStagedQuoteSellerComment {
  sellerComment: String
}

input SetStagedQuoteValidTo {
  validTo: DateTime
}

input SetStandalonePriceCustomFields {
  name: String!
  value: String
}

input SetStandalonePriceDiscountedPrice {
  discounted: DiscountedProductPriceValueInput
}

input SetStandalonePriceKey {
  key: String
}

input SetStandalonePriceTiers {
  tiers: [ProductPriceTierInput!]!
}

input SetStandalonePriceValidFrom {
  validFrom: DateTime
}

input SetStandalonePriceValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}

input SetStandalonePriceValidUntil {
  validUntil: DateTime
}

input SetStateDescription {
  description: [LocalizedStringItemInputType!]
}

input SetStateName {
  name: [LocalizedStringItemInputType!]
}

input SetStateRoles {
  roles: [StateRole!]!
}

input SetStateTransitions {
  transitions: [ResourceIdentifierInput!]
}

input SetStoreCountries {
  countries: [StoreCountryInput!]
}

input SetStoreCustomField {
  name: String!
  value: String
}

input SetStoreCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}

input SetStoreDistributionChannels {
  distributionChannels: [ResourceIdentifierInput!]
}

input SetStoreLanguages {
  languages: [Locale!]
}

input SetStoreName {
  name: [LocalizedStringItemInputType!]
}

input SetStoreProductSelections {
  productSelections: [ProductSelectionSettingInActionInput!]
}

input SetStoreSupplyChannels {
  supplyChannels: [ResourceIdentifierInput!]
}

input SetSubscriptionChanges {
  changes: [ChangeSubscriptionInput!]!
}

input SetSubscriptionKey {
  key: String
}

input SetSubscriptionMessages {
  messages: [MessageSubscriptionInput!]!
}

input SetTaxCategoryKey {
  key: String
}

type SetType implements FieldType {
  elementType: FieldType!
  name: String!
}

input SetTypeDescription {
  description: [LocalizedStringItemInputType!]
}

input SetZoneDescription {
  description: String
}

input SetZoneKey {
  key: String
}

enum ShipmentState {
  Backorder
  Delayed
  Delivered
  Partial
  Pending
  Ready
  Shipped
}

type Shipping {
  shippingKey: String
  shippingInfo: ShippingInfo
  shippingAddress: Address
  shippingRateInput: ShippingRateInput
  shippingCustomFields: CustomFieldsType
}

input ShippingDraft {
  key: String!
  shippingMethod: ResourceIdentifierInput
  shippingAddress: AddressInput!
  shippingRateInput: ShippingRateInputDraft
  externalTaxRate: ExternalTaxRateDraft
  deliveries: [DeliveryDraft!]
  custom: CustomFieldsDraft
}

type ShippingInfo {
  shippingMethodName: String!
  price: Money!
  shippingRate: ShippingRate!
  taxRate: TaxRate
  deliveries: [Delivery!]!
  discountedPrice: DiscountedLineItemPrice
  shippingMethodState: ShippingMethodState!
  shippingMethod: ShippingMethod
  shippingMethodRef: Reference
  taxCategory: TaxCategory
  taxCategoryRef: Reference
  taxedPrice: TaxedItemPrice
}

input ShippingInfoImportDraft {
  shippingMethodName: String!
  price: MoneyInput!
  shippingRate: ShippingRateDraft!
  taxRate: TaxRateInput
  taxCategory: ResourceIdentifierInput
  deliveries: [DeliveryDraft!]! = []
  shippingMethod: ResourceIdentifierInput
  discountedPrice: DiscountedLineItemPriceDraft
  shippingMethodState: ShippingMethodState! = MatchesCart
}

type ShippingMethod implements Versioned & ReferenceExpandable {
  name: String!
  zoneRates: [ZoneRate!]!
  active: Boolean!
  isDefault: Boolean!
  predicate: String
  key: String
  taxCategoryRef: Reference
  localizedDescriptionAllLocales: [LocalizedString!]
  localizedNameAllLocales: [LocalizedString!]
  localizedDescription(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  localizedName(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  taxCategory: TaxCategory
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

input ShippingMethodDraft {
  name: String!
  localizedName: [LocalizedStringItemInputType!]

  "The usage of parameter 'description' is deprecated in favor of using 'localizedDescription'"
  description: String
  localizedDescription: [LocalizedStringItemInputType!]
  taxCategory: ResourceIdentifierInput!
  zoneRates: [ZoneRateDraft!] = []
  active: Boolean
  isDefault: Boolean!
  predicate: String
  key: String
  custom: CustomFieldsDraft
}

type ShippingMethodLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type ShippingMethodLimitsProjection {
  total: ShippingMethodLimitWithCurrent!
}

type ShippingMethodQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [ShippingMethod!]!
}

enum ShippingMethodState {
  "The ShippingMethod predicate does not match the cart. Ordering this cart will fail with error ShippingMethodDoesNotMatchCart"
  DoesNotMatchCart

  "Either there is no predicate defined for the ShippingMethod or the given predicate matches the cart"
  MatchesCart
}

input ShippingMethodUpdateAction {
  addShippingRate: AddShippingMethodShippingRate
  addZone: AddShippingMethodZone
  changeActive: ChangeShippingMethodActive
  changeIsDefault: ChangeShippingMethodIsDefault
  changeName: ChangeShippingMethodName
  changeTaxCategory: ChangeShippingMethodTaxCategory
  removeShippingRate: RemoveShippingMethodShippingRate
  removeZone: RemoveShippingMethodZone
  setCustomField: SetShippingMethodCustomField
  setCustomType: SetShippingMethodCustomType

  "This action is deprecated in favor of using 'setLocalizedDescription'"
  setDescription: SetShippingMethodDescription
  setKey: SetShippingMethodKey
  setLocalizedDescription: SetShippingMethodLocalizedDescription
  setLocalizedName: SetShippingMethodLocalizedName
  setPredicate: SetShippingMethodPredicate
}

"A field to retrieve available shipping methods for a cart."
interface ShippingMethodsByCartInterface {
  shippingMethodsByCart(id: String!): [ShippingMethod!]!
}

enum ShippingMode {
  "Allows multiple shipping methods for the cart with their respective shipping addresses"
  Multiple

  "Allows only one shipping method and shipping address for the cart"
  Single
}

"Shipping Rate"
type ShippingRate {
  price: Money!
  freeAbove: Money
  isMatching: Boolean
  tiers: [ShippingRatePriceTier!]!
}

type ShippingRateCartClassificationPriceTier implements ShippingRatePriceTier {
  value: String!
  price: Money!
  isMatching: Boolean
  type: String!
}

type ShippingRateCartScorePriceTier implements ShippingRatePriceTier {
  score: Int!
  price: Money
  priceFunction: PriceFunction
  isMatching: Boolean
  type: String!
}

type ShippingRateCartValuePriceTier implements ShippingRatePriceTier {
  minimumCentAmount: Int!
  price: Money!
  isMatching: Boolean
  type: String!
}

input ShippingRateDraft {
  price: MoneyDraft!
  freeAbove: MoneyDraft
  tiers: [ShippingRatePriceTierDraft!] = []
}

interface ShippingRateInput {
  type: String!
}

input ShippingRateInputDraft {
  Classification: ClassificationShippingRateInputDraft
  Score: ScoreShippingRateInputDraft
}

interface ShippingRateInputDraftOutput {
  type: String!
}

type ShippingRateInputLocalizedEnumValue {
  key: String!
  label(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  labelAllLocales: [LocalizedString!]!
}

interface ShippingRateInputType {
  type: String!
}

input ShippingRateInputTypeInput {
  CartValue: CartValueInput
  CartClassification: CartClassificationInput
  CartScore: CartScoreInput
}

interface ShippingRatePriceTier {
  type: String!
}

input ShippingRatePriceTierCartClassificationDraft {
  value: String!
  price: MoneyDraft!
}

input ShippingRatePriceTierCartScoreDraft {
  score: Int!
  price: MoneyDraft
  priceFunction: PriceFunctionDraft
}

input ShippingRatePriceTierCartValueDraft {
  minimumCentAmount: Int!
  price: MoneyDraft!
}

input ShippingRatePriceTierDraft {
  CartValue: ShippingRatePriceTierCartValueDraft
  CartClassification: ShippingRatePriceTierCartClassificationDraft
  CartScore: ShippingRatePriceTierCartScoreDraft
}

type ShippingTarget implements CartDiscountTarget {
  type: String!
}

input ShippingTargetDraft {
  addressKey: String!
  quantity: Long!
  shippingMethodKey: String
}

input ShippingTargetDraftType {
  addressKey: String!
  quantity: Long!
  shippingMethodKey: String
}

input ShippingTargetInput {
  dummy: String
}

type ShoppingList implements Versioned & ReferenceExpandable {
  key: String
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]
  customerRef: Reference
  customer: Customer
  storeRef: KeyReference
  store: Store
  anonymousId: String
  lineItems: [ShoppingListLineItem!]!
  textLineItems: [TextLineItem!]!
  custom: CustomFieldsType
  deleteDaysAfterLastModification: Int
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

input ShoppingListDraft {
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  lineItems: [ShoppingListLineItemDraft!] = []
  textLineItems: [TextLineItemDraft!] = []
  custom: CustomFieldsDraft
  deleteDaysAfterLastModification: Int
  key: String
  customer: ResourceIdentifierInput
  slug: [LocalizedStringItemInputType!]
  anonymousId: String
}

type ShoppingListLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type ShoppingListLimitsProjection {
  lineItems: Limit!
  textLineItems: Limit!
  total: ShoppingListLimitWithCurrent!
}

type ShoppingListLineItem {
  id: String!
  key: String
  productId: String!
  variantId: Int
  productTypeRef: Reference!
  productType: ProductTypeDefinition!
  quantity: Int!
  addedAt: DateTime!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  deactivatedAt: DateTime
  custom: CustomFieldsType
  productSlug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  productSlugAllLocales: [LocalizedString!]
  variant: ProductVariant
}

input ShoppingListLineItemDraft {
  productId: String
  key: String
  sku: String
  variantId: Int
  quantity: Int = 1
  custom: CustomFieldsDraft
  addedAt: DateTime
}

"Fields to access shopping lists. Includes direct access to a single list and searching for shopping lists."
interface ShoppingListQueryInterface {
  shoppingList(
    "Queries with specified ID"
    id: String,

    "Queries with specified key"
    key: String): ShoppingList
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
}

type ShoppingListQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [ShoppingList!]!
}

input ShoppingListUpdateAction {
  addLineItem: AddShoppingListLineItem
  addTextLineItem: AddShoppingListTextLineItem
  changeLineItemQuantity: ChangeShoppingListLineItemQuantity
  changeLineItemsOrder: ChangeShoppingListLineItemsOrder
  changeName: ChangeShoppingListName
  changeTextLineItemName: ChangeShoppingListTextLineItemName
  changeTextLineItemQuantity: ChangeShoppingListTextLineItemQuantity
  changeTextLineItemsOrder: ChangeShoppingListTextLineItemsOrder
  removeLineItem: RemoveShoppingListLineItem
  removeTextLineItem: RemoveShoppingListTextLineItem
  setAnonymousId: SetShoppingListAnonymousId
  setCustomField: SetShoppingListCustomField
  setCustomType: SetShoppingListCustomType
  setCustomer: SetShoppingListCustomer
  setDeleteDaysAfterLastModification: SetShoppingListDeleteDaysAfterLastModification
  setDescription: SetShoppingListDescription
  setKey: SetShoppingListKey
  setLineItemCustomField: SetShoppingListLineItemCustomField
  setLineItemCustomType: SetShoppingListLineItemCustomType
  setSlug: SetShoppingListSlug
  setStore: SetShoppingListStore
  setTextLineItemCustomField: SetShoppingListTextLineItemCustomField
  setTextLineItemCustomType: SetShoppingListTextLineItemCustomType
  setTextLineItemDescription: SetShoppingListTextLineItemDescription
}

type ShoppingListsConfiguration {
  deleteDaysAfterLastModification: Int
}

input ShoppingListsConfigurationInput {
  deleteDaysAfterLastModification: Int
}

input SignUpInMyBusinessUnitDraft {
  businessUnit: ResourceIdentifierInput!
  customer: CustomerSignUpDraft!
  version: Long!
  associateRoleAssignments: [AssociateRoleAssignmentDraft!]!
}

input SimpleAttributeTypeDraft {
  dummy: String
}

input SimpleFieldTypeDraft {
  dummy: String
}

"Describes how this discount interacts with other discounts"
enum StackingMode {
  "Default. Continue applying other matching discounts after applying this one."
  Stacking

  "Don\u2019t apply any more matching discounts after this one."
  StopAfterThisDiscount
}

input StagedOrderUpdateAction {
  addCustomLineItem: AddStagedOrderCustomLineItem
  addDelivery: AddStagedOrderDelivery
  addDiscountCode: AddStagedOrderDiscountCode
  addItemShippingAddress: AddStagedOrderItemShippingAddress
  addLineItem: AddStagedOrderLineItem
  addParcelToDelivery: AddStagedOrderParcelToDelivery
  addPayment: AddStagedOrderPayment
  addReturnInfo: AddStagedOrderReturnInfo
  addShoppingList: AddStagedOrderShoppingList
  changeCustomLineItemMoney: ChangeStagedOrderCustomLineItemMoney
  changeCustomLineItemQuantity: ChangeStagedOrderCustomLineItemQuantity
  changeLineItemQuantity: ChangeStagedOrderLineItemQuantity
  changeOrderState: ChangeStagedOrderOrderState
  changePaymentState: ChangeStagedOrderPaymentState
  changeShipmentState: ChangeStagedOrderShipmentState
  changeTaxCalculationMode: ChangeStagedOrderTaxCalculationMode
  changeTaxMode: ChangeStagedOrderTaxMode
  changeTaxRoundingMode: ChangeStagedOrderTaxRoundingMode
  importCustomLineItemState: ImportStagedOrderCustomLineItemState
  importLineItemState: ImportStagedOrderLineItemState
  removeCustomLineItem: RemoveStagedOrderCustomLineItem
  removeDelivery: RemoveStagedOrderDelivery
  removeDiscountCode: RemoveStagedOrderDiscountCode
  removeItemShippingAddress: RemoveStagedOrderItemShippingAddress
  removeLineItem: RemoveStagedOrderLineItem
  removeParcelFromDelivery: RemoveStagedOrderParcelFromDelivery
  removePayment: RemoveStagedOrderPayment
  setBillingAddress: SetStagedOrderBillingAddress
  setBillingAddressCustomField: SetStagedOrderBillingAddressCustomField
  setBillingAddressCustomType: SetStagedOrderBillingAddressCustomType
  setCountry: SetStagedOrderCountry
  setCustomField: SetStagedOrderCustomField
  setCustomLineItemCustomField: SetStagedOrderCustomLineItemCustomField
  setCustomLineItemCustomType: SetStagedOrderCustomLineItemCustomType
  setCustomLineItemShippingDetails: SetStagedOrderCustomLineItemShippingDetails
  setCustomLineItemTaxAmount: SetStagedOrderCustomLineItemTaxAmount
  setCustomLineItemTaxRate: SetStagedOrderCustomLineItemTaxRate
  setCustomShippingMethod: SetStagedOrderCustomShippingMethod
  setCustomType: SetStagedOrderCustomType
  setCustomerEmail: SetStagedOrderCustomerEmail
  setCustomerGroup: SetStagedOrderCustomerGroup
  setCustomerId: SetStagedOrderCustomerId
  setDeliveryAddress: SetStagedOrderDeliveryAddress
  setDeliveryAddressCustomField: SetStagedOrderDeliveryAddressCustomField
  setDeliveryAddressCustomType: SetStagedOrderDeliveryAddressCustomType
  setDeliveryCustomField: SetStagedOrderDeliveryCustomField
  setDeliveryCustomType: SetStagedOrderDeliveryCustomType
  setDeliveryItems: SetStagedOrderDeliveryItems
  setDirectDiscounts: SetStagedOrderDirectDiscounts
  setItemShippingAddressCustomField: SetStagedOrderItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetStagedOrderItemShippingAddressCustomType
  setLineItemCustomField: SetStagedOrderLineItemCustomField
  setLineItemCustomType: SetStagedOrderLineItemCustomType
  setLineItemDistributionChannel: SetStagedOrderLineItemDistributionChannel
  setLineItemPrice: SetStagedOrderLineItemPrice
  setLineItemShippingDetails: SetStagedOrderLineItemShippingDetails
  setLineItemTaxAmount: SetStagedOrderLineItemTaxAmount
  setLineItemTaxRate: SetStagedOrderLineItemTaxRate
  setLineItemTotalPrice: SetStagedOrderLineItemTotalPrice
  setLocale: SetStagedOrderLocale
  setOrderNumber: SetStagedOrderOrderNumber
  setOrderTotalTax: SetStagedOrderOrderTotalTax
  setParcelCustomField: SetStagedOrderParcelCustomField
  setParcelCustomType: SetStagedOrderParcelCustomType
  setParcelItems: SetStagedOrderParcelItems
  setParcelMeasurements: SetStagedOrderParcelMeasurements
  setParcelTrackingData: SetStagedOrderParcelTrackingData
  setPurchaseOrderNumber: SetStagedOrderPurchaseOrderNumber
  setReturnInfo: SetStagedOrderReturnInfo
  setReturnItemCustomField: SetStagedOrderReturnItemCustomField
  setReturnItemCustomType: SetStagedOrderReturnItemCustomType
  setReturnPaymentState: SetStagedOrderReturnPaymentState
  setReturnShipmentState: SetStagedOrderReturnShipmentState
  setShippingAddress: SetStagedOrderShippingAddress
  setShippingAddressAndCustomShippingMethod: SetStagedOrderShippingAddressAndCustomShippingMethod
  setShippingAddressAndShippingMethod: SetStagedOrderShippingAddressAndShippingMethod
  setShippingAddressCustomField: SetStagedOrderShippingAddressCustomField
  setShippingAddressCustomType: SetStagedOrderShippingAddressCustomType
  setShippingCustomField: SetStagedOrderShippingCustomField
  setShippingCustomType: SetStagedOrderShippingCustomType
  setShippingMethod: SetStagedOrderShippingMethod
  setShippingMethodTaxAmount: SetStagedOrderShippingMethodTaxAmount
  setShippingMethodTaxRate: SetStagedOrderShippingMethodTaxRate
  setShippingRateInput: SetStagedOrderShippingRateInput
  setStore: SetStagedOrderStore
  transitionCustomLineItemState: TransitionStagedOrderCustomLineItemState
  transitionLineItemState: TransitionStagedOrderLineItemState
  transitionState: TransitionStagedOrderState
  updateItemShippingAddress: UpdateStagedOrderItemShippingAddress
  updateSyncInfo: UpdateStagedOrderSyncInfo
}

interface StagedOrderUpdateActionOutput {
  type: String!
}

input StagedPriceDraft {
  value: BaseMoneyInput!
}

type StagedQuote implements Versioned {
  key: String
  stagedQuoteState: StagedQuoteState!
  quoteRequestRef: Reference!
  quoteRequest: QuoteRequest
  quotationCartRef: Reference!
  quotationCart: Cart
  customerRef: Reference
  customer: Customer
  validTo: DateTime
  custom: CustomFieldsType
  stateRef: Reference
  state: State
  sellerComment: String
  businessUnit: BusinessUnit
  businessUnitRef: KeyReference
  purchaseOrderNumber: String
  storeRef: KeyReference
  store: Store
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type StagedQuoteCreated implements MessagePayload {
  stagedQuote: StagedQuote!
  type: String!
}

type StagedQuoteDeleted implements MessagePayload {
  type: String!
}

input StagedQuoteDraft {
  key: String
  quoteRequest: ResourceIdentifierInput
  quoteRequestStateToAccepted: Boolean = false
  quoteRequestVersion: Long
  custom: CustomFieldsDraft
  state: ReferenceInput
}

type StagedQuoteQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [StagedQuote!]!
}

type StagedQuoteSellerCommentSet implements MessagePayload {
  sellerComment: String
  type: String!
}

enum StagedQuoteState {
  Closed
  InProgress
  Sent
}

type StagedQuoteStateChanged implements MessagePayload {
  stagedQuoteState: StagedQuoteState!
  oldStagedQuoteState: StagedQuoteState!
  type: String!
}

type StagedQuoteStateTransition implements MessagePayload {
  stateRef: Reference!
  oldStateRef: Reference
  force: Boolean!
  state: State
  oldState: State
  type: String!
}

input StagedQuoteUpdateAction {
  changeStagedQuoteState: ChangeStagedQuoteState
  setSellerComment: SetStagedQuoteSellerComment
  setCustomField: SetStagedQuoteCustomField
  setCustomType: SetStagedQuoteCustomType
  setValidTo: SetStagedQuoteValidTo
  transitionState: TransitionStagedQuoteState
}

type StagedQuoteValidToSet implements MessagePayload {
  validTo: DateTime
  type: String!
}

type StagedStandalonePrice {
  value: BaseMoney!
  discounted: DiscountedProductPriceValue
}

"""
StandalonePrices are managed and queried through the StandalonePrices API
and associated to a ProductVariant through the sku field.
"""
type StandalonePrice implements Versioned {
  id: String!
  version: Long!
  key: String
  sku: String!
  value: BaseMoney!
  country: Country
  customerGroupRef: Reference
  customerGroup: CustomerGroup
  channelRef: Reference
  channel: Channel
  validFrom: DateTime
  validUntil: DateTime
  tiers: [ProductPriceTier!]
  discounted: DiscountedProductPriceValue
  staged: StagedStandalonePrice
  custom: CustomFieldsType
  active: Boolean!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type StandalonePriceActiveChanged implements MessagePayload {
  active: Boolean!
  oldActive: Boolean!
  type: String!
}

type StandalonePriceCreated implements MessagePayload {
  standalonePrice: StandalonePrice!
  type: String!
}

type StandalonePriceDeleted implements MessagePayload {
  sku: String
  type: String!
}

type StandalonePriceDiscountSet implements MessagePayload {
  discounted: DiscountedProductPriceValue
  type: String!
}

type StandalonePriceExternalDiscountSet implements MessagePayload {
  discounted: DiscountedProductPriceValue
  type: String!
}

type StandalonePriceKeySet implements MessagePayload {
  key: String
  oldKey: String
  type: String!
}

type StandalonePriceQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [StandalonePrice!]!
}

type StandalonePriceStagedChangesApplied implements MessagePayload {
  stagedChanges: StagedStandalonePrice!
  type: String!
}

type StandalonePriceStagedChangesRemoved implements MessagePayload {
  stagedChanges: StagedStandalonePrice
  type: String!
}

type StandalonePriceTierAdded implements MessagePayload {
  tier: ProductPriceTier!
  type: String!
}

type StandalonePriceTierRemoved implements MessagePayload {
  tier: ProductPriceTier!
  type: String!
}

type StandalonePriceTiersSet implements MessagePayload {
  tiers: [ProductPriceTier!]!
  previousTiers: [ProductPriceTier!]!
  type: String!
}

input StandalonePriceUpdateAction {
  applyStagedChanges: ApplyStagedChanges
  changeActive: ChangeStandalonePriceActive
  changeValue: ChangeStandalonePriceValue
  setKey: SetStandalonePriceKey
  setDiscountedPrice: SetStandalonePriceDiscountedPrice
  setCustomField: SetStandalonePriceCustomFields
  setCustomType: CustomFieldsDraft
  setValidFromAndUntil: SetStandalonePriceValidFromAndUntil
  setValidFrom: SetStandalonePriceValidFrom
  setValidUntil: SetStandalonePriceValidUntil
  addPriceTier: AddStandalonePriceTier
  removePriceTier: RemoveStandalonePriceTier
  removeStagedChanges: RemoveStagedChanges
  setPriceTiers: SetStandalonePriceTiers
}

type StandalonePriceValidFromAndUntilSet implements MessagePayload {
  validFrom: DateTime
  validUntil: DateTime
  previousValidFrom: DateTime
  previousValidUntil: DateTime
  type: String!
}

type StandalonePriceValidFromSet implements MessagePayload {
  validFrom: DateTime
  previousValidFrom: DateTime
  type: String!
}

type StandalonePriceValidUntilSet implements MessagePayload {
  validUntil: DateTime
  previousValidUntil: DateTime
  type: String!
}

type StandalonePriceValueChanged implements MessagePayload {
  value: BaseMoney!
  staged: Boolean!
  oldValue: BaseMoney
  type: String!
}

"[State](https://docs.commercetools.com/api/projects/states)"
type State implements Versioned & ReferenceExpandable {
  id: String!
  version: Long!
  key: String
  type: StateType!
  roles: [StateRole!]!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  builtIn: Boolean!
  transitionsRef: [Reference!]
  transitions: [State!]
  initial: Boolean!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

input StateDraft {
  key: String!
  type: StateType!
  name: [LocalizedStringItemInputType!]
  description: [LocalizedStringItemInputType!]
  initial: Boolean
  roles: [StateRole!]
  transitions: [ReferenceInput!]
}

type StateQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [State!]!
}

enum StateRole {
  Return
  ReviewIncludedInStatistics
}

enum StateType {
  LineItemState
  OrderState
  PaymentState
  ProductState
  QuoteRequestState
  QuoteState
  ReviewState
  StagedQuoteState
}

input StateUpdateAction {
  addRoles: AddStateRoles
  changeInitial: ChangeStateInitial
  changeKey: ChangeStateKey
  changeType: ChangeStateType
  removeRoles: RemoveStateRoles
  setDescription: SetStateDescription
  setName: SetStateName
  setRoles: SetStateRoles
  setTransitions: SetStateTransitions
}

"Stores allow defining different contexts for a project."
type Store implements Versioned & ReferenceExpandable {
  id: String!
  version: Long!
  key: String!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  languages: [Locale!]
  countries: [StoreCountry!]
  productSelections: [ProductSelectionSetting!]!
  distributionChannelsRef: [Reference!]!
  distributionChannels: [Channel!]!
  supplyChannelsRef: [Reference!]!
  supplyChannels: [Channel!]!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  custom: CustomFieldsType
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type StoreCountriesChanged implements MessagePayload {
  addedCountries: [StoreCountry!]
  removedCountries: [StoreCountry!]
  type: String!
}

type StoreCountry {
  code: Country!
}

input StoreCountryInput {
  code: Country!
}

type StoreCreated implements MessagePayload {
  languages: [Locale!]!
  custom: CustomFieldsType
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  productSelections: [ProductSelectionSetting!]!
  distributionChannels: [Channel!]!
  supplyChannels: [Channel!]!
  countries: [StoreCountry!]
  distributionChannelsRef: [Reference!]!
  supplyChannelsRef: [Reference!]!
  productSelectionsRef: [Reference!]!
  nameAllLocales: [LocalizedString!]
  type: String!
}

type StoreDeleted implements MessagePayload {
  type: String!
}

type StoreDistributionChannelsChanged implements MessagePayload {
  addedDistributionChannels: [Channel!]
  removedDistributionChannels: [Channel!]
  addedDistributionChannelsRef: [Reference!]
  removedDistributionChannelsRef: [Reference!]
  type: String!
}

type StoreLanguagesChanged implements MessagePayload {
  addedLanguages: [Locale!]
  removedLanguages: [Locale!]
  type: String!
}

type StoreLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type StoreLimitsProjection {
  productSelections: Limit!
  inventorySupplyChannels: Limit!
  productDistributionChannels: Limit!
  total: StoreLimitWithCurrent!
}

type StoreNameSet implements MessagePayload {
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  type: String!
}

type StoreProductSelectionsChanged implements MessagePayload {
  addedProductSelections: [ProductSelectionSetting!]
  removedProductSelections: [ProductSelectionSetting!]
  updatedProductSelections: [ProductSelectionSetting!]
  type: String!
}

type StoreQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Store!]!
}

type StoreSupplyChannelsChanged implements MessagePayload {
  addedSupplyChannels: [Channel!]
  removedSupplyChannels: [Channel!]
  addedSupplyChannelsRef: [Reference!]
  removedSupplyChannelsRef: [Reference!]
  type: String!
}

input StoreUpdateAction {
  addProductSelection: AddStoreProductSelection
  addCountry: AddStoreCountry
  addDistributionChannel: AddStoreDistributionChannel
  addSupplyChannel: AddStoreSupplyChannel
  changeProductSelectionActive: ChangeStoreProductSelectionActive
  removeProductSelection: RemoveStoreProductSelection
  removeCountry: RemoveStoreCountry
  removeDistributionChannel: RemoveStoreDistributionChannel
  removeSupplyChannel: RemoveStoreSupplyChannel
  setProductSelections: SetStoreProductSelections
  setCountries: SetStoreCountries
  setCustomField: SetStoreCustomField
  setCustomType: SetStoreCustomType
  setDistributionChannels: SetStoreDistributionChannels
  setLanguages: SetStoreLanguages
  setName: SetStoreName
  setSupplyChannels: SetStoreSupplyChannels
}

type StringAttribute implements Attribute {
  value: String!
  name: String!
}

type StringField implements CustomField {
  value: String!
  name: String!
}

type StringType implements FieldType {
  name: String!
}

type SubRate {
  name: String!
  amount: Float!
}

input SubRateDraft {
  name: String!
  amount: Float!
}

input SubscriptionDraft {
  key: String
  destination: DestinationInput!
  messages: [MessageSubscriptionInput!]
  changes: [ChangeSubscriptionInput!]
  format: SubscriptionFormatInput
}

input SubscriptionFormatInput {
  Platform: PlatformFormatInput
  CloudEvents: CloudEventsSubscriptionsFormatInput
}

enum SubscriptionHealthStatus {
  ConfigurationError
  ConfigurationErrorDeliveryStopped
  Healthy
  TemporaryError
  ManuallySuspended
}

input SubscriptionUpdateAction {
  changeDestination: ChangeSubscriptionDestination
  setChanges: SetSubscriptionChanges
  setKey: SetSubscriptionKey
  setMessages: SetSubscriptionMessages
}

type SubscriptionsLimitsProjection {
  maxSubscriptions: Limit!
}

type SuggestResult {
  searchKeywords: [SuggestResultEntry!]!
}

type SuggestResultEntry {
  locale: Locale!
  suggestions: [Suggestion!]!
}

interface SuggestTokenizer {
  type: String!
}

interface SuggestTokenizerProductSearch {
  type: String!
}

type Suggestion {
  text: String!
}

"Stores information about order synchronization activities (like export or import)."
type SyncInfo {
  channelRef: Reference!
  channel: Channel
  externalId: String
  syncedAt: DateTime!
}

input TargetReferenceInput {
  typeId: String!
  id: String
  key: String
}

enum TaxCalculationMode {
  """
  Default. This calculation mode calculates the taxes after the unit price is multiplied with the quantity.
  E.g. `($1.08 * 3 = $3.24) * 1.19 = $3.8556 -> $3.86 rounded`
  """
  LineItemLevel

  """
  This calculation mode calculates the taxes on the unit price before multiplying with the quantity.
  E.g. `($1.08 * 1.19 = $1.2852 -> $1.29 rounded) * 3 = $3.87`
  """
  UnitPriceLevel
}

"Tax Categories define how products are to be taxed in different countries."
type TaxCategory implements Versioned & ReferenceExpandable {
  name: String!
  description: String
  rates: [TaxRate!]!
  key: String
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

input TaxCategoryAddTaxRate {
  taxRate: TaxRateDraft!
}

input TaxCategoryChangeName {
  name: String!
}

input TaxCategoryDraft {
  name: String!
  description: String
  rates: [TaxRateDraft!]
  key: String
}

type TaxCategoryLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type TaxCategoryLimitsProjection {
  total: TaxCategoryLimitWithCurrent!
}

type TaxCategoryQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [TaxCategory!]!
}

input TaxCategoryRemoveTaxRate {
  taxRateId: String
  taxRateKey: String
}

input TaxCategoryReplaceTaxRate {
  taxRateId: String
  taxRateKey: String
  taxRate: TaxRateDraft!
}

input TaxCategorySetDescription {
  description: String
}

input TaxCategoryUpdateAction {
  changeName: TaxCategoryChangeName
  setDescription: TaxCategorySetDescription
  addTaxRate: TaxCategoryAddTaxRate
  replaceTaxRate: TaxCategoryReplaceTaxRate
  removeTaxRate: TaxCategoryRemoveTaxRate
  setKey: SetTaxCategoryKey
}

enum TaxMode {
  "No taxes are added to the cart."
  Disabled

  """
  The tax rates are set externally per ExternalTaxRateDraft. A cart with this tax mode can only be ordered if all
  line items, all custom line items and the shipping method have an external tax rate set. The totalNet and
  totalGross as well as the taxPortions fields are calculated according to the taxRoundingMode.
  """
  External

  """
  The tax amounts and the tax rates as well as the tax portions are set externally per ExternalTaxAmountDraft.
  A cart with this tax mode can only be ordered if the cart itself and all line items, all custom line items and
  the shipping method have an external tax amount and rate set
  """
  ExternalAmount

  """
  The tax rates are selected from the TaxCategories based on the cart shipping address.
  The totalNet and totalGross as well as the taxPortions fields are calculated according to the
  taxRoundingMode.
  """
  Platform
}

"""
Represents the portions that sum up to the totalGross field of a TaxedPrice. The portions are calculated
from the TaxRates. If a tax rate has SubRates, they are used and can be identified by name. Tax portions
from line items that have the same rate and name will be accumulated to the same tax portion.
"""
type TaxPortion {
  rate: Float!
  amount: Money!
  name: String
}

input TaxPortionDraft {
  name: String
  rate: Float!
  amount: MoneyInput!
}

type TaxRate {
  name: String!
  amount: Float!
  includedInPrice: Boolean!
  country: Country!
  state: String
  id: String
  key: String
  subRates: [SubRate!]!
}

input TaxRateDraft {
  name: String!
  amount: Float
  includedInPrice: Boolean!
  country: Country!
  state: String
  subRates: [SubRateDraft!] = []
  key: String
}

input TaxRateInput {
  name: String!
  amount: Float!
  includedInPrice: Boolean!
  country: Country!
  state: String
  id: String
  key: String
  subRates: [SubRateDraft!] = []
}

type TaxedItemPrice {
  totalNet: Money!
  totalGross: Money!
  taxPortions: [TaxPortion!]!
  totalTax: Money
}

type TaxedPrice {
  totalNet: Money!
  totalGross: Money!
  taxPortions: [TaxPortion!]!
  totalTax: Money
}

input TaxedPriceDraft {
  totalNet: BaseMoneyInput!
  totalGross: BaseMoneyInput!
  taxPortions: [TaxPortionDraft!]!
  totalTax: BaseMoneyInput
}

type TermCount {
  term: String!
  count: Int!
  productCount: Int
}

input TermsFacetInput {
  path: String!
  alias: String
  countProducts: Boolean! = false
}

type TermsFacetResult implements FacetResult {
  dataType: String!
  missing: Int!
  total: Int!
  other: Int!
  terms: [TermCount!]!
  type: String!
}

type TextAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

"UI hint telling what kind of edit control should be displayed for a text attribute."
enum TextInputHint {
  SingleLine
  MultiLine
}

type TextLineItem {
  id: String!
  key: String
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  quantity: Int!
  custom: CustomFieldsType
  addedAt: DateTime!
}

input TextLineItemDraft {
  key: String
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  quantity: Int = 1
  custom: CustomFieldsDraft
  addedAt: DateTime
}

"Time is a scalar value that represents an ISO8601 formatted time."
scalar Time

type TimeAttribute implements Attribute {
  value: Time!
  name: String!
}

type TimeAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type TimeField implements CustomField {
  value: Time!
  name: String!
}

type TimeType implements FieldType {
  name: String!
}

type TrackingData {
  trackingId: String
  carrier: String
  provider: String
  providerTransaction: String
  isReturn: Boolean!
}

input TrackingDataDraftType {
  trackingId: String
  carrier: String
  provider: String
  providerTransaction: String
  isReturn: Boolean = false
}

type Transaction {
  id: String!
  timestamp: DateTime
  type: TransactionType
  amount: Money!
  interactionId: String
  state: TransactionState!
  custom: CustomFieldsType
}

input TransactionDraft {
  timestamp: DateTime
  type: TransactionType!
  amount: MoneyInput!
  interactionId: String
  state: TransactionState
  custom: CustomFieldsDraft
}

enum TransactionState {
  Failure
  Initial
  Pending
  Success
}

enum TransactionType {
  Authorization
  CancelAuthorization
  Charge
  Chargeback
  Refund
}

input TransitionOrderCustomLineItemState {
  customLineItemId: String
  customLineItemKey: String
  quantity: Long!
  fromState: ResourceIdentifierInput!
  toState: ResourceIdentifierInput!
  actualTransitionDate: DateTime
}

input TransitionOrderLineItemState {
  lineItemId: String
  lineItemKey: String
  quantity: Long!
  fromState: ResourceIdentifierInput!
  toState: ResourceIdentifierInput!
  actualTransitionDate: DateTime
}

input TransitionOrderState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}

input TransitionPaymentState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}

input TransitionProductState {
  state: ReferenceInput!
  force: Boolean
}

input TransitionQuoteRequestState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}

input TransitionQuoteState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}

input TransitionReviewState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}

input TransitionStagedOrderCustomLineItemState {
  customLineItemId: String
  customLineItemKey: String
  quantity: Long!
  fromState: ResourceIdentifierInput!
  toState: ResourceIdentifierInput!
  actualTransitionDate: DateTime
}

type TransitionStagedOrderCustomLineItemStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String
  customLineItemKey: String
  quantity: Long!
  fromStateResId: ResourceIdentifier!
  toStateResId: ResourceIdentifier!
  actualTransitionDate: DateTime
}

input TransitionStagedOrderLineItemState {
  lineItemId: String
  lineItemKey: String
  quantity: Long!
  fromState: ResourceIdentifierInput!
  toState: ResourceIdentifierInput!
  actualTransitionDate: DateTime
}

type TransitionStagedOrderLineItemStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String
  lineItemKey: String
  quantity: Long!
  fromStateResId: ResourceIdentifier!
  toStateResId: ResourceIdentifier!
  actualTransitionDate: DateTime
}

input TransitionStagedOrderState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}

type TransitionStagedOrderStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  stateResId: ResourceIdentifier!
  force: Boolean!
}

input TransitionStagedQuoteState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}

input TreeFilterInput {
  path: String!
  rootValues: [String!]!
  subTreeValues: [String!]!
}

type Trigger {
  resourceTypeId: String!
  actions: [ActionType!]!
  condition: String
}

input TriggerInput {
  resourceTypeId: String!
  actions: [ActionType!]
  condition: String
}

"Types allow you to define additional project-specific fields on resources and data types, so-called Custom Fields."
type TypeDefinition implements Versioned & ReferenceExpandable {
  key: String!
  name(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  description(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  descriptionAllLocales: [LocalizedString!]
  resourceTypeIds: [String!]!
  fieldDefinitions(
    """
    The names of the custom field definitions to include.

    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    includeNames: [String!],

    """
    The names of the custom field definitions to exclude.

    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    excludeNames: [String!]): [FieldDefinition!]!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

input TypeDefinitionDraft {
  key: String!
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  resourceTypeIds: [String!]!
  fieldDefinitions: [FieldDefinitionInput!]
}

type TypeDefinitionQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [TypeDefinition!]!
}

input TypeUpdateAction {
  addEnumValue: AddTypeEnumValue
  addFieldDefinition: AddTypeFieldDefinition
  addLocalizedEnumValue: AddTypeLocalizedEnumValue
  changeEnumValueLabel: ChangeTypeEnumValueLabel
  changeEnumValueOrder: ChangeTypeEnumValueOrder
  changeLabel: ChangeTypeLabel
  changeFieldDefinitionOrder: ChangeTypeFieldDefinitionOrder
  changeInputHint: ChangeTypeInputHint
  changeLocalizedEnumValueLabel: ChangeTypeLocalizedEnumValueLabel
  changeLocalizedEnumValueOrder: ChangeTypeLocalizedEnumValueOrder
  changeKey: ChangeTypeKey
  changeName: ChangeTypeName
  removeFieldDefinition: RemoveTypeFieldDefinition
  setDescription: SetTypeDescription
}

input UnfreezeCart {
  dummy: String
}

input UnpublishProduct {
  dummy: String
}

input UnpublishTailoring {
  dummy: String
}

input UpdateCartItemShippingAddress {
  address: AddressInput!
}

input UpdateOrderItemShippingAddress {
  address: AddressInput!
}

input UpdateOrderSyncInfo {
  channel: ResourceIdentifierInput!
  syncedAt: DateTime
  externalId: String
}

input UpdateStagedOrderItemShippingAddress {
  address: AddressInput!
}

type UpdateStagedOrderItemShippingAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft!
}

input UpdateStagedOrderSyncInfo {
  channel: ResourceIdentifierInput!
  syncedAt: DateTime
  externalId: String
}

type UpdateStagedOrderSyncInfoOutput implements StagedOrderUpdateActionOutput {
  type: String!
  channelResId: ChannelReferenceIdentifier!
  syncedAt: DateTime
  externalId: String
}

type UserProvidedIdentifiers {
  key: String
  orderNumber: String
  customerNumber: String
  externalId: String
  sku: String
  slug(
    "String is defined for different locales. This argument specifies the desired locale."
    locale: Locale,

    "List of languages the client is able to understand, and which locale variant is preferred."
    acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]
}

type ValueFacetResult implements FacetResult {
  count: Int!
  productCount: Int
  type: String!
}

input ValueFilterInput {
  path: String!
  values: [String!]!
}

"BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta"
type VariantTailoring {
  images: [Image!]!
  assets: [Asset!]!
}

"Versioned object have an ID and version and modification. Every update of this object changes it's version."
interface Versioned {
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type WhitespaceSuggestTokenizer implements SuggestTokenizer {
  type: String!
}

input WhitespaceSuggestTokenizerInput {
  dummy: String
}

type WhitespaceSuggestTokenizerProductSearch implements SuggestTokenizerProductSearch {
  type: String!
}

"YearMonth is a scalar value that represents an ISO8601 formatted year and month."
scalar YearMonth

"Zones allow defining ShippingRates for specific Locations."
type Zone implements Versioned & ReferenceExpandable {
  name: String!
  key: String
  description: String
  locations: [Location!]!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}

type ZoneLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}

type ZoneLimitsProjection {
  total: ZoneLimitWithCurrent!
}

input ZoneLocation {
  country: Country!
  state: String
}

type ZoneQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  exists: Boolean!
  results: [Zone!]!
}

type ZoneRate {
  shippingRates: [ShippingRate!]!
  zoneRef: Reference
  zone: Zone
}

input ZoneRateDraft {
  zone: ResourceIdentifierInput!
  shippingRates: [ShippingRateDraft!] = []
}

input ZoneUpdateAction {
  addLocation: AddZoneLocation
  changeName: ChangeZoneName
  removeLocation: RemoveZoneLocation
  setDescription: SetZoneDescription
  setKey: SetZoneKey
}

input addAttributeDefinition {
  attributeDefinition: AttributeDefinitionDraft!
}

input addLocalizedEnumValue {
  attributeName: String!
  value: LocalizedEnumValueDraft!
}

input addPlainEnumValue {
  attributeName: String!
  value: PlainEnumValueDraft!
}

input changeAttributeName {
  attributeName: String!
  newAttributeName: String!
}

input changeAttributeOrder {
  attributeDefinitions: [AttributeDefinitionDraft!]!
}

input changeAttributeOrderByName {
  attributeNames: [String!]!
}

input changeDescription {
  description: String!
}

input changeEnumKey {
  attributeName: String!
  key: String!
  newKey: String!
}

input changeInputHint {
  attributeName: String!
  newValue: TextInputHint!
}

input changeIsSearchable {
  attributeName: String!
  isSearchable: Boolean!
}

input changeLabel {
  attributeName: String!
  label: [LocalizedStringItemInputType!]!
}

input changeLocalizedEnumValueLabel {
  attributeName: String!
  newValue: LocalizedEnumValueDraft!
}

input changeLocalizedEnumValueOrder {
  attributeName: String!
  values: [LocalizedEnumValueDraft!]!
}

input changeName {
  name: String!
}

input changePlainEnumValueLabel {
  attributeName: String!
  newValue: PlainEnumValueDraft!
}

input changePlainEnumValueOrder {
  attributeName: String!
  values: [PlainEnumValueDraft!]!
}

input removeAttributeDefinition {
  name: String!
}

input removeEnumValues {
  attributeName: String!
  keys: [String!]!
}

input setInputTip {
  attributeName: String!
  inputTip: [LocalizedStringItemInputType!]
}

input setKey {
  key: String
}
